<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="益达的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="益达的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="益达的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>益达的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">益达的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/javaCore的说明/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/javaCore的说明/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-18T19:56:16+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于javaCore"><a href="#关于javaCore" class="headerlink" title="关于javaCore"></a>关于javaCore</h3><p>一个JSVirtualMachine的实例就是一个完整独立的JavaScript的执行环境，为JavaScript的执行提供底层资源。</p>
<p>这个类主要用来做两件事情：</p>
<p>实现并发的JavaScript执行<br>JavaScript和Objective-C桥接对象的内存管理</p>
<p>每一个JavaScript上下文（JSContext对象）都归属于一个虚拟机（JSVirtualMachine）。每个虚拟机可以包含多个不同的上下文，并允许在这些不同的上下文之间传值（JSValue对象）。</p>
<p>然而，每个虚拟机都是完整且独立的，有其独立的堆空间和垃圾回收器（garbage collector ），GC无法处理别的虚拟机堆中的对象，因此你不能把一个虚拟机中创建的值传给另一个虚拟机。</p>
<p>线程和JavaScript的并发执行</p>
<p>JavaScriptCore API都是线程安全的。你可以在任意线程创建JSValue或者执行JS代码，然而，所有其他想要使用该虚拟机的线程都要等待。</p>
<p>如果想并发执行JS，需要使用多个不同的虚拟机来实现。<br>可以在子线程中执行JS代码。</p>
<p>三个线程分别异步执行每秒1次的js log，首先会休眠1秒。</p>
<p>在context上执行一个休眠5秒的JS函数。</p>
<p>首先执行的应该是休眠5秒的JS函数，在此期间，context所处的虚拟机上的其他调用都会处于等待状态，因此tick和tick_2在前5秒都不会有执行。</p>
<p>而context1所处的虚拟机仍然可以正常执行tick_1。</p>
<p>休眠5秒结束后，tick和tick_2才会开始执行（不保证先后顺序）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/自动闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/自动闭包/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-14T09:31:24+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Swift的自动闭包（autoclosure-noescape-escape-）"><a href="#Swift的自动闭包（autoclosure-noescape-escape-）" class="headerlink" title="Swift的自动闭包（autoclosure,noescape,escape,??）"></a>Swift的自动闭包（autoclosure,noescape,escape,??）</h3><p>@autoclosure（自动闭包）</p>
<p> 1:自动闭包，顾名思义是一种自动创建的闭包，用于包装函数参数的表达式，可以说是一种简便语法.<br> 2:自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。<br> 3:自动闭包的好处之二是让你能够延迟求值,因为代码段不会被执行直到你调用这个闭包，这样你就可以控制代码什么时候执行。<br> 4：含有autoclosure特性的声明同时也具有noescape的特性，及默认是非逃逸闭包，除非传递可选参数escaping.如果传递了该参数，那么将可以在闭包之外进行操作闭包,形式为：请使用@autoclosure(escaping)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/其他rc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/其他rc/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-11T17:15:19+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基本信息：<br>关于class和struct的区别（网易的考题）</p>
<p>介绍下设计模式：<br>注意点：回答了NSNotificationCenter的可以直接pass</p>
<p>首先回答设计模式为了解决什么问题<br>其次是通过什么方案来解决这些问题<br>最后才是当前体系下的具体的实现方案</p>
<p>https链接的网站里面，输入账号密码点击登录后，到服务器返回这个请求前，中间经历了什么。</p>
<p>TCP的协议，<br>对于整个网络连接模型的理解可以看出基本功</p>
<p>关于UI的链式，在一个app中间有一个button，在你的手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么。<br>runloop和响应链需要说清楚<br>随便问问UIResponse ， UIControl , UIView之间的关系</p>
<p>组件化的解耦</p>
<p>蘑菇街的组件间通信，采用的是URL跳转模式，理论上页面之间的跳转只需要open一个URL即可。所以对一个组件来说，只要定义【支持哪些URL】即可，比如详情页面，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//注册进入到指定页面， 页面级别的路由和需要传入的参数</span><br><span class="line">[MGJRouter registerURLPattern:@"mgl://detail?id=id" toHandler:^(Dictionary *routerParam) &#123;</span><br><span class="line">	//获取指定的value的值</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">组件A调用组件B的，比如商品详情页面要调用展示购物车的商品数量，就涉及到想购物车组件拿数据</span><br><span class="line"></span><br><span class="line">[MGJRouter registerURLPattern:@"mgj://cart/orderCount" toObjectHandler:^id(NSDictionary *routerParamters) &#123;</span><br><span class="line"></span><br><span class="line">	//参数解析，然后获取对应的value的值</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">使用时，</span><br><span class="line">NSNumber *orderCount = [MGJRouter obejctForURL:@"mgj://catd/ordercount"]就这样，可以获取购物车里面的商品数量。</span><br><span class="line"></span><br><span class="line">稍微复杂但更加通用性的是使用协议【协议】 -&gt;  [类]绑定的方式，还是以购物车为例，购物车组件可以提供一个协议protocol</span><br><span class="line"></span><br><span class="line">@protocol MGJCart<span class="tag">&lt;<span class="name">NSObecjt</span>&gt;</span></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看到通过协议可以直接指定返回的数据类型，然后在购物车组件内新建个类实现这个协议，假设这个类名MGJCartImpl ,接着就可以把它与协议关联起来。</span><br><span class="line"></span><br><span class="line">[ModuleManager registerClass:MGJCartImpl forProtocol:@protocol(MGJCart)];</span><br><span class="line"></span><br><span class="line">需要调用[ModuleManagerClassForProtocol:@protocol(MGJCart)]，然后调用orderCount的就可以了。</span><br><span class="line"></span><br><span class="line">//入口方式，</span><br><span class="line"></span><br><span class="line">通过文件加载出所有的module的方式 然后通过调用module里面的application的协议事件来实现module的需要进行初始化的的事件，</span><br><span class="line"></span><br><span class="line">在app启动时，从入口调用</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/响应链路/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/响应链路/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-11T17:14:56+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="关于iOS的事件响应链路"><a href="#关于iOS的事件响应链路" class="headerlink" title="关于iOS的事件响应链路"></a>关于iOS的事件响应链路</h4><h5 id="事件链路"><a href="#事件链路" class="headerlink" title="事件链路"></a>事件链路</h5><p>当我们用手指轻触屏幕，首先是app的UIApplication对象接收到了这次点击事件，紧接着，UIApplication对象把这次事件传递给了UIWindow对象，UIWindow对象继续向他额子View对象进行传递，直到传递到最上层。<br>UIApplication对象 – UIWindow对象 – RootVC.view对象 –redView的对象</p>
<h5 id="响应链路"><a href="#响应链路" class="headerlink" title="响应链路"></a>响应链路</h5><p>响应者： 能够响应事件的对象都是UIResponse的子类对象<br>UIResponse提供了touchBegin等等四个方法来实现这个响应的过程。<br>确定响应链，能够响应事件的view一定是具备userInteractionEnable属性是yes.<br>最顶层的view发现点击事件是在自己的范围内的，且自己可以响应这个事件，那么他不用再向下传递，如果发现当前的视图自己不具备响应这个事件的能力，那么他会把事件向下继续传递，直到UIWindow层，如果发现依旧没有view可以响应对应的事件，那么这个响应事件就没有响应者，点击无效。<br>响应链的传递顺序： UIButton -&gt; UIView -&gt; FourthViewController -&gt; UITabBarController -&gt; UITransition -&gt; UIWindow -&gt; UIApplication -&gt; AppDelegate</p>
<p>关于细节点：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(id)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UIView *hitView = [super hitTest:point withEvent:event];</span><br><span class="line">    if (hitView == self)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return hitView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的用处是判断当前的点击或者触摸事件的点是否在当前的view中。它被hitTest:withEvent:调用，通过对每个子视图调用pointInside:withEvent:决定最终哪个视图来响应此事件。如果 PointInside:withEvent:返回YES，然后子视图的继承树就会被遍历（遍历顺序中最先响应的为：与用户最接近的那个视图。 it starts from the top-level subview），即子视图的子视图继续调用递归这个函数，直到找到可以响应的子视图（这个子视图的hitTest:withEvent:会返回self，而不是nil）；否则，视图的继承树就会被忽略。<br>   当我们需要重写某个UIView的继承类UIViewInherit的时候，如果需要重写hitTest:withEvent:方法，就会出现是否<br>调用[super hitTest:withEvent:]方法的疑问？究竟是否需要都是看具体需求，这里只是说明调与不调的效果。<br>    如果不调用，那么重写的方法hitTest:withEvent:只会调用重写后的代码，根据所重写的代码返回self或nil，如果返<br>回self那么你的这个UIViewInherit类会接受你的按键，然后调用touches系列方法；否则返回nil那么传递给UIViewInherit类的按键到此为止，<br>它不接受它的父view给它的按键，即不会调用touches系列方法。这时，PointInside:withEvent:几乎没有作用。<br>    如果调用，那么[super hitTest:withEvent:]方法首先是根据PointInside:withEvent:的返回值决定是否递归调用所<br>有子View的hitTest:withEvent:方法。对于子View的hitTest:withEvent:方法调用也是一样的过程，这样一直递<br>归下去，直到最先找到的某个递归层次上的子View的hitTest:withEvent:方法返回非nil，这时候，调用即结束，<br>最终会调用这个子View的touches系列方法。<br>如果我们不想让某个视图响应事件，只需要重载 PointInside:withEvent:方法，让此方法返回NO就行了。不过从这里，还是不能了解到hitTest:WithEvent的方法的用途。</p>
<p>几个适合使用的技术点：<br>1.扩大UIButton的响应热区，重载UIButton的-(BOOL)pointInside: withEvent:方法，让Point即使落在Button的Frame外围也返回YES。<br>2.子view超出了父view的bounds响应事件，重载父view的-(UIView *)hitTest: withEvent:方法，去掉点击必须在父view内的判断，然后子view就能成为 hit-test view用于响应事件了。（即不需要[self pointInside:point withEvent:event]）去限制view的大小</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/KVO/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/KVO/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-11T15:56:50+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="KVO基本原理："><a href="#KVO基本原理：" class="headerlink" title="KVO基本原理："></a>KVO基本原理：</h4><p>1.KVO是基于runtime机制实现的<br>2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制<br>3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person<br>4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法<br>5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</p>
<h4 id="KVO深入原理："><a href="#KVO深入原理：" class="headerlink" title="KVO深入原理："></a>KVO深入原理：</h4><p>1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：?NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter?方法，setter?方法会负责在调用原?setter?方法之前和之后，通知所有观察对象属性值的更改情况。<br>2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；<br>3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。<br>4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）?因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。<br>5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath?的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath?的属性值已经变更；之后，?observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter?方法这种继承方式的注入是在运行时而不是编译时实现的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1829339-77757288cc139f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/weak的原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/weak的原理/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-11T15:55:06+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="weak实现原理："><a href="#weak实现原理：" class="headerlink" title="weak实现原理："></a>weak实现原理：</h4><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。<br>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br>2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。<br>3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
<p>追问的问题一：实现weak后，为什么对象释放后会自动为nil？<br>runtime对注册的类， 会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，假如weak指向的对象内存地址是a，那么就会以a为键， 在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。</p>
<p>追问的问题二：当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？<br>1、调用objc_release<br>2、因为对象的引用计数为0，所以执行dealloc<br>3、在dealloc中，调用了_objc_rootDealloc函数<br>4、在_objc_rootDealloc中，调用了object_dispose函数<br>5、调用objc_destructInstance<br>6、最后调用objc_clear_deallocating,详细过程如下：<br>a. 从weak表中获取废弃对象的地址为键值的记录<br>b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil<br>c. 将weak表中该记录删除<br>d. 从引用计数表中删除废弃对象的地址为键值的记录</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/GCD技术基础点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/GCD技术基础点/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-09T10:15:41+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于多线程的理解：</p>
<p>pthread的特点：<br>一套通用的多线程api，适用于Unix，Linux，Windows等系统<br>跨平台\可移植，使用难度大，C语言，使用的频率，几乎不用<br>线程生命周期： 由程序员进行管理</p>
<p>NSThread：<br>使用更加面向对象 简单易用，可以直接操作线程对象，使用的OC语言进行封装，使用的频率：偶尔使用。线程的生命周期： 由程序员进行管理</p>
<p>GCD：<br>旨在代替NSThread等线程技术，充分利用设备的多核（自动），使用语言是C语言，使用频率：经常使用，线程生命周期：自动管理</p>
<p>NSOperation：<br>基于GCD，比CGD多了一些更加简单实用的功能，使用面向对象，使用语言：OC语言，使用频率：经常使用，生命周期管理：自动管理</p>
<p>多线程的原理：<br>同一时间，CPU只能处理1条线程，只有一条线程在工作，<br>多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）<br>如果CPU调度线程的时间足够快，就造成了都线程并发执行的假象</p>
<p>思考点？？<br>如果线程非常非常多，会发生什么情况？<br>CPU会在N多个线程之前调度，CPU会累死，消耗大量的CPU资源。<br>每条线程被调度执行的频次会降低（线程的执行效率降低）</p>
<p>多线程的优点：<br>能适当提高程序的执行效率，能适当提高资源的利用率（CPU，内存利用率）</p>
<p>多线程的缺点：<br>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M， 子线程占用512kb，如果开启大量的线程，会占用大量的内存空间，降低程序的性能）<br>线程越多，CPU在调度线程上开销就越大<br>程序设计更加复杂：比如线程之间的通信，多线程的数据共享</p>
<p>更倾向于哪一种通信方式：<br>GCD技术是一个轻量的，底层实现隐藏的神奇技术，我们能够通过GCD和block轻松的实现多线程编程，有时候，CGD相比其他系统提供的多线程方法更加有效，当然，有时候GCD不是最佳选择，另一个多线程编程的技术</p>
<p>NSOperationQueue让我们能够将后台线程以队列方式依序执行，并提供更多操作的入口，这和GCD的实现有些类似。</p>
<p>CGD和NSOperationQueue的区别：<br>CGD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象，在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构，而Operation作为一个对象，为我们提供了更多的选择。<br>在NSOperationQueue中，我们可以随时取消已经设定要准备的任务，（当然，已经开始的任务就无法阻止了，）而GCD没法停止已经加入Queue的block（其实是有的，但是需要需要更多复杂的代码实现）<br>NSOperation能够方便的设置依赖关系，我们可以让一个Operation依赖另一个Operation，这样的话，尽管两个NSOperation处于同一个并行队列中，但前者会到后者执行完毕后再执行。<br>我们将KVO应用在NSOperation中，可以监听一个Operation是否完成或者取消，这样子能比GCD更加有效的掌控我们执行的后台任务。<br>NSOperation可以设置NSOperation的priority优先级，能够使用同一个队列中的任务区分先后地执行，而在GCD中，我们只能区分不同的任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码。<br>我们能够对NSOperation进行继承，在这之上添加变量和成员方法，提高整个代码的复用度，这比简单的将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。<br>总的来说，OperationQueue提供了更多你在编写程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口，从编程原则来说，一般我们需要尽可能的使用高等级，封装完美的API，在必须时才使用底层API，但如果能以更简单的底层代码实现时，CGD确实是更好的选择。</p>
<p>使用NSOperation的情况： 各个操作之间有依赖关系，操作需要取消暂停，并发管理 ，控制操作之间的优先级，限制同时能执行的线程数量，让线程在某个时刻停止或者继续等。</p>
<p>使用GCD的情况： 一般的需求很简单的多线程操作，用GCD都可以，简单高效</p>
<p>GCD的执行原理：<br>GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？）</p>
<p>而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。</p>
<p>如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。</p>
<p>如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。</p>
<p>这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5至8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3至5条最为合理。</p>
<p>关于gcd的原理的执行案例：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@("1"));</span><br><span class="line">dispatch_sync(dispatch_get_main_queue(),^&#123;</span><br><span class="line">	NSLog(@"2");</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@"3");</span><br><span class="line">执行的结果是：1</span><br><span class="line"></span><br><span class="line">NSLog(@"1");</span><br><span class="line">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0)^&#123;</span><br><span class="line">	NSLog(@"2");</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@("3"));</span><br><span class="line">执行顺序： 1 2 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dispath_queue_t queue = dispatch_queue_create("com.demo.serialQueue",DISPATCH_QUEUE_SERIAL);</span><br><span class="line">NSLog(@"1");</span><br><span class="line">dispatch_aync(queue,^&#123;</span><br><span class="line">	NSLog(@"2");</span><br><span class="line">    dispatch_sync(queue,^&#123;</span><br><span class="line">    	NSLog("3");//任务3</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(""4);//任务4</span><br><span class="line">&#125;)；</span><br><span class="line">NSLog(@"5");//任务5</span><br><span class="line">执行的顺序： 1， 2 ，5  或者  1， 5， 2</span><br><span class="line"></span><br><span class="line">NSLog(@"1");</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0,0),^&#123;</span><br><span class="line">	NSLog(@"2");</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(),^&#123;</span><br><span class="line">    	NSLog(@"3");</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@"4");</span><br><span class="line">&#125;)</span><br><span class="line">NSLog(@"5");</span><br><span class="line">输出结果： 1， 2， 5, 3, 4</span><br><span class="line"></span><br><span class="line">关于主线程出现死循环的情况</span><br><span class="line">dispatch_aynsc(dispatch_get_global_queue(0,0),^&#123;</span><br><span class="line">	NSLog(@"1");</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(),^&#123;</span><br><span class="line">    	NSLog(@"2");</span><br><span class="line">    &#125;)</span><br><span class="line">    NSLog(@"3");</span><br><span class="line">&#125;)</span><br><span class="line">NSLog(@"4");</span><br><span class="line">while(1) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">NSLog(@"5");</span><br><span class="line"></span><br><span class="line">输出结果： 1，</span><br></pre></td></tr></table></figure></p>
<p>iOS8之前队列优先级：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH 2高优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT 0默认优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW (-2)低优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN后台优先级</span><br><span class="line">iOS8+之后：</span><br><span class="line">QOS_CLASS_USER_INTERACTIVE 0x21, 用户交互(希望尽快完成，不要放太耗时操作)</span><br><span class="line">QOS_CLASS_USER_INITIATED 0x19, 用户期望(不要放太耗时操作)</span><br><span class="line">QOS_CLASS_DEFAULT 0x15, 默认(用来重置对列使用的)</span><br><span class="line">QOS_CLASS_UTILITY 0x11, 实用工具(耗时操作，可以使用这个选项)</span><br><span class="line">QOS_CLASS_BACKGROUND 0x09, 后台</span><br><span class="line">QOS_CLASS_UNSPECIFIED 0x00, 未指定</span><br></pre></td></tr></table></figure></p>
<p>NSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用、代码可读性也更高。</p>
<p>NSOperation需要配合NSOperationQueue来实现多线程。因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。</p>
<p>因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：</p>
<p>创建任务：先将需要执行的操作封装到一个NSOperation对象中。<br>创建队列：创建NSOperationQueue对象。<br>将任务加入到队列中：然后将NSOperation对象添加到NSOperationQueue中。<br>之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。</p>
<p>三类封装类型：<br>使用子类NSInvocationOperation<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建NSInvocationOperation对象</span><br><span class="line">NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">// 2.调用start方法开始执行操作</span><br><span class="line">[op start];</span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@"------%@", [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">在没有使用NSOperationQueue，单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程中执行操作，并没有开启新线程。</span><br></pre></td></tr></table></figure></p>
<p>使用子类NSBlockOperation<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    // 在主线程</span><br><span class="line">    NSLog(@"------%@", [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[op start];</span><br><span class="line">在没有使用NSOperationQueue，单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程中执行操作，并没有开启新线程。</span><br><span class="line"></span><br><span class="line">// 添加额外的任务(在子线程执行)</span><br><span class="line">    [op addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@"2------%@", [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。</p>
<p>创建队列<br>NSOperationQueue一共有两种队列：主队列和其他队列，其中包含了串行，并发功能，<br>主队列：<br>NSOperationQueue *queue = [NSOperationQueue mainQueue];</p>
<p>其他队列：（非主队列）<br>添加到这种队列的任务,（NSOperation），就会自动放到子线程中执行，同时包含了串行和并发功能。<br>NSOperationQueue *queue = [[NSOperationQueue alloc] init];</p>
<p>将任务加到队列中：<br>创建任务，然后将创建好的任务加入到创建好的队列中。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 1.创建队列</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    // 2. 创建操作</span><br><span class="line">    // 创建NSInvocationOperation</span><br><span class="line">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    // 创建NSBlockOperation</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i <span class="tag">&lt; <span class="attr">2</span>; ++<span class="attr">i</span>) &#123;</span></span><br><span class="line"><span class="tag">            <span class="attr">NSLog</span>(@"<span class="attr">1-----</span>%@", [<span class="attr">NSThread</span> <span class="attr">currentThread</span>]);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">    &#125;];</span></span><br><span class="line"><span class="tag">    // <span class="attr">3.</span> 添加操作到队列中：<span class="attr">addOperation:</span></span></span><br><span class="line"><span class="tag">    [<span class="attr">queue</span> <span class="attr">addOperation:op1</span>]; // [<span class="attr">op1</span> <span class="attr">start</span>]</span></span><br><span class="line"><span class="tag">    [<span class="attr">queue</span> <span class="attr">addOperation:op2</span>]; // [<span class="attr">op2</span> <span class="attr">start</span>]</span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">    // <span class="attr">1.</span> 创建队列</span></span><br><span class="line"><span class="tag">    <span class="attr">NSOperationQueue</span> *<span class="attr">queue</span> = <span class="string">[[NSOperationQueue</span> <span class="attr">alloc</span>] <span class="attr">init</span>];</span></span><br><span class="line"><span class="tag">    // <span class="attr">2.</span> 添加操作到队列中：<span class="attr">addOperationWithBlock:</span></span></span><br><span class="line"><span class="tag">    [<span class="attr">queue</span> <span class="attr">addOperationWithBlock:</span>^&#123;</span></span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            NSLog(@"-----%@", [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    可以看出，addOperationWithBlock和NSOperationQueue能够开启新线程，进行并发执行。</span><br></pre></td></tr></table></figure></p>
<p>控制串执行和并行执行的关键：<br>关键参数，maxConcurrentOperationCount, 最大并发数。<br>maxConcurrentOperationCount默认情况是-1，表示不进行限制，默认认为并发执行。<br>maxConcurrentOperationCount为1时，进行串行执行，<br>maxConcurrentOperationCount大于1时，指不能超过系统的限制，即使设置了，系统也会自动做调整。</p>
<p>操作依赖：<br>NSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">   NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       NSLog(@"1-----%@", [NSThread  currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       NSLog(@"2-----%@", [NSThread  currentThread]);</span><br><span class="line">   &#125;];</span><br><span class="line">   [op2 addDependency:op1];    // 让op2 依赖于 op1，则先执行op1，在执行op2</span><br><span class="line"></span><br><span class="line">   [queue addOperation:op1];</span><br><span class="line">   [queue addOperation:op2];</span><br></pre></td></tr></table></figure>
<p>其他的要点接口:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel; NSOperation提供的方法，可取消单个操作</span><br><span class="line"></span><br><span class="line">- (void)cancelAllOperations; NSOperationQueue提供的方法，可以取消队列的所有操作</span><br><span class="line"></span><br><span class="line">- (void)setSuspended:(BOOL)b; 可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列</span><br><span class="line"></span><br><span class="line">- (BOOL)isSuspended; 判断暂停状态</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<p>这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。<br>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/iOS自动化打包的知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/iOS自动化打包的知识点/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-02T10:06:31+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于iOS自动化打包工具的脚本<br><a href="https://github.com/hades0918/ipapy/blob/master/ipa.py" target="_blank" rel="noopener">https://github.com/hades0918/ipapy/blob/master/ipa.py</a><br>根据当前文件的路径来实现，从文件的拉取内容上来区分</p>
<p><a href="https://mp.weixin.qq.com/s/iAkN0vPU0wQlv_feWVIc0g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iAkN0vPU0wQlv_feWVIc0g</a><br>关于iOS自动化打包的一些分享，</p>
<p>关于iOS和swift中涉及的iOS开源库<br><a href="http://blog.csdn.net/qq_16825363/article/details/70064228" target="_blank" rel="noopener">http://blog.csdn.net/qq_16825363/article/details/70064228</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/16/swift设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/16/swift设计模式/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-16T13:37:59+08:00">
                2018-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于swifter中的设计模式：</p>
<p>单例模式确保每个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会使用延时加载的策略，只在第一次需要使用的时候初始化。</p>
<p>注意：在 iOS 中单例模式很常见，NSUserDefaults.standardUserDefaults() 、 UIApplication.sharedApplication() 、 UIScreen.mainScreen() 、 NSFileManager.defaultManager() 这些都是单例模式。</p>
<p>你可能会疑惑了：如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？</p>
<p>某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。</p>
<p>单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。</p>
<p>如何使用单例模式<br>可以看下这个图：</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.6.png" alt=""><br>这是一个日志类，有一个属性 (是一个单例对象) 和两个方法 (sharedInstance() 和 init())。</p>
<p>第一次调用 sharedInstance() 的时候，instance 属性还没有初始化。所以我们要创建一个新实例并且返回。</p>
<p>下一次你再调用 sharedInstance() 的时候，instance 已经初始化完成，直接返回即可。这个逻辑确保了这个类只存在一个实例对象。</p>
<p>接下来我们继续完善单例模式，通过这个类来管理专辑数据。</p>
<p>注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。</p>
<p>在 LibraryAPI 里添加下面这段代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">class var sharedInstance: LibraryAPI &#123;</span><br><span class="line">    //2</span><br><span class="line">    struct Singleton &#123;</span><br><span class="line">        //3</span><br><span class="line">        static let instance = LibraryAPI()</span><br><span class="line">    &#125;</span><br><span class="line">    //4</span><br><span class="line">    return Singleton.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这几行代码里，做了如下工作：<br>创建一个计算类型的类变量，这个类变量，就像是 objc 中的静态方法一样，可以直接通过类访问而不用实例对象。具体可参见苹果官方文档的 [属性][10] 这一章。<br>在类变量里嵌套一个 Singleton 结构体。<br>Singleton 封装了一个静态的常量，通过 static 定义意味着这个属性只存在一个，注意 Swift 中 static 的变量是延时加载的，意味着 Instance 直到需要的时候才会被创建。同时再注意一下，因为它是一个常量，所以一旦创建之后不会再创建第二次。这些就是单例模式的核心所在：一旦初始化完成，当前类存在一个实例对象，初始化方法就不会再被调用。<br>返回计算后的属性值。<br>注意：更多的单例模式实例可以看看 Github 上的这个[示例][11]，列举了单例模式的若干种实现方式。<br>你现在可以将这个单例作为专辑管理类的入口，接下来我们继续创建一个处理专辑数据持久化的类。<br>新建 PersistencyManager.swift 并添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var albums = [Album]()</span><br></pre></td></tr></table></figure></p>
<p>在这里我们定义了一个私有属性，用来存储专辑数据。这是一个可变数组，所以你可以很容易的增加或者删除数据。</p>
<p>然后加上一些初始化的数据：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">  //Dummy list of albums</span><br><span class="line">  let album1 = Album(title: "Best of Bowie",</span><br><span class="line">         artist: "David Bowie",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png",</span><br><span class="line">         year: "1992")</span><br><span class="line"></span><br><span class="line">  let album2 = Album(title: "It's My Life",</span><br><span class="line">         artist: "No Doubt",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png",</span><br><span class="line">         year: "2003")</span><br><span class="line"></span><br><span class="line">  let album3 = Album(title: "Nothing Like The Sun",</span><br><span class="line">         artist: "Sting",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png",</span><br><span class="line">         year: "1999")</span><br><span class="line"></span><br><span class="line">  let album4 = Album(title: "Staring at the Sun",</span><br><span class="line">         artist: "U2",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png",</span><br><span class="line">         year: "2000")</span><br><span class="line"></span><br><span class="line">  let album5 = Album(title: "American Pie",</span><br><span class="line">         artist: "Madonna",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png",</span><br><span class="line">         year: "2000")</span><br><span class="line"></span><br><span class="line">  albums = [album1, album2, album3, album4, album5]</span><br><span class="line">&#125;</span><br><span class="line">在这个初始化方法里，我们初始化了五张专辑。如果上面的专辑没有你喜欢的，你可以随意替换成你的菜:]</span><br><span class="line"></span><br><span class="line">然后添加如下方法：</span><br><span class="line">func getAlbums() -&gt; [Album] &#123;</span><br><span class="line">  return albums</span><br><span class="line">&#125;</span><br><span class="line">func addAlbum(album: Album, index: Int) &#123;</span><br><span class="line">  if (albums.count &gt;= index) &#123;</span><br><span class="line">    albums.insert(album, atIndex: index)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    albums.append(album)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func deleteAlbumAtIndex(index: Int) &#123;</span><br><span class="line">  albums.removeAtIndex(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些方法可以让你自由的访问、添加、删除专辑数据。</p>
<p>这时你可以运行一下你的项目，确保编译通过以便进行下一步操作。</p>
<p>此时你或许会感到好奇： PersistencyManager 好像不是单例啊？是的，它确实不是单例。不过没关系，在接下来的外观模式章节，你会看到 LibraryAPI 和 PersistencyManager 之间的联系。</p>
<p>Model-View-Controller (缩写 MVC ) 是 Cocoa 框架的一部分，并且毋庸置疑是最常用的设计模式之一。它可以帮你把对象根据职责进行划分和归类。</p>
<p>作为划分依据的三个基本职责是：</p>
<p>模型层 (Model) ：存储数据并且定义如何操作这些数据。在我们的例子中，就是 Album 类。<br>视图层 (View) ：负责模型层的可视化展示，并且负责用户的交互，一般来说都是继承自 UIView 这个基类。在我们的项目中就是 AlbumView 这个类。<br>控制器 (Controller) ：控制器是整个系统的掌控者，它连接了模型层和数据层，并且把数据在视图层展示出来，监听各种事件，负责数据的各种操作。不妨猜猜在我们的项目中哪个是控制器？啊哈猜对了：ViewController 这个类就是。<br>如果你的项目遵循 MVC 的设计模式，那么各种对象要不是 Model ，要不是 View ，要不就是 Controller。当然在实际的开发中也可以灵活变化，比如结合具体业务使用 MVVM 结构给 ViewController 瘦瘦身，也是可以的。</p>
<p>三者之间的关系如下<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.4.png" alt=""><br>模型层通知控制器层任何数据的变化，然后控制器层会刷新视图层中的数据。视图层可以通知控制器层用户的交互事件，然后控制器会处理各种事件以及刷新数据。</p>
<p>你可能会感觉奇怪：为什么要把这三个东西分开来，而不能揉在一个类里呢？那样似乎更简单一点嘛。</p>
<p>Naive.</p>
<p>之所以这样做，是为了将代码更好的分离和重用。理想状态下，视图层应当和模型层完全分离。如果视图层不依赖任何模型层的具体实现，那么就可以很容易的被其他模型复用，用来展示不同的数据。</p>
<p>举个例子，比如在未来我们需要添加电影或者什么书籍，我们依旧可以使用 AlbumView 这个类作为展示。更久远点来说，在以后如果你创建了一个新的项目并且需要用到和专辑相关的内容，你可以直接复用 Album 类因为它并不依赖于任何视图模块。这就是 MVC 的强大之处，三大元素，各司其职，减少依赖。</p>
<p>如何使用 MVC 模式<br>首先，你需要确定你的项目中的每个类都是三大基本类型中的一种：控制器、模型、视图。不要在一个类里糅合多个角色。目前我们创建了 Album 类和 AlbumView 类是符合要求的，做得很好。</p>
<p>然后，为了确保你遵循这种模式，你最好创建三个项目分组来存放代码，分别是 Model、View、Controller，保持每个类型的文件分别独立。</p>
<p>接下来把 Album.swift 拖到 Model 分组，把 AlbumView.swift 拖到 View 分组，然后把 ViewController.swift 拖到 Controller 分组中。</p>
<p>现在你的项目应该是这个样子：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.5.png" alt=""><br>现在你的项目已经有点样子了，不再是各个文件颠沛流离居无定所了。显然你还会有其他分组和类，但是应用的核心就在这三个类里。</p>
<p>现在你的内容已经组织好了，接下来要做的就是获取专辑的数据。你将会创建一个 API 类来管理数据 - 这里我们会用到下一个设计模式：单例模式。</p>
<p>外观模式在复杂的业务系统上提供了简单的接口。如果直接把业务的所有接口直接暴露给使用者，使用者需要单独面对这一大堆复杂的接口，学习成本很高，而且存在误用的隐患。如果使用外观模式，我们只要暴露必要的 API 就可以了。</p>
<p>下图演示了外观模式的基本概念：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.8.png" alt=""></p>
<p>API 的使用者完全不知道这内部的业务逻辑有多么复杂。当我们有大量的类并且它们使用起来很复杂而且也很难理解的时候，外观模式是一个十分理想的选择。</p>
<p>外观模式把使用和背后的实现逻辑成功解耦，同时也降低了外部代码对内部工作的依赖程度。如果底层的类发生了改变，外观的接口并不需要做修改。</p>
<p>举个例子，如果有一天你想换掉所有的后台服务，你只需要修改 API 内部的代码，外部调用 API 的代码并不会有改动。</p>
<p>如何使用外观模式<br>现在我们用 PersistencyManager 来管理专辑数据，用 HTTPClient 来处理网络请求，项目中的其他类不应该知道这个逻辑。他们只需要知道 LibraryAPI 这个”外观”就可以了。</p>
<p>为了实现外观模式，应该只让 LibraryAPI 持有 PersistencyManager 和 HTTPClient 的实例，然后 LibraryAPI 暴露一个简单的接口给其他类来访问，这样外部的访问类不需要知道内部的业务具体是怎样的，也不用知道你是通过 PersistencyManager 还是 HTTPClient 获取到数据的。</p>
<p>大致的设计是这样的：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.9.png" alt=""><br>LibraryAPI 会暴露给其他代码访问，但是 PersistencyManager 和 HTTPClient 则是不对外开放的。</p>
<p>打开 LibraryAPI.swift 然后添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private let persistencyManager: PersistencyManager</span><br><span class="line">private let httpClient: HTTPClient</span><br><span class="line">private let isOnline: Bool</span><br></pre></td></tr></table></figure></p>
<p>除了两个实例变量之外，还有个 Bool 值： isOnline ，这个是用来标识当前是否为联网状态的，如果是联网状态就会去网络获取数据。</p>
<p>我们需要在 init 里面初始化这些变量：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">  persistencyManager = PersistencyManager()</span><br><span class="line">  httpClient = HTTPClient()</span><br><span class="line">  isOnline = false</span><br><span class="line"></span><br><span class="line">  super.init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HTTPClient 并不会直接和真实的服务器交互，只是用来演示外观模式的使用。所以 inOnline 这个值我们一直设置为 false。</p>
<p>接下来在 LibraryAPI.swift 里添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func getAlbums() -&gt; [Album] &#123;</span><br><span class="line">  return persistencyManager.getAlbums()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func addAlbum(album: Album, index: Int) &#123;</span><br><span class="line">  persistencyManager.addAlbum(album, index: index)</span><br><span class="line">  if isOnline &#123;</span><br><span class="line">    httpClient.postRequest("/api/addAlbum", body: album.description())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func deleteAlbum(index: Int) &#123;</span><br><span class="line">  persistencyManager.deleteAlbumAtIndex(index)</span><br><span class="line">  if isOnline &#123;</span><br><span class="line">    httpClient.postRequest("/api/deleteAlbum", body: "(index)")</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下 addAlbum(_:index:) 这个方法，先更新本地缓存，然后如果是联网状态还需要向服务器发送网络请求。这便是外观模式的强大之处：如果外部文件想要添加一个新的专辑，它不会也不用去了解内部的实现逻辑是怎么样的。</p>
<p>注意：当你设计外观的时候，请务必牢记：使用者随时可能直接访问你的隐藏类。永远不要假设使用者会遵循你当初的设计做事。</p>
<h3 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式 - Decorator"></a>装饰者模式 - Decorator</h3><p>装饰者模式可以动态的给指定的类添加一些行为和职责，而不用对原代码进行任何修改。当你需要使用子类的时候，不妨考虑一下装饰者模式，可以在原始类上面封装一层。</p>
<p>在 Swift 里，有两种方式实现装饰者模式：扩展 (Extension) 和委托 (Delegation)。</p>
<p>扩展<br>扩展是一种十分强大的机制，可以让你在不用继承的情况下，给已存在的类、结构体或者枚举类添加一些新的功能。最重要的一点是，你可以在你没有访问权限的情况下扩展已有类。这意味着你甚至可以扩展 Cocoa 的类，比如 UIView 或者 UIImage 。</p>
<p>举个例子，在编译时新加的方法可以像扩展类的正常方法一样执行。这和装饰器模式有点不同，因为扩展不会持有扩展类的对象。</p>
<p>如何使用扩展<br>想象一下这个场景，我们需要在下面这个列表里展示数据：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.11.png" alt=""><br>专辑标题从哪里来？ Album 本身是个 Model 对象，所以它不应该负责如何展示数据。你需要一些额外的代码添加展示数据的逻辑，但是为了保持 Model 的干净，我们不应该直接修改代码，因为这样不符合单一职责原则。 Model 层最好就是负责纯粹的数据结构，如果有数据的操作可以放到扩展中完成。</p>
<p>接下来我们会创建一个扩展，扩展现有的 Album 类，在扩展里定义了新的方法，返回更适合 UITableView 展示用的数据结构。</p>
<p>数据的结构大概是这样：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.12.png" alt=""><br>新建一个 Swift 文件：AlbumExtensions ，在里面添加如下扩展：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Album &#123;</span><br><span class="line">  func ae_tableRepresentation() -&gt; (titles:[String], values:[String]) &#123;</span><br><span class="line">    return (["Artist", "Album", "Genre", "Year"], [artist, title, genre, year])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在方法的前面有个 ae_ 前缀，是 AlbumExtension 的缩写，这样有利于和类的原有方法进行区分，避免使用的时候产生冲突。现在很多还在维护中的第三方库都已经改成了这个风格。</p>
<p>注意：类是可以重写父类方法的，但是在扩展里不可以。扩展里的方法和属性不能和原始类里的方法和属性冲突。</p>
<p>思考一下这个设计模式的强大之处：</p>
<p>我们可以直接在扩展里使用 Album 里的属性。<br>我们给 Album 类添加了内容但是并没有继承它，事实上，使用继承来扩展业务也可以实现一样的功能。<br>这个简单的扩展让我们可以更好地把 Album 的数据展示在 UITableView 里，而且不用修改源码。<br>委托<br>装饰者模式的另一种实现方案是委托。在这种机制下，一个对象可以和另一个对象相关联。比如你在用 UITableView ，你必须实现 tableView(_:numberOfRowsInSection:) 这个委托方法。</p>
<p>你不应该指望 UITableView 知道你有多少数据，这是个应用层该解决的问题。所以，数据相关的计算应该通过 UITableView 的委托来解决。这样可以让 UITableView 和数据层分别独立。视图层就负责显示数据，你递过来什么我就显示什么。</p>
<p>下面这张图很好的解释了 UITableView 的工作过程：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.13.png" alt=""><br>UITableView 的工作仅仅是展示数据，但是最终它需要知道自己要展示那些数据，这时就可以向它的委托询问。在 objc 的委托模式里，一个类可以通过协议来声明可选或者必须的方法。</p>
<p>看起来似乎继承然后重写必须的方法来的更简单一点。但是考虑一下这个问题：继承的结果必定是一个独立的类，如果你想让某个对象成为多个对象的委托，那么子类这招就行不通了。<br>注意：委托模式十分重要，苹果在 UIKit 中大量使用了该模式，基本上随处可见。</p>
<p>打开 ViewController.swift 文件，添加如下私有变量：</p>
<p>private var allAlbums = <a href="">Album</a><br>private var currentAlbumData : (titles:[String], values:[String])?<br>private var currentAlbumIndex = 0<br>在 viewDidLoad 里面加入如下内容：</p>
<p>override func viewDidLoad() {<br>    super.viewDidLoad()</p>
<pre><code>self.navigationController?.navigationBar.translucent = false
currentAlbumIndex = 0

allAlbums = LibraryAPI.sharedInstance.getAlbums()

dataTable.delegate = self
dataTable.dataSource = self
dataTable.backgroundView = nil
view.addSubview(dataTable!)
</code></pre><p>}<br>对上面三个部分进行拆解：</p>
<p>关闭导航栏的透明效果</p>
<p>通过 API 获取所有的专辑数据，记住，我们使用外观模式之后，应该从 LibraryAPI 获取数据，而不是 PersistencyManager 。</p>
<p>你可以在这里设置你的 UITablweView ，在这里声明了 UITableView 的 delegate 是当前的 ViewController 。事实上你用了 XIB 或者 StoryBoard ，可以直接在可视化的页面里拖拽完成。<br>接下来添加一个新的方法用来更方便的获取数据：</p>
<p>func showDataForAlbum(albumIndex: Int) {</p>
<pre><code>if (albumIndex &lt; allAlbums.count &amp;&amp; albumIndex &gt; -1) {

    let album = allAlbums[albumIndex]

    currentAlbumData = album.ae_tableRepresentation()
} else {
    currentAlbumData = nil
}

dataTable!.reloadData()
</code></pre><p>}<br>showDataForAlbum() 这个方法获取最新的专辑数据，当你想要展示新数据的时候，你需要调用 reloadData() 这个方法，这样 UITableView 就会向委托请求数据，比如有多少个 section 有多少个 row 之类的。</p>
<p>在 viewDidLoad 里面调用上面的方法：</p>
<p>self.showDataForAlbum(currentAlbumIndex)<br>这样应用一启动就会去加载当前的专辑数据。因为 currentAlbumIndex 的默认值是 0 ，所以一开始会默认显示第一章专辑的信息。</p>
<p>接下来我们该去完善 DataSource 的协议方法了。你可以直接把委托方法写在类里面，当然如果你想让你的代码看起来更整洁一点，则可以放在扩展里。</p>
<p>在文件底部添加如下方法，注意一定要放在类定义的大括号外面，因为这两个家伙不是类定义的一部分，它们是扩展：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: UITableViewDataSource &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ViewController: UITableViewDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是实现委托的方法 - 你可以把协议想象成是与委托之间的约定，只要你实现了约定的方法，就算是实现了委托。在我们的代码中， ViewController 需要遵守 UITableViewDataSource 和 UITableViewDelegate 的协议。这样 UITableView 才能确保必要的委托方法都已经实现了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在 UITableViewDataSource 对应的那个扩展里加上如下方法：</span><br><span class="line">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">  if let albumData = currentAlbumData &#123;</span><br><span class="line">    return albumData.titles.count</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">  var cell:UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as UITableViewCell</span><br><span class="line">  if let albumData = currentAlbumData &#123;</span><br><span class="line">    cell.textLabel?.text = albumData.titles[indexPath.row]</span><br><span class="line">      if let detailTextLabel = cell.detailTextLabel &#123;</span><br><span class="line">        detailTextLabel.text = albumData.values[indexPath.row]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br><span class="line">tableView(_:numberOfRowsInSection:) 返回需要展示的行数，和存储的数据中的 title 的数目相同。</span><br><span class="line"></span><br><span class="line">tableView(_:cellForRowAtIndexPath:) 创建并且返回了一个单元格，上面有标题和对应的值。</span><br></pre></td></tr></table></figure></p>
<p>注意：你可以把这些方法直接加在类声明里面，也可以放在扩展里，编译器不会去管数据源到底在哪里，只要能找到对应的方法就可以了。而我们之所以这样做，是为了方便其他人阅读。</p>
<h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 - Adapter"></a>适配器模式 - Adapter</h3><p>适配器把自己封装起来然后暴露统一的接口给其他类，这样即使其他类的接口各不相同，也能相安无事，一起工作。</p>
<p>如果你熟悉适配器模式，那么你会发现苹果在实现适配器模式的方式稍有不同：苹果通过委托实现了适配器模式。委托相信大家都不陌生。举个例子，如果一个类遵循了 NSCoying 的协议，那么它一定要实现 copy 方法。</p>
<p>如何使用适配器模式<br>横滑的滚动栏理论上应该是这个样子的：</p>
<p>新建一个 Swift 文件：HorizontalScroller.swift ，作为我们的横滑滚动控件， HorizontalScroller 继承自 UIView 。</p>
<p>打开 HorizontalScroller.swift 文件并添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol HorizontalScrollerDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这行代码定义了一个新的协议： HorizontalScrollerDelegate 。我们在前面加上了 @objc 的标记，这样我们就可以像在 objc 里一样使用 @optional 的委托方法了。</p>
<p>接下来我们在大括号里定义所有的委托方法，包括必须的和可选的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 在横滑视图中有多少页面需要展示</span><br><span class="line">func numberOfViewsForHorizontalScroller(scroller: HorizontalScroller) -&gt; Int</span><br><span class="line">// 展示在第 index 位置显示的 UIView</span><br><span class="line">func horizontalScrollerViewAtIndex(scroller: HorizontalScroller, index:Int) -&gt; UIView</span><br><span class="line">// 通知委托第 index 个视图被点击了</span><br><span class="line">func horizontalScrollerClickedViewAtIndex(scroller: HorizontalScroller, index:Int)</span><br><span class="line">// 可选方法，返回初始化时显示的图片下标，默认是0</span><br><span class="line">optional func initialViewIndex(scroller: HorizontalScroller) -&gt; Int</span><br><span class="line">​``` xml</span><br><span class="line">其中，没有 option 标记的方法是必须实现的，一般来说包括那些用来显示的必须数据，比如如何展示数据，有多少数据需要展示，点击事件如何处理等等，不可或缺；有 option 标记的方法为可选实现的，相当于是一些辅助设置和功能，就算没有实现也有默认值进行处理。</span><br><span class="line"></span><br><span class="line">在 HorizontalScroller 类里添加一个新的委托对象：</span><br><span class="line"></span><br><span class="line">weak var delegate: HorizontalScrollerDelegate?</span><br><span class="line">为了避免循环引用的问题，委托是 weak 类型。如果委托是 strong 类型的，当前对象持有了委托的强引用，委托又持有了当前对象的强引用，这样谁都无法释放就会导致内存泄露。</span><br><span class="line"></span><br><span class="line">委托是可选类型，所以很有可能当前类的使用者并没有指定委托。但是如果指定了委托，那么它一定会遵循 HorizontalScrollerDelegate 里约定的内容。</span><br><span class="line"></span><br><span class="line">再添加一些新的属性：</span><br><span class="line">​``` xml</span><br><span class="line">// 1</span><br><span class="line">private let VIEW_PADDING = 10</span><br><span class="line">private let VIEW_DIMENSIONS = 100</span><br><span class="line">private let VIEWS_OFFSET = 100</span><br><span class="line">// 2</span><br><span class="line">private var scroller : UIScrollView!</span><br><span class="line">// 3</span><br><span class="line">var viewArray = [UIView]()</span><br><span class="line">上面标注的三点分别做了这些事情：</span><br><span class="line"></span><br><span class="line">定义一个常量，用来方便的改变布局。现在默认的是显示的内容长宽为100，间隔为10。</span><br><span class="line">创建一个 UIScrollView 作为容器。</span><br><span class="line">创建一个数组用来存放需要展示的数据</span><br><span class="line">接下来实现初始化方法：</span><br><span class="line"></span><br><span class="line">override init(frame: CGRect) &#123;</span><br><span class="line">    super.init(frame: frame)</span><br><span class="line">    initializeScrollView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">required init(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    super.init(coder: aDecoder)</span><br><span class="line">    initializeScrollView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initializeScrollView() &#123;</span><br><span class="line">    //1</span><br><span class="line">    scroller = UIScrollView()</span><br><span class="line">    addSubview(scroller)</span><br><span class="line"></span><br><span class="line">    //2</span><br><span class="line">    scroller.setTranslatesAutoresizingMaskIntoConstraints(false)</span><br><span class="line">    //3</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Leading, relatedBy: .Equal, toItem: self, attribute: .Leading, multiplier: 1.0, constant: 0.0))</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Trailing, relatedBy: .Equal, toItem: self, attribute: .Trailing, multiplier: 1.0, constant: 0.0))</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Top, relatedBy: .Equal, toItem: self, attribute: .Top, multiplier: 1.0, constant: 0.0))</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Bottom, relatedBy: .Equal, toItem: self, attribute: .Bottom, multiplier: 1.0, constant: 0.0))</span><br><span class="line"></span><br><span class="line">    //4</span><br><span class="line">    let tapRecognizer = UITapGestureRecognizer(target: self, action:Selector("scrollerTapped:"))</span><br><span class="line">    scroller.addGestureRecognizer(tapRecognizer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码做了如下工作：</p>
<p>创建一个 UIScrollView 对象并且把它加到父视图中。<br>关闭 autoresizing masks ，从而可以使用 AutoLayout 进行布局。<br>给 scrollview 添加约束。我们希望 scrollview 能填满 HorizontalScroller 。<br>创建一个点击事件，检测是否点击到了专辑封面，如果确实点击到了专辑封面，我们需要通知 HorizontalScroller 的委托。<br>添加委托方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> func scrollerTapped(gesture: UITapGestureRecognizer) &#123;</span><br><span class="line">  let location = gesture.locationInView(gesture.view)</span><br><span class="line">  if let delegate = self.delegate &#123;</span><br><span class="line">    for index in 0..<span class="tag">&lt;<span class="name">delegate.numberOfViewsForHorizontalScroller(self)</span> &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">let</span> <span class="attr">view</span> = <span class="string">scroller.subviews[index]</span> <span class="attr">as</span> <span class="attr">UIView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">if</span> <span class="attr">CGRectContainsPoint</span>(<span class="attr">view.frame</span>, <span class="attr">location</span>) &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">delegate.horizontalScrollerClickedViewAtIndex</span>(<span class="attr">self</span>, <span class="attr">index:</span> <span class="attr">index</span>)</span></span><br><span class="line"><span class="tag">        <span class="attr">scroller.setContentOffset</span>(<span class="attr">CGPointMake</span>(<span class="attr">view.frame.origin.x</span> <span class="attr">-</span> <span class="attr">self.frame.size.width</span>/<span class="attr">2</span> + <span class="attr">view.frame.size.width</span>/<span class="attr">2</span>, <span class="attr">0</span>), <span class="attr">animated:true</span>)</span></span><br><span class="line"><span class="tag">        <span class="attr">break</span></span></span><br><span class="line"><span class="tag">      &#125;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们把 gesture 作为一个参数传了进来，这样就可以获取点击的具体坐标了。</p>
<p>接下来我们调用了 numberOfViewsForHorizontalScroller 方法，HorizontalScroller 不知道自己的 delegate 具体是谁，但是知道它一定实现了 HorizontalScrollerDelegate 协议，所以可以放心的调用。</p>
<p>对于 scroll view 中的 view ，通过 CGRectContainsPoint 进行点击检测，从而获知是哪一个 view 被点击了。当找到了点击的 view 的时候，则会调用委托方法里的 horizontalScrollerClickedViewAtIndex 方法通知委托。在跳出 for 循环之前，先把点击到的 view 居中。</p>
<p>接下来我们再加个方法获取数组里的 view ：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func viewAtIndex(index :Int) -&gt; UIView &#123;</span><br><span class="line">  return viewArray[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很简单，只是用来更方便获取数组里的 view 而已。在后面实现高亮选中专辑的时候会用到这个方法。</p>
<p>添加如下代码用来重新加载 scroller ：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func reload() &#123;</span><br><span class="line">  // 1 - Check if there is a delegate, if not there is nothing to load.</span><br><span class="line">  if let delegate = self.delegate &#123;</span><br><span class="line">    //2 - Will keep adding new album views on reload, need to reset.</span><br><span class="line">    viewArray = []</span><br><span class="line">    let views: NSArray = scroller.subviews</span><br><span class="line"></span><br><span class="line">    // 3 - remove all subviews</span><br><span class="line">    views.enumerateObjectsUsingBlock &#123;</span><br><span class="line">    (object: AnyObject!, idx: Int, stop: UnsafeMutablePointer<span class="tag">&lt;<span class="name">ObjCBool</span>&gt;</span>) -&gt; Void in</span><br><span class="line">      object.removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">    // 4 - xValue is the starting point of the views inside the scroller            </span><br><span class="line">    var xValue = VIEWS_OFFSET</span><br><span class="line">    for index in 0..<span class="tag">&lt;<span class="name">delegate.numberOfViewsForHorizontalScroller(self)</span> &#123;</span></span><br><span class="line"><span class="tag">      // <span class="attr">5</span> <span class="attr">-</span> <span class="attr">add</span> <span class="attr">a</span> <span class="attr">view</span> <span class="attr">at</span> <span class="attr">the</span> <span class="attr">right</span> <span class="attr">position</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xValue</span> += <span class="string">VIEW_PADDING</span></span></span><br><span class="line"><span class="tag">      <span class="attr">let</span> <span class="attr">view</span> = <span class="string">delegate.horizontalScrollerViewAtIndex(self,</span> <span class="attr">index:</span> <span class="attr">index</span>)</span></span><br><span class="line"><span class="tag">      <span class="attr">view.frame</span> = <span class="string">CGRectMake(CGFloat(xValue),</span> <span class="attr">CGFloat</span>(<span class="attr">VIEW_PADDING</span>), <span class="attr">CGFloat</span>(<span class="attr">VIEW_DIMENSIONS</span>), <span class="attr">CGFloat</span>(<span class="attr">VIEW_DIMENSIONS</span>))</span></span><br><span class="line"><span class="tag">      <span class="attr">scroller.addSubview</span>(<span class="attr">view</span>)</span></span><br><span class="line"><span class="tag">      <span class="attr">xValue</span> += <span class="string">VIEW_DIMENSIONS</span> + <span class="attr">VIEW_PADDING</span></span></span><br><span class="line"><span class="tag">      // <span class="attr">6</span> <span class="attr">-</span> <span class="attr">Store</span> <span class="attr">the</span> <span class="attr">view</span> <span class="attr">so</span> <span class="attr">we</span> <span class="attr">can</span> <span class="attr">reference</span> <span class="attr">it</span> <span class="attr">later</span></span></span><br><span class="line"><span class="tag">     <span class="attr">viewArray.append</span>(<span class="attr">view</span>)</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">    // <span class="attr">7</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scroller.contentSize</span> = <span class="string">CGSizeMake(CGFloat(xValue</span> + <span class="attr">VIEWS_OFFSET</span>), <span class="attr">frame.size.height</span>)</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    // <span class="attr">8</span> <span class="attr">-</span> <span class="attr">If</span> <span class="attr">an</span> <span class="attr">initial</span> <span class="attr">view</span> <span class="attr">is</span> <span class="attr">defined</span>, <span class="attr">center</span> <span class="attr">the</span> <span class="attr">scroller</span> <span class="attr">on</span> <span class="attr">it</span></span></span><br><span class="line"><span class="tag">    <span class="attr">if</span> <span class="attr">let</span> <span class="attr">initialView</span> = <span class="string">delegate.initialViewIndex?(self)</span> &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">scroller.setContentOffset</span>(<span class="attr">CGPointMake</span>(<span class="attr">CGFloat</span>(<span class="attr">initialView</span>)*<span class="attr">CGFloat</span>((<span class="attr">VIEW_DIMENSIONS</span> + (<span class="attr">2</span> * <span class="attr">VIEW_PADDING</span>))), <span class="attr">0</span>), <span class="attr">animated:</span> <span class="attr">true</span>)</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个 reload 方法有点像是 UITableView 里面的 reloadData 方法，它会重新加载所有数据。</p>
<p>一段一段的看下上面的代码：</p>
<p>在调用 reload 之前，先检查一下是否有委托。<br>既然要清除专辑封面，那么也需要重新设置 viewArray ，要不然以前的数据会累加进来。<br>移除先前加入到 scrollview 的子视图。<br>所有的 view 都有一个偏移量，目前默认是100，我们可以修改 VIEW_OFFSET 这个常量轻松的修改它。<br>HorizontalScroller 通过委托获取对应位置的 view 并且把它们放在对应的位置上。<br>把 view 存进 viewArray 以便后面的操作。<br>当所有 view 都安放好了，再设置一下 content size 这样才可以进行滑动。<br>HorizontalScroller 检查一下委托是否实现了 initialViewIndex() 这个可选方法，这种检查十分必要，因为这个委托方法是可选的，如果委托没有实现这个方法则用0作为默认值。最终设置 scroll view 将初始的 view 放置到居中的位置。<br>当数据发生改变的时候，我们需要调用 reload 方法。当 HorizontalScroller 被加到其他页面的时候也需要调用这个方法，我们在 HorizontalScroller.swift 里面加入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func didMoveToSuperview() &#123;</span><br><span class="line">    reload()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在当前 view 添加到其他 view 里的时候就会自动调用 didMoveToSuperview 方法，这样可以在正确的时间重新加载数据。</p>
<p>HorizontalScroller 的最后一部分是用来确保当前浏览的内容时刻位于正中心的位置，为了实现这个功能我们需要在用户滑动结束的时候做一些额外的计算和修正。</p>
<p>添加下面这个方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func centerCurrentView() &#123;</span><br><span class="line">    var xFinal = scroller.contentOffset.x + CGFloat((VIEWS_OFFSET/2) + VIEW_PADDING)</span><br><span class="line">    let viewIndex = xFinal / CGFloat((VIEW_DIMENSIONS + (2*VIEW_PADDING)))</span><br><span class="line">    xFinal = viewIndex * CGFloat(VIEW_DIMENSIONS + (2*VIEW_PADDING))</span><br><span class="line">    scroller.setContentOffset(CGPointMake(xFinal, 0), animated: true)</span><br><span class="line">    if let delegate = self.delegate &#123;</span><br><span class="line">        delegate.horizontalScrollerClickedViewAtIndex(self, index: Int(viewIndex))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码计算了当前视图里中心位置距离多少，然后算出正确的居中坐标并滑动到那个位置。最后一行是通知委托所选视图已经发生了改变。</p>
<p>为了检测到用户滑动的结束时间，我们还需要实现 UIScrollViewDelegate 的方法。在文件结尾加上下面这个扩展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension HorizontalScroller: UIScrollViewDelegate &#123;</span><br><span class="line">    func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123;</span><br><span class="line">        if !decelerate &#123;</span><br><span class="line">            centerCurrentView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123;</span><br><span class="line">        centerCurrentView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用户停止滑动的时候，scrollViewDidEndDragging(_:willDecelerate:) 这个方法会通知委托。如果滑动还没有停止，decelerate 的值为 true 。当滑动完全结束的时候，则会调用 scrollViewDidEndDecelerating 这个方法。在这两种情况下，你都应该把当前的视图居中，因为用户的操作可能会改变当前视图。</p>
<p>你的 HorizontalScroller 已经可以使用了！回头看看前面写的代码，你会看到我们并没有涉及什么 Album 或者 AlbumView 的代码。这是极好的，因为这样意味着这个 scroller 是完全独立的，可以复用。</p>
<p>运行一下你的项目，确保编译通过。</p>
<p>这样，我们的 HorizontalScroller 就完成了，接下来我们就要把它应用到我们的项目里了。首先，打开 Main.Sstoryboard 文件，点击上面的灰色矩形，设置 Class 为 HorizontalScroller ：</p>
<p>接下来，在 assistant editor 模式下向 ViewController.swift 拖拽生成 outlet ，命名为 scroller ：</p>
<p>接下来打开 ViewController.swift 文件，是时候实现 HorizontalScrollerDelegate 委托里的方法啦！</p>
<p>添加如下扩展：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: HorizontalScrollerDelegate &#123;</span><br><span class="line">    func horizontalScrollerClickedViewAtIndex(scroller: HorizontalScroller, index: Int) &#123;</span><br><span class="line">        //1</span><br><span class="line">        let previousAlbumView = scroller.viewAtIndex(currentAlbumIndex) as AlbumView</span><br><span class="line">        previousAlbumView.highlightAlbum(didHighlightView: false)</span><br><span class="line">        //2</span><br><span class="line">        currentAlbumIndex = index</span><br><span class="line">        //3</span><br><span class="line">        let albumView = scroller.viewAtIndex(index) as AlbumView</span><br><span class="line">        albumView.highlightAlbum(didHighlightView: true)</span><br><span class="line">        //4</span><br><span class="line">        showDataForAlbum(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们一行一行的看下这个委托的实现：</p>
<p>获取上一个选中的相册，然后取消高亮<br>存储当前点击的相册封面<br>获取当前选中的相册，设置为高亮<br>在 table view 里面展示新数据<br>接下来在扩展里添加如下方法：</p>
<p>func numberOfViewsForHorizontalScroller(scroller: HorizontalScroller) -&gt; (Int) {<br>    return allAlbums.count<br>}<br>这个委托方法返回 scroll vew 里面的视图数量，因为是用来展示所有的专辑的封面，所以数目也就是专辑数目。</p>
<p>然后添加如下代码：</p>
<p>func horizontalScrollerViewAtIndex(scroller: HorizontalScroller, index: Int) -&gt; (UIView) {<br>    let album = allAlbums[index]<br>    let albumView = AlbumView(frame: CGRectMake(0, 0, 100, 100), albumCover: album.coverUrl)<br>    if currentAlbumIndex == index {<br>        albumView.highlightAlbum(didHighlightView: true)<br>    } else {<br>        albumView.highlightAlbum(didHighlightView: false)<br>    }<br>    return albumView<br>}<br>我们创建了一个新的 AlbumView ，然后检查一下是不是当前选中的专辑，如果是则设为高亮，最后返回结果。</p>
<p>是的就是这么简单！三个方法，完成了一个横向滚动的浏览视图。</p>
<p>我们还需要创建这个滚动视图并把它加到主视图里，但是在这之前，先添加如下方法：</p>
<p>func reloadScroller() {<br>    allAlbums = LibraryAPI.sharedInstance.getAlbums()<br>    if currentAlbumIndex &lt; 0 {<br>        currentAlbumIndex = 0<br>    } else if currentAlbumIndex &gt;= allAlbums.count {<br>        currentAlbumIndex = allAlbums.count - 1<br>    }<br>    scroller.reload()<br>    showDataForAlbum(currentAlbumIndex)<br>}<br>这个方法通过 LibraryAPI 加载专辑数据，然后根据 currentAlbumIndex 的值设置当前视图。在设置之前先进行了校正，如果小于0则设置第一个专辑为展示的视图，如果超出了范围则设置最后一个专辑为展示的视图。</p>
<p>接下来只需要指定委托就可以了，在 viewDidLoad 最后加入一下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scroller.delegate = self</span><br><span class="line">reloadScroller()</span><br></pre></td></tr></table></figure></p>
<p>因为 HorizontalScroller 是在 StoryBoard 里初始化的，所以我们需要做的只是指定委托，然后调用 reloadScroller() 方法，从而加载所有的子视图并且展示专辑数据。</p>
<p>标注：如果协议里的方法过多，可以考虑把它分解成几个更小的协议。UITableViewDelegate 和 UITableViewDataSource 就是很好的例子，它们都是 UITableView 的协议。尝试去设计你自己的协议，让每个协议都单独负责一部分功能。</p>
<p>运行一下当前项目，看一下我们的新页面：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/7.png" alt=""><br>等下，滚动视图显示出来了，但是专辑的封面怎么不见了？</p>
<p>啊哈，是的。我们还没完成下载部分的代码，我们需要添加下载图片的方法。因为我们所有的访问都是通过 LibraryAPI 实现的，所以很显然我们下一步应该去完善这个类了。不过在这之前，我们还需要考虑一些问题：</p>
<p>AlbumView 不应该直接和 LibraryAPI 交互，我们不应该把视图的逻辑和业务逻辑混在一起。<br>同样， LibraryAPI 也不应该知道 AlbumView 这个类。<br>如果 AlbumView 要展示封面，LibraryAPI 需要告诉 AlbumView 图片下载完成。<br>看起来好像很难的样子？别绝望，接下来我们会用观察者模式 (Observer Pattern) 解决这个问题！</p>
<p>###观察者模式 - Observer</p>
<p>在观察者模式里，一个对象在状态变化的时候会通知另一个对象。参与者并不需要知道其他对象的具体是干什么的 - 这是一种降低耦合度的设计。这个设计模式常用于在某个属性改变的时候通知关注该属性的对象。</p>
<p>常见的使用方法是观察者注册监听，然后再状态改变的时候，所有观察者们都会收到通知。</p>
<p>在 MVC 里，观察者模式意味着需要允许 Model 对象和 View 对象进行交流，而不能有直接的关联。</p>
<p>Cocoa 使用两种方式实现了观察者模式： Notification 和 Key-Value Observing (KVO)。</p>
<p>通知 - Notification<br>不要把这里的通知和推送通知或者本地通知搞混了，这里的通知是基于订阅-发布模型的，即一个对象 (发布者) 向其他对象 (订阅者) 发送消息。发布者永远不需要知道订阅者的任何数据。</p>
<p>Apple 对于通知的使用很频繁，比如当键盘弹出或者收起的时候，系统会分别发送 UIKeyboardWillShowNotification/UIKeyboardWillHideNotification 的通知。当你的应用切到后台的时候，又会发送 UIApplicationDidEnterBackgroundNotification 的通知。</p>
<p>注意：打开 UIApplication.swift 文件，在文件结尾你会看到二十多种系统发送的通知。</p>
<p>如何使用通知<br>打开 AlbumView.swift 然后在 init 的最后插入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().postNotificationName("BLDownloadImageNotification", object: self, userInfo: ["imageView":coverImage, "coverUrl" : albumCover])</span><br></pre></td></tr></table></figure></p>
<p>这行代码通过 NSNotificationCenter 发送了一个通知，通知信息包含了 UIImageView 和图片的下载地址。这是下载图像需要的所有数据。</p>
<p>然后在 LibraryAPI.swift 的 init 方法的 super.init() 后面加上如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector:"downloadImage:", name: "BLDownloadImageNotification", object: nil)</span><br></pre></td></tr></table></figure></p>
<p>这是等号的另一边：观察者。每当 AlbumView 发出一个 BLDownloadImageNotification 通知的时候，由于 LibraryAPI 已经注册了成为观察者，所以系统会调用 downloadImage() 方法。</p>
<p>但是，在实现 downloadImage() 之前，我们必须先在 dealloc 里取消监听。如果没有取消监听消息，消息会发送给一个已经销毁的对象，导致程序崩溃。</p>
<p>在 LibaratyAPI.swift 里加上取消订阅的代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NSNotificationCenter.defaultCenter().removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对象销毁的时候，把它从所有消息的订阅列表里去除。</p>
<p>这里还要做一件事情：我们最好把图片存储到本地，这样可以避免一次又一次下载相同的封面。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">打开 PersistencyManager.swift 添加如下代码：</span><br><span class="line"></span><br><span class="line">func saveImage(image: UIImage, filename: String) &#123;</span><br><span class="line">    let path = NSHomeDirectory().stringByAppendingString("/Documents/\(filename)")</span><br><span class="line">    let data = UIImagePNGRepresentation(image)</span><br><span class="line">    data.writeToFile(path, atomically: true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getImage(filename: String) -&gt; UIImage? &#123;</span><br><span class="line">    var error: NSError?</span><br><span class="line">    let path = NSHomeDirectory().stringByAppendingString("/Documents/\(filename)")</span><br><span class="line">    let data = NSData(contentsOfFile: path, options: .UncachedRead, error: &amp;error)</span><br><span class="line">    if let unwrappedError = error &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return UIImage(data: data!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单直接，下载的图片会存储在 Documents 目录下，如果没有检查到缓存文件， getImage() 方法则会返回 nil 。</p>
<p>然后在 LibraryAPI.swift 添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func downloadImage(notification: NSNotification) &#123;</span><br><span class="line">    //1</span><br><span class="line">    let userInfo = notification.userInfo as [String: AnyObject]</span><br><span class="line">    var imageView = userInfo["imageView"] as UIImageView?</span><br><span class="line">    let coverUrl = userInfo["coverUrl"] as NSString</span><br><span class="line"></span><br><span class="line">    //2</span><br><span class="line">    if let imageViewUnWrapped = imageView &#123;</span><br><span class="line">        imageViewUnWrapped.image = persistencyManager.getImage(coverUrl.lastPathComponent)</span><br><span class="line">        if imageViewUnWrapped.image == nil &#123;</span><br><span class="line">            //3</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), &#123; () -&gt; Void in</span><br><span class="line">                let downloadedImage = self.httpClient.downloadImage(coverUrl)</span><br><span class="line">                //4</span><br><span class="line">                dispatch_sync(dispatch_get_main_queue(), &#123; () -&gt; Void in</span><br><span class="line">                    imageViewUnWrapped.image = downloadedImage</span><br><span class="line">                    self.persistencyManager.saveImage(downloadedImage, filename: coverUrl.lastPathComponent)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拆解一下上面的代码：</p>
<p>downloadImage 通过通知调用，所以这个方法的参数就是 NSNotification 本身。 UIImageView 和 URL 都可以从其中获取到。<br>如果以前下载过，从 PersistencyManager 里获取缓存。<br>如果图片没有缓存，则通过 HTTPClient 获取。<br>如果下载完成，展示图片并用 PersistencyManager 存储到本地。<br>再回顾一下，我们使用外观模式隐藏了下载图片的复杂程度。通知的发送者并不在乎图片是如何从网上下载到本地的。</p>
<p>运行一下项目，可以看到专辑封面已经显示出来了：</p>
<p>关了应用再重新运行，注意这次没有任何延时就显示了所有的图片，因为我们已经有了本地缓存。我们甚至可以在没有网络的情况下正常使用我们的应用。不过出了问题：这个用来提示加载网络请求的小菊花怎么一直在显示！</p>
<p>我们在下载图片的时候开启了这个白色小菊花，但是在图片下载完毕的时候我们并没有停掉它。我们可以在每次下载成功的时候发送一个通知，但是我们不这样做，这次我们来用用另一个观察者模式： KVO 。</p>
<p>键值观察 - KVO<br>在 KVO 里，对象可以注册监听任何属性的变化，不管它是否持有。如果感兴趣的话，可以读一读苹果 KVO 编程指南。</p>
<p>如何使用 KVO<br>正如前面所提及的， 对象可以关注任何属性的变化。在我们的例子里，我们可以用 KVO 关注 UIImageView 的 image 属性变化。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">打开 AlbumView.swift 文件，找到 init(frame:albumCover:) 方法，在把 coverImage 添加到 subView 的代码后面添加如下代码：</span><br><span class="line"></span><br><span class="line">coverImage.addObserver(self, forKeyPath: "image", options: nil, context: nil)</span><br><span class="line">这行代码把 self (也就是当前类) 添加到了 coverImage 的 image 属性的观察者里。</span><br><span class="line"></span><br><span class="line">在销毁的时候，我们也需要取消观察。还是在 AlbumView.swift 文件里，添加如下代码：</span><br><span class="line"></span><br><span class="line">deinit &#123;</span><br><span class="line">    coverImage.removeObserver(self, forKeyPath: "image")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终添加如下方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject, change: [NSObject : AnyObject], context: UnsafeMutablePointer<span class="tag">&lt;<span class="name">Void</span>&gt;</span>) &#123;</span><br><span class="line">    if keyPath == "image" &#123;</span><br><span class="line">        indicator.stopAnimating()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>必须在所有的观察者里实现上面的代码。在检测到属性变化的时候，系统会自动调用这个方法。在上面的代码里，我们在图片加载完成的时候把那个提示加载的小菊花去掉了。</p>
<p>再次运行项目，你会发现一切正常了：</p>
<p>注意：一定要记得移除观察者，否则如果对象已经销毁了还给它发送消息会导致应用崩溃。</p>
<p>此时你可以把玩一下当前的应用然后再关掉它，你会发现你的应用的状态并没有存储下来。最后看见的专辑并不会再下次打开应用的时候出现。</p>
<p>为了解决这个问题，我们可以使用下一种模式：备忘录模式。</p>
<h3 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 - Memento"></a>备忘录模式 - Memento</h3><p>备忘录模式捕捉并且具象化一个对象的内在状态。换句话说，它把你的对象存在了某个地方，然后在以后的某个时间再把它恢复出来，而不会打破它本身的封装性，私有数据依旧是私有数据。</p>
<p>如何使用备忘录模式<br>在 ViewController.swift 里加上下面两个方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//MARK: Memento Pattern</span><br><span class="line">func saveCurrentState() &#123;</span><br><span class="line">    // When the user leaves the app and then comes back again, he wants it to be in the exact same state</span><br><span class="line">    // he left it. In order to do this we need to save the currently displayed album.</span><br><span class="line">    // Since it's only one piece of information we can use NSUserDefaults.</span><br><span class="line">    NSUserDefaults.standardUserDefaults().setInteger(currentAlbumIndex, forKey: "currentAlbumIndex")</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func loadPreviousState() &#123;</span><br><span class="line">    currentAlbumIndex = NSUserDefaults.standardUserDefaults().integerForKey("currentAlbumIndex")</span><br><span class="line">    showDataForAlbum(currentAlbumIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>saveCurrentState 把当前相册的索引值存到 NSUserDefaults 里。NSUserDefaults 是 iOS 提供的一个标准存储方案，用于保存应用的配置信息和数据。</p>
<p>loadPreviousState 方法加载上次存储的索引值。这并不是备忘录模式的完整实现，但是已经离目标不远了。</p>
<p>接下来在 viewDidLoad 的 scroller.delegate = self 前面调用：<br>loadPreviousState()<br>这样在刚初始化的时候就加载了上次存储的状态。但是什么时候存储当前状态呢？这个时候我们可以用通知来做。在应用进入到后台的时候， iOS 会发送一个 UIApplicationDidEnterBackgroundNotification 的通知，我们可以在这个通知里调用 saveCurrentState 这个方法。是不是很方便？</p>
<p>在 viewDidLoad 的最后加上如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector:"saveCurrentState", name: UIApplicationDidEnterBackgroundNotification, object: nil)</span><br></pre></td></tr></table></figure></p>
<p>现在，当应用即将进入后台的时候，ViewController 会调用 saveCurrentState 方法自动存储当前状态。</p>
<p>当然也别忘了取消监听通知，添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NSNotificationCenter.defaultCenter().removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就确保在 ViewController 销毁的时候取消监听通知。</p>
<p>这时再运行程序，随意移到某个专辑上，然后按下 Home 键把应用切换到后台，再在 Xcode 上把 App 关闭。重新启动，会看见上次记录的专辑已经存了下来并成功还原了：</p>
<p>看起来专辑数据好像是对了，但是上面的滚动条似乎出了问题，没有居中啊！</p>
<p>这时 initialViewIndex 方法就派上用场了。由于在委托里 (也就是 ViewController ) 还没实现这个方法，所以初始化的结果总是第一张专辑。</p>
<p>为了修复这个问题，我们可以在 ViewController.swift 里添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func initialViewIndex(scroller: HorizontalScroller) -&gt; Int &#123;</span><br><span class="line">    return currentAlbumIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在 HorizontalScroller 可以根据 currentAlbumIndex 自动滑到相应的索引位置了。</p>
<p>再次重复上次的步骤，切到后台，关闭应用，重启，一切顺利：</p>
<p>回头看看 PersistencyManager 的 init 方法，你会发现专辑数据是我们硬编码写进去的，而且每次创建 PersistencyManager 的时候都会再创建一次专辑数据。而实际上一个比较好的方案是只创建一次，然后把专辑数据存到本地文件里。我们如何把专辑数据存到文件里呢？</p>
<p>一种方案是遍历 Album 的属性然后把它们写到一个 plist 文件里，然后如果需要的时候再重新创建 Album 对象。这并不是最好的选择，因为数据和属性不同，你的代码也就要相应的产生变化。举个例子，如果我们以后想添加 Movie 对象，它有着完全不同的属性，那么存储和读取数据又需要重写新的代码。</p>
<p>况且你也无法存储这些对象的私有属性，因为其他类是没有访问权限的。这也就是为什么 Apple 提供了 归档 的机制。</p>
<p>归档 - Archiving<br>苹果通过归档的方法来实现备忘录模式。它把对象转化成了流然后在不暴露内部属性的情况下存储数据。你可以读一读 《iOS 6 by Tutorials》 这本书的第 16 章，或者看下[苹果的归档和序列化文档][14]。</p>
<p>如何使用归档<br>首先，我们需要让 Album 实现 NSCoding 协议，声明这个类是可被归档的。打开 Album.swift 在 class 那行后面加上 NSCoding ：</p>
<p>class Album: NSObject, NSCoding {<br>然后添加如下的两个方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">required init(coder decoder: NSCoder) &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    self.title = decoder.decodeObjectForKey("title") as String?</span><br><span class="line">    self.artist = decoder.decodeObjectForKey("artist") as String?</span><br><span class="line">    self.genre = decoder.decodeObjectForKey("genre") as String?</span><br><span class="line">    self.coverUrl = decoder.decodeObjectForKey("cover_url") as String?</span><br><span class="line">    self.year = decoder.decodeObjectForKey("year") as String?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func encodeWithCoder(aCoder: NSCoder) &#123;</span><br><span class="line">    aCoder.encodeObject(title, forKey: "title")</span><br><span class="line">    aCoder.encodeObject(artist, forKey: "artist")</span><br><span class="line">    aCoder.encodeObject(genre, forKey: "genre")</span><br><span class="line">    aCoder.encodeObject(coverUrl, forKey: "cover_url")</span><br><span class="line">    aCoder.encodeObject(year, forKey: "year")</span><br><span class="line">&#125;</span><br><span class="line">encodeWithCoder 方法是 NSCoding 的一部分，在被归档的时候调用。相对的， init(coder:) 方法则是用来解档的。很简单，很强大。</span><br></pre></td></tr></table></figure></p>
<p>现在 Album 对象可以被归档了，添加一些代码来存储和加载 Album 数据。</p>
<p>在 PersistencyManager.swift 里添加如下代码：</p>
<p>func saveAlbums() {<br>    var filename = NSHomeDirectory().stringByAppendingString(“/Documents/albums.bin”)<br>    let data = NSKeyedArchiver.archivedDataWithRootObject(albums)<br>    data.writeToFile(filename, atomically: true)<br>}<br>这个方法可以用来存储专辑。 NSKeyedArchiver 把专辑数组归档到了 albums.bin 这个文件里。</p>
<p>当我们归档一个包含子对象的对象时，系统会自动递归的归档子对象，然后是子对象的子对象，这样一层层递归下去。在我们的例子里，我们归档的是 albums 因为 Array 和 Album 都是实现 NSCopying 接口的，所以数组里的对象都可以自动归档。</p>
<p>用下面的代码取代 PersistencyManager 中的 init 方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    if let data = NSData(contentsOfFile: NSHomeDirectory().stringByAppendingString("/Documents/albums.bin")) &#123;</span><br><span class="line">        let unarchiveAlbums = NSKeyedUnarchiver.unarchiveObjectWithData(data) as [Album]?</span><br><span class="line">        if let unwrappedAlbum = unarchiveAlbums &#123;</span><br><span class="line">            albums = unwrappedAlbum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createPlaceholderAlbum()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createPlaceholderAlbum() &#123;</span><br><span class="line">    //Dummy list of albums</span><br><span class="line">    let album1 = Album(title: "Best of Bowie",</span><br><span class="line">             artist: "David Bowie",</span><br><span class="line">             genre: "Pop",</span><br><span class="line">             coverUrl: "http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png",</span><br><span class="line">             year: "1992")</span><br><span class="line"></span><br><span class="line">    let album2 = Album(title: "It's My Life",</span><br><span class="line">           artist: "No Doubt",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png",</span><br><span class="line">           year: "2003")</span><br><span class="line"></span><br><span class="line">    let album3 = Album(title: "Nothing Like The Sun",</span><br><span class="line">               artist: "Sting",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png",</span><br><span class="line">           year: "1999")</span><br><span class="line"></span><br><span class="line">    let album4 = Album(title: "Staring at the Sun",</span><br><span class="line">           artist: "U2",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png",</span><br><span class="line">           year: "2000")</span><br><span class="line"></span><br><span class="line">    let album5 = Album(title: "American Pie",</span><br><span class="line">           artist: "Madonna",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png",</span><br><span class="line">           year: "2000")</span><br><span class="line">    albums = [album1, album2, album3, album4, album5]</span><br><span class="line">    saveAlbums()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把创建专辑数据的方法放到了 createPlaceholderAlbum 里，这样代码可读性更高。在新的代码里，如果存在归档文件， NSKeyedUnarchiver 从归档文件加载数据；否则就创建归档文件，这样下次程序启动的时候可以读取本地文件加载数据。</p>
<p>我们还想在每次程序进入后台的时候存储专辑数据。看起来现在这个功能并不是必须的，但是如果以后我们加了编辑功能，这样做还是很有必要的，那时我们肯定希望确保新的数据会同步到本地的归档文件。</p>
<p>因为我们的程序通过 LibraryAPI 来访问所有服务，所以我们需要通过 LibraryAPI 来通知 PersistencyManager 存储专辑数据。</p>
<p>在 LibraryAPI 里添加存储专辑数据的方法：</p>
<p>func saveAlbums() {<br>    persistencyManager.saveAlbums()<br>}<br>这个方法很简单，就是把 LibraryAPI 的 saveAlbums 方法传递给了 persistencyManager 的 saveAlbums 方法。</p>
<p>然后在 ViewController.swift 的 saveCurrentState 方法的最后加上：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibraryAPI.sharedInstance.saveAlbums()</span><br></pre></td></tr></table></figure></p>
<p>在 ViewController 需要存储状态的时候，上面的代码通过 LibraryAPI 归档当前的专辑数据。</p>
<p>运行一下程序，检查一下没有编译错误。</p>
<p>不幸的是似乎没什么简单的方法来检查归档是否正确完成。你可以检查一下 Documents 目录，看下是否存在归档文件。如果要查看其他数据变化的话，还需要添加编辑专辑数据的功能。</p>
<p>不过和编辑数据相比，似乎加个删除专辑的功能更好一点，如果不想要这张专辑直接删除即可。再进一步，万一误删了话，是不是还可以再加个撤销按钮？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/14/Swift的关键字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/14/Swift的关键字/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-14T09:16:59+08:00">
                2018-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="关于swift中的知识点"><a href="#关于swift中的知识点" class="headerlink" title="关于swift中的知识点"></a>关于swift中的知识点</h4><p>swift中的所有关键字：</p>
<p>用作声明的关键字:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class、deinit、enum、extension、func、import、init、let、protocol、static、struct、subscript、typealias、var</span><br></pre></td></tr></table></figure></p>
<p>用作语句的关键字<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break、case、continue、default、break、case、continue、default、do、else、fallthrough、if、in、for、return、switch、where、while</span><br><span class="line">do、else、fallthrough、if、in、for、return、switch、where、while</span><br></pre></td></tr></table></figure></p>
<p>用作表达和类型的关键字：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as、dynamicType、new、is、super、self、Self、Type、__COLUMN__、__FILE__、__FUNCTION__、__LINE__</span><br></pre></td></tr></table></figure></p>
<p>特定上下文中被保留的关键字:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">associativity、didset、get、infix、inout、left、mutating、none、nonmutating、operator、override、postfix、precedence、prefix、rightset、unowned、unowned(sale)、unowned(unsafe)、weak、willset</span><br></pre></td></tr></table></figure></p>
<p>常见的关键字的处理：</p>
<p>class : 用来声明一个类<br>enum : 用来声明一个枚举<br>init : 相对于类的释构方法的修饰。<br>deinit : 相对于类的释构方法的修饰。<br>对于类的构造和释构在swift 中需要使用关键词来修饰，而很多高级语言并不需要特别的指定，便C++ 只需要类名与构造函数名相同就可以，不需要额外的关键词。</p>
<p>extension:扩展(类似于OC的categories)，</p>
<ol>
<li>Swift 中的可以扩展以下几个：</li>
<li>添加计算型属性和计算静态属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个接口</li>
</ol>
<p>let : 声明一个常量. 类似于const<br>protocol : 协议.也可以叫接口.这个往往在很多高级语言中不能多重继承的情况下使用协议是一个比较好的多态方式。<br>static : 声明静态变量或者函数<br>struct : 声明定义一个结构体<br>subscript : 下标索引修饰.可以让class、struct、以及enum使用下标访问内部的值<br>typealias : 为此类型声明一个别名.和 typedef类似.<br>break : 跳出循环.一般在控制流中使用,比如 for . while switch等语句<br>case : switch的选择分支.<br>continue : 跳过本次循环,继续执行后面的循环.<br>in : 范围或集合操作,多用于遍历.<br>fallthrough : swift语是执行完当前case,继续执行下面的case.类似于其它语言中省去break里，会继续往后一个c言特性switch语句的break可以忽略不写,满足条件时直接跳出循环.fallthrough的作用就是执行完当前case,继续执行下面的case.类似于其它语言中省去break里，会继续往后一个case跑，直到碰到break或default才完成的效果.</p>
<p>where : 用于条件判断,和数据库查询时的where ‘id &gt; 10’这样功能. swift语言的特性.OC中并没有.<br>is &amp; as : is一般用于对一些变量的类型做判断.类似于OC中的isKindClass. as 与强制转换含义雷同.<br>as的使用场合，从派生类向基类转化。<br>as！向下转类型，由于是强制类型转化，如果转化失败，会报runtime的错误。<br>as?使用的场合，as？和as!操作符的转化规则是完全一致的，但as？如果转化不成功的时候便会返回一个nil对象，成功的话，返回可选择的类型的值，需要拆包使用，并且as？及时出现错误了，也不会报错，如果对于转化需要确保100%的话，可以使用as！，需要做细节说明。</p>
<p>没看懂是怎么使用的，暂时先忽略的关键字<br>dynamicType:获取对象的动态类型,即运行时的实际类型,而非代码指定或编译器看到的类型</p>
<p><strong>COLUMN</strong> 列号<br><strong>FILE</strong> 路径<br><strong>FUNCTION</strong> 函数<br><strong>LINE</strong> 行号</p>
<p>运算符的结合性： associativity<br>inout: inout作为函数声明，引用传值的关键字，但是在调用的时候引用的地址，所以在引用的时候要加上&amp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func test(inout a : Int ,inout b : Int) &#123;</span><br><span class="line">&#125;</span><br><span class="line">var num1 = 3</span><br><span class="line">var num2 = 4</span><br><span class="line">test(&amp;num1,&amp;num2)</span><br></pre></td></tr></table></figure></p>
<p>willSet和didSet:willSet和didSet的作用是对赋值过程前后附加额外的操作<br>可以看做是捕获状态然后做操作,在将要赋值的时候和已经赋值的时候做相关操作</p>
<p>mutating:作用:写在func前面,以便于让func可以修改struct和protocol的extension中的成员的值。 如果func前面不加mutating,struct和protocol的extension中的成员的值便被保护起来,不能修改</p>
<p>class var:在swift中对于enum和struct来说支持用static关键字来标示静态变量，<br>但是对于class成员来说，只能以class var的方式返回一个只读值</p>
<p>convenience : convenience用来进行方便的初始化，就相当于构造函数重载。<br>对于class来讲，默认或指定的初始化方法作为所谓的Designated初始化。<br>若重载的初始化需要调用Designated初始化则将它作为convenience初始化，在方法前要加上convenience关键字<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Figure&#123;</span><br><span class="line">       var name:String!</span><br><span class="line">       var nikname:String?</span><br><span class="line">       init()&#123;</span><br><span class="line">          name = "John"</span><br><span class="line">       &#125;</span><br><span class="line">      convenience init(name:String!,nikname:String!) &#123;</span><br><span class="line">           self.init() self.name = name self.nikname = nikname</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>precedence : 运算的优先级，越高的话优先进行计算。swift 中乘法和除法的优先级是 150 ，加法和减法的优先级是 140 ，这里我们定义点积的优先级为 160 ，就是说应该早于普通的乘除进行运算。<br>unowned, unowned(safe), unowned(unsafe):无宿主引用。<br>infix: 表示要定义的是一个中位操作符，即前后都是输入<br>defer: 用来包裹一段代码，这个代码块将会在当前作用域结束的时候被调用。这通常被用来对当前的代码进行一些清理工作，比如关闭打开的文件等。<br>可以在同一个作用域中指定多个 defer<br>代码块，在当前作用域结束时，它们会以相反的顺序被调用，即先定义的后执行，后定义的先执行。<br>guard : 当某些条件不满足的情况下，跳出作用域. 色值</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yida</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yida</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
