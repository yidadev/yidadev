<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="益达的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="益达的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="益达的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>益达的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">益达的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/20180701shell脚本常用参数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/20180701shell脚本常用参数/" itemprop="url">load的基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-01T10:11:12+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>shell的常用关键字</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echo "shell 输出脚本名称及参数";</span><br><span class="line">echo "执行的脚本名: $0 ";</span><br><span class="line">echo "第一个参数： $1";</span><br><span class="line">echo "第二个参数： $2";</span><br><span class="line">echo "传递到脚本的参数 $#"</span><br><span class="line">echo "脚本运行的当前进程ID号 $$"</span><br><span class="line"></span><br><span class="line">以一个单字符串显示所有向脚本传递的参数。</span><br><span class="line">如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</span><br><span class="line">echo "-- \$* 演示 ---"</span><br><span class="line">for i in "$*"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//拼接字符串</span><br><span class="line">your_name="qinjx"</span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, $&#123;your_name&#125; !"</span><br><span class="line"></span><br><span class="line">//获取字符串的长度</span><br><span class="line">string="abcd" echo $&#123;#string&#125; #输出 4</span><br><span class="line"></span><br><span class="line">//提取字符串</span><br><span class="line">string="runoob is a great site"</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>
<p>数组的定义：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"></span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br><span class="line"></span><br><span class="line">读取数组：</span><br><span class="line">$&#123;数组名[下标] valuen=$&#123;array_name[n]&#125;</span><br><span class="line">echo $&#123;array_name[@]&#125;  使用@符号可以获取数组中的所有元素</span><br><span class="line"></span><br><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure></p>
<p>expr<br>(1).”string : REGEX”字符串匹配示例。要输出匹配到的字符串结果，需要使用”(“和”)“，否则返回的将是匹配到的字符串数量。<br>(2).”index string chars”用法示例。<br>(3).”substr string pos len”用法示例。</p>
<p>数字</p>
<p>-eq    检测两个数是否相等，相等返回 true。<br>ne    检测两个数是否相等，不相等返回 true。    [ $a -ne $b ]<br>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ]<br>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ]<br>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ]<br>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]</p>
<p>if [ $a -eq $b ]<br>then<br>   echo “$a -eq $b : a 等于 b”<br>else<br>   echo “$a -eq $b: a 不等于 b”<br>fi</p>
<p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ]<br>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ]<br>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ]</p>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false<br>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<p>字符串：</p>
<p>=    检测两个字符串是否相等，相等返回 true。    [ $a = $b ] 返回 false。<br>!=    检测两个字符串是否相等，不相等返回 true。    [ $a != $b ] 返回 true。<br>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。<br>-n    检测字符串长度是否为0，不为0返回 true。    [ -n $a ] 返回 true。<br>str    检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<p>-b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ]<br>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ]<br>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ]<br>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。<br>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] ]<br>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。<br>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。<br>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。<br>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。<br>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。<br>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。<br>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>//输出到文件<br>echo “It is a test” &gt; myfile<br>echo <code>date</code>输出时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/01/20180601HTTP的总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/20180601HTTP的总结/" itemprop="url">关于Http的总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-01T10:11:12+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于Http的总结</p>
<ol>
<li><p>HTTP/1.1<br>TCP连接是需要三次握手的，同时，多个TCP连接也会给服务器带来资源的消耗，在HTTP/1.1中，每个请求回复都是一次TCP连接（未开启Keep-Alive的情况下），并且，同时传输多个资源时，会有队首阻塞的问题，造成网络资源无法有效利用。</p>
</li>
<li><p>安全<br>对于大多数人来说，下图的情况几乎都有遇到过（电脑或手机里）。万恶的运营商或者网络接入WiFi提供商劫持我们的网络，修改网络的内容，给我们带来了很大的困扰。</p>
</li>
</ol>
<p>现在，HTTP/2.0出现了。其实HTTP/2.0是支持Clear Text版和Over TLS版，由于现有支持HTTP/2.0的浏览器都是实现的Over TLS版，故本文的HTTP/2.0都是讲的是HTTPS版HTTP/2.0。</p>
<ol>
<li><p>Clear Text版:<br>客户端向服务端请求（假设此时scheme是HTTP），带有以下头：<br>Upgrade: h2c<br>HTTP2-Settings<br>服务器端返回：<br>101状态码，转换协议；<br>Connection: Upgrade<br>Upgrade: h2c 或者 200/404</p>
</li>
<li><p>HTTP/2.0 Over TLS版:<br>客户端向服务器端请求<br>TLS + ALPN(Application Layer Protocol Negotiation)/NPN<br>服务器端返回:<br>TLS 握手 并返回支持的HTTP协议<br><img src="https://mc.qcloudimg.com/static/img/851afadec019cc1f93f28e119c3f6f53/image.jpg" alt=""></p>
</li>
</ol>
<p>b. ALPN协商过程</p>
<p>参考TLS握手过程图，下面是增加ALPN协商的具体过程：<br>客户端添加一个ProtocolNameList字段，包含支持的HTTP协议到ClientHello消息中；<br>服务器端查看ProtocolNameList字段后通过ServerHello消息返回ProtocolName字段，表明被选定的协议；<br>通过实现ALPN，不再需要单独请求一次服务器带上Upgrade: h2c。</p>
<p>c. False Start</p>
<p>通常情况下，使用ALPN会搭配使用False Start，客户端在完成TLS握手前提前发送加密后的应用数据，将两次RTT TLS握手减少为一次；不过需要同时支持ALPN（NPN已经很少用啦）和前向安全性。</p>
<p>d. HSTS</p>
<p>HTTP Strict Transport Security（简称为HSTS）是一个安全功能，告诉浏览器只能通过HTTPS访问当前资源，禁止HTTP方式。<br>如果用户输入域名<a href="http://www.qq.com，" target="_blank" rel="noopener">www.qq.com，</a> 浏览器首先会去请求<a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a> ,请求过程是明文非加密的，此时容易被中间人攻击，让网路恶意中间商直接接触到用户信息；而HSTS是用户请求时，服务器告诉客户端，下次来请求直接请求https:// ，而不要再请求服务器来跳转到https。<br>同时，开启HSTS后，如果证书认证不通过（比如遭到中间人攻击），浏览器此时强制无法打开该网站。</p>
<p>流(Stream)：一个Stream是包含一条或多条信息，ID和优先级的双向通道；<br>消息(Message)：消息由帧组成；<br>帧(Frame)：帧有不同的类型，并且是混合的。他们通过stream id被重新组装进消息中。</p>
<p>二进制帧的处理：</p>
<p><img src="https://mc.qcloudimg.com/static/img/811215f81ab8ff1af5ee542841cd3575/image.jpg" alt=""></p>
<p>HTTP2的二进制帧是9字节(72 bit)<br>长度：24bit，也就是理论上可以携带2^24字节的数据。但通常由于SETTINGS_MAX_FRAME_SIZE的设置，不能发送超过2^14(16384)字节的数据；<br>类型：8bit，决定了该帧的类型；<br>DATA : 数据帧<br>HEADERS : 头部帧<br>PRIORITY : 设置流的优先级<br>RST_STREAM : 终止流<br>SETTINGS : 设置连接参数<br>PUSH_PROMISE : 服务器推送模拟请求帧<br>PING : 用来计算RTT时间和看是否服务器挂了的Stream<br>GOAWAY : 告诉对方停止再向当前连接创建stream<br>WINDOW_UPDATE : 流量控制<br>保留字段：1bit，一般为0。</p>
<p>Stream ID：31bit，Stream标识，理论上可以有2147483648，超过这么多stream怎么办呢？</p>
<p>如果是客户端无法再创建新的stream id，可以直接创建新的TCP连接，stream id被重置。</p>
<p>如果是服务器端无法再创建新的stream id，服务器将会给客户端发一个 GOAWAY帧，客户端无法再向该服务器创建stream，不得不新建TCP连接。</p>
<p>新的特性：<br>a. 多路复用<br><img src="https://mc.qcloudimg.com/static/img/ca52b1f8f8397cd11b0164bf2adda94d/image.jpg" alt=""></p>
<p>HTTP/2.0中，数据在发送端被切分为更小的数据帧用以高效利用链接。</p>
<p>HTTP 1.1时代，再不开启Keep-alive的情况下，每一个请求会占用一个TCP连接，而HTTP/2将请求和响应消息拆分为各自独立的帧，交错的发送，然后再在接收端重新装配组合。有什么好处呢？</p>
<p>交错的多个请求/响应之间互现不会被阻塞</p>
<p>HTTP/1.1时代的Keep-alive也是保持同一个TCP连接，但是由于请求/接收有先后，后面的请求资源会被前面的资源阻塞（没收到响应时不会发新的请求），如下图最左和最右边所示，即便是相比HTTP管道，优化也是巨大的：<br><img src="https://mc.qcloudimg.com/static/img/228acfed18be7661c6da162b0c56b777/image.jpg" alt=""><br>减少了不必要的延时，改善了网路的利用率(多路复用和资源优先级/依赖关系搭配使用，使得页面重度依赖的资源优先传输)；</p>
<p>b. 头部压缩</p>
<p>HTTP/2.0使用HPACK来给头部压缩；<br>值通过霍夫曼编码；<br>之前发送的值都被索引起来，之后使用时发现之前发送过该Header字段，并且值相同，就会沿用之前的索引来指代那个Header值；<br>Cookies：在HTTP/2.0中，Cookie也将会变为键值对索引起来，而不是一长串字符串。</p>
<p>c. 资源优先级/依赖关系<br>资源优先级/依赖关系通过stream权重和dependency来设置。<br>通过上图可以看到，有一列是叫作Priority，初始设置是根据Content-type来设置优先级的，比如HTML是Highest，CSS是High，然后JS是Medium。<br>Stream 权重值可以设置为1到256之间。<br>Stream可以明确的表示依赖关系。<br>注意，一定要理解权重和依赖，权重值和依赖关系是作为带宽资源/服务器/客户端处理资源的建议值，但并不能保证他们有特定的传输顺序。</p>
<p>d. 流量控制<br>与TCP的流量控制类似，不过HTTP/2.0的流量控制可以到具体帧，而TCP是TCP连接层面上的。注意：流量控制目前只对DATA帧有效！流量控制的算法没有具体要求使用哪一种，但是大概实现的功能是这样的：<br>两端收发保有一个流量控制(window)窗口；<br>发送端每发送一个DATA帧，就把窗口的大小递减，递减量为这个帧的大小，要是窗口大小小于该帧的大小，那么这个帧就必须被拆分。如果窗口值等于0，就不能发送任何帧。流量控制的初始默认窗口值大小为65535字节(理论上可以设置2^31-1字节也就是2147483647字节大小的窗口值)；<br>接收端可以通过发送WINDOW_UPDATE帧给发送端，发送端以帧内指定的窗口大小增量加到窗口大小限制上。</p>
<p>e. Server Push<br>Server Push的资源同样需要遵守同源策略，通过:authority来判断。<br>Server Push有什么好处呢：<br>推送的资源可以被客户端缓存；<br>推送的资源可以被不同的页面复用；<br>推送资源也是支持多路复用的；<br>推送资源可以被客户端拒绝掉(客户端接收到PUSH_PROMISE后，可以选择发送RST_PROMISE来拒绝接收，告诉服务器端不要再发送了，当然，此时可能已经有部分内容已经发送过来了)；</p>
<p>关于Http和Https的区别的点</p>
<p>HTTP和HTTPS的区别，概念层的区别<br>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：<br>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>http的隐患：</p>
<p>1、隐私泄露<br>由于 HTTP 本身是明文传输，用户和服务端之间的传输内容都能被中间者查看。也就是说 你在网上搜索、购物、访问的网点、点击的页面等信息，都可以被「中间人」获取。<br>2、页面劫持<br>隐私泄露的风险比较隐蔽，用户基本感知不到。但另外一类劫持的影响就非常明显非常直接了——页面劫持，也就是直接篡改用户的浏览页面。有很多页面劫持很简单粗暴，直接插入第三方广告或者运营商的流量提示信息。<br>3、劫持路径及分类<br>那劫持到底是如何产生的呢？从技术上来讲比较简单，在内容经过的地方进行监听篡改就行了。但要想把整个劫持的产业链条摸清楚，需要深入黑产内部，比较困难。有一点可以肯定的是，劫持大部分都是在中间的网络节点发生的，又叫「中间人」(MITM， man in the middle)。如下图所示<br><img src="https://blog-10039692.file.myqcloud.com/1486471416100_7812_1486471416521.png" alt=""><br>由于信息传输都需要经过上述的「中间人节点」，它们又拥有信息的读写权限，如果信息没有加密，也没有校验，那么想要查看隐私，篡改页面，对于「中间人」来说可谓是轻而易举。</p>
<p>那劫持又有哪些主要的分类呢?根据劫持路径划分的话，主要是下图所示的三类：<br><img src="https://blog-10039692.file.myqcloud.com/1486471476410_5533_1486471477594.png" alt=""><br>DNS 劫持，客户端劫持和链路劫持。 根据我们的不完全统计，业务遇到的绝大部分劫持 (90%)都属于链路劫持。</p>
<p>HTTPS 为什么能很好的解决链路劫持呢？主要是三大武器:<br>1、身份认证—防假冒，防抵赖<br>每次建立一个全新的 HTTPS 连接时，都需要对身份进行认证，确保用户访问的是正确的目的网站。<br><img src="https://blog-10039692.file.myqcloud.com/1486471569259_8625_1486471569506.png" alt=""></p>
<p>2、内容加密—防窃听<br>内容加密意味端对端的通信内容全都是密文，中间人无法直接查看到明文，HTTPS 所有的应用层内容都是通过对称加密来实现加密和解密的。<br><img src="https://blog-10039692.file.myqcloud.com/1486471621111_7034_1486471621290.png" alt=""></p>
<p>3、一致性校验—防篡改<br>通过对数据和共享密钥的 MAC 码来防止中间者篡改消息内容，确保数据的一致性。<br><img src="https://blog-10039692.file.myqcloud.com/1486471674398_2270_1486471675064.png" alt=""></p>
<p>网络耗时。由于协议的规定，必须要进行的网络传输。比如 SSL 完全握手，302 跳转等。最坏情况下可能要增加 7 个 RTT。<br>计算耗时。无论是客户端还是服务端，都需要进行对称加解密，协议解析，私钥计算，证书校验等计算，增加大量的计算时间。</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1486471843113_1438_1486471843834.png" alt=""></p>
<p>Charles可以用作中间的HTTPS代理，允许您以纯文本形式查看Web浏览器和SSL Web服务器之间的通信。</p>
<p>Charles通过成为中间人来做到这一点。替换浏览器看到服务器的证书，Charles动态地为服务器生成证书，并用它自己的根证书（Charles的CA证书）签名。Charles接收服务器的证书，而您的浏览器接收Charles的证书。因此，您将看到一个安全警告，指示根权限不受信任。</p>
<p>先说一下https使用的非对称加密的原理。等等说非对称加密之前还要说下对称加密的原理。简单来说，对称加密就是加密解密使用同一个密钥。浏览器和服务器交互的话一般会动态生成一个密钥，所以密钥如何交换就成了问题。</p>
<p>下面引入非对称密钥，非对称加密主要用于密钥交换（也叫密钥协商），能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。</p>
<p>密钥交换过程：服务器的公钥是公开的，私钥是不公开的。浏览器先向服务器取得公钥，然后用公钥加密自己的私钥连同自己私钥加密的请求一并发送给服务器。服务器使用自己私钥解密得到浏览器的私钥，使用浏览器的私钥解密请求。然后再用浏览器的私钥加密response发送回浏览器(此处之前笔误写成服务器了)。</p>
<p>中间人攻击是先伪装服务器向浏览器发送伪造的公钥，从而取得浏览器的私钥。这样就完成的浏览器端的解密。服务器端类似。</p>
<p>但是！！！https是可以防止中间人攻击的，因为服务器的公钥是用证书的。charles伪造的证书一般浏览器会警告，所以我们需要将charles的证书认为可靠的。从而实现中间人。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/20180501iOS自动化打包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/20180501iOS自动化打包/" itemprop="url">iOS自动化打包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-01T10:11:12+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于iOS自动化打包工具的脚本<br><a href="https://github.com/hades0918/ipapy/blob/master/ipa.py" target="_blank" rel="noopener">https://github.com/hades0918/ipapy/blob/master/ipa.py</a><br>根据当前文件的路径来实现，从文件的拉取内容上来区分</p>
<p><a href="https://mp.weixin.qq.com/s/iAkN0vPU0wQlv_feWVIc0g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/iAkN0vPU0wQlv_feWVIc0g</a><br>关于iOS自动化打包的一些分享，</p>
<p>关于iOS和swift中涉及的iOS开源库<br><a href="http://blog.csdn.net/qq_16825363/article/details/70064228" target="_blank" rel="noopener">http://blog.csdn.net/qq_16825363/article/details/70064228</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/20180401路由分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/20180401路由分析/" itemprop="url">路由分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-01T10:11:12+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于我们常见的路由的整理：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/26/162602099053e6f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>首先JLRoute是受URL Scheme思路的影响。它把所有对资源的请求看成是一个URI。<br><img src="https://user-gold-cdn.xitu.io/2018/3/26/162602098f06672b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。(全局的静态变量，定义指定不同组件中的scheme和JLRouters的组合)包含注册，非注册，全部解绑注册。</p>
<p>至于为何有这么多条路由，笔者认为，如果路由按照业务线进行划分的话，每个业务线可能会有不相同的逻辑，即使每个业务里面的组件名字可能相同，但是由于业务线不同，会有不同的路由规则。</p>
<p>在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。</p>
<p>不是特别理解pattern，在remove的过程中 实际扮演的意思，还是通过比较做事情</p>
<p>在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/01/20180301启动优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/20180301启动优化/" itemprop="url">App 启动优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-01T10:11:12+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先说结论，t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载；<br>t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</p>
<p>main()调用之前的加载过程<br>App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。<br>动态链接库包括：iOS 中用到的所有系统 framework，加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)和libsystem_blocks (Block)。</p>
<p>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的，那么image究竟包括哪些呢？</p>
<p>什么是image<br>1.executable可执行文件 比如.o文件。<br>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。<br>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p>
<p>除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p>
<p>系统使用动态链接有几点好处：<br>代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份。 易于维护：由于被依赖的 lib 是程序执行时才链接的，所以这些 lib 很容易做更新，比如libSystem.dylib 是 libSystem.B.dylib 的替身，哪天想升级直接换成libSystem.C.dylib 然后再替换替身就行了。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多。</p>
<p>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应），那么ImageLoader又是什么呢？</p>
<p>什么是ImageLoader<br>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。<br>两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。</p>
<p>当然所有这些都发生在我们真正的main函数执行前。</p>
<p>动态链接库加载的具体流程<br>动态链接库的加载步骤具体分为5步：</p>
<p>load dylibs image 读取库镜像文件<br>Rebase image<br>Bind image<br>Objc setup<br>initializers<br>load dylibs image<br>在每个动态库的加载过程中， dyld需要：</p>
<p>分析所依赖的动态库<br>找到动态库的mach-o文件<br>打开文件<br>验证文件<br>在系统核心注册文件签名<br>对动态库的每一个segment调用mmap()<br>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p>
<p>减少非系统库的依赖<br>合并非系统库<br>使用静态资源，比如把代码加入主程序<br>rebase/bind<br>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。<br>通过命令行可以查看相关的资源指针:</p>
<p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p>
<p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p>
<p>减少Objc类数量， 减少selector数量<br>减少C++虚函数数量<br>转而使用swift stuct（其实本质上就是为了减少符号的数量）<br>Objc setup<br>这一步主要工作是:</p>
<p>注册Objc类 (class registration)<br>把category的定义插入方法列表 (category registration)<br>保证每一个selector唯一 (selctor uniquing)<br>由于之前2步骤的优化，这一步实际上没有什么可做的。</p>
<p>initializers<br>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有：</p>
<p>Objc的+load()函数<br>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()<br>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度<br>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p>
<p>dyld 开始将程序二进制文件初始化<br>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号<br>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理<br>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法<br>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。</p>
<p>整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</p>
<p>如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点，这就分别是热启动和冷启动的概念，如下图所示:</p>
<p><img src="http://ofnft8t2g.bkt.clouddn.com/wikiimage2.png" alt=""></p>
<p>main()之前的加载时间如何衡量<br>那么问题就来了，那怎么衡量main()之前也就是time1的耗时呢，苹果官方提供了一种方法，那就是在真机调试的时候勾选dyldPRINTSTATISTICS选项。</p>
<p>由此可见对于系统级别的动态链接库，因为苹果做了优化，所以耗时并不多，在这个awesome的例子中，自身App中的代码占用了整体时间的94.2% 我们应用中一次典型的Log如下：</p>
<p><img src="http://ofnft8t2g.bkt.clouddn.com/wikiimage5.png" alt=""></p>
<p>由此可见，最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。</p>
<p>总结一下：对于main()调用之前的耗时我们可以优化的点有：</p>
<p>减少不必要的framework，因为动态链接比较耗时<br>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查<br>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</p>
<p>删减一些无用的静态变量<br>删减没有被调用到或者已经废弃的方法<br>将不必须在+load方法中做的事情延迟到+initialize中<br>尽量不要用C++虚函数(创建虚函数表有开销)<br>main()调用之后的加载时间</p>
<p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。 App通常在AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。</p>
<p>而视图的渲染主要涉及三个阶段：</p>
<p>准备阶段 这里主要是图片的解码<br>布局阶段 首页所有UIView的- (void)layoutSubViews()运行<br>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行</p>
<p>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方<br>因此，对于main()函数调用之前我们可以优化的点有：</p>
<p>不使用xib，直接视用代码加载首页视图<br>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)<br>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log<br>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</p>
<p>实测数据<br>建立了一个空的HelloWorld工程，只加入了pods中的代码，不包含主端的业务逻辑代码，一次典型的冷启动基本接近2s iPhone6 iOS9.3.5系统测试主要时间在加载动态库，类/方法的初始化还有符号地址绑定阶段。</p>
<p>一次典型的热启动数据如下：可以看到因为系统做了缓存方面的优化，比冷启动快了500ms加上头条主端业务逻辑代码之后一次典型的热启动耗时2.1s。</p>
<p>以上用时均为main()之前的加载耗时。</p>
<p>main()函数之后加载时间优化记录</p>
<p>NSUserDefaults是否是瓶颈<br>苹果官方文档提到NSUserDefaults加载的时候是整个plist配置文件全部load到内存中，目前头条主端当中NSUserDefaults存储了200多项缓存数据，因此怀疑可能拖慢启动速度，但是测试结果显示并不会。 通过符号断点+[NSUserDefaults standardUserDefaults]确定最早一次的+load()从执行到结束耗时1.8ms，可见NSUserDefaults的初始化仅耗时1.8ms，并不是启动耗时的瓶颈。</p>
<p>如何找到拖慢启动应用时长的瓶颈<br>为了找到瓶颈，我们在启动之后的didFinishLauhcning方法开始执行到首页列表页的NewsListViewController的viewDidAppear方法，几乎每个可能比较耗时的流程进行拆分和统计，得到统计数据之后发现： 主要耗时在首页UI构造和渲染(storyboard加载，tabBar/topBar渲染，开屏广告加载/cell注册/日志模块初始化这几个步骤)。</p>
<p>具体优化点<br>因此，针对于今日头条这个App我们可以优化的点如下：</p>
<p>纯代码方式而不是storyboard加载首页UI。<br>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。<br>对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载<br>对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。<br>上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。<br>优化结果<br>之前曾经有一位同事已经做了一定的优化，比如启动之后展示闪屏广告图的同时初始化首页的列表页，当广告展示完成之后列表页也就渲染完成了。经过这一次优化之后的main()之后的启动总时长通过上线之后收集数据的验证达到了预期的效果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/04/20180204自动闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/20180204自动闭包/" itemprop="url">Swift的闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-04T10:11:12+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Swift的自动闭包（autoclosure-noescape-escape-）"><a href="#Swift的自动闭包（autoclosure-noescape-escape-）" class="headerlink" title="Swift的自动闭包（autoclosure,noescape,escape,??）"></a>Swift的自动闭包（autoclosure,noescape,escape,??）</h3><p>@autoclosure（自动闭包）</p>
<p> 1:自动闭包，顾名思义是一种自动创建的闭包，用于包装函数参数的表达式，可以说是一种简便语法.<br> 2:自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。<br> 3:自动闭包的好处之二是让你能够延迟求值,因为代码段不会被执行直到你调用这个闭包，这样你就可以控制代码什么时候执行。<br> 4：含有autoclosure特性的声明同时也具有noescape的特性，及默认是非逃逸闭包，除非传递可选参数escaping.如果传递了该参数，那么将可以在闭包之外进行操作闭包,形式为：请使用@autoclosure(escaping)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/20180203Swift的关键字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/20180203Swift的关键字/" itemprop="url">Swift关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-03T10:11:12+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="关于swift中的知识点"><a href="#关于swift中的知识点" class="headerlink" title="关于swift中的知识点"></a>关于swift中的知识点</h4><p>swift中的所有关键字：</p>
<p>用作声明的关键字:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class、deinit、enum、extension、func、import、init、let、protocol、static、struct、subscript、typealias、var</span><br></pre></td></tr></table></figure></p>
<p>用作语句的关键字<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">break、case、continue、default、break、case、continue、default、do、else、fallthrough、if、in、for、return、switch、where、while</span><br><span class="line">do、else、fallthrough、if、in、for、return、switch、where、while</span><br></pre></td></tr></table></figure></p>
<p>用作表达和类型的关键字：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as、dynamicType、new、is、super、self、Self、Type、__COLUMN__、__FILE__、__FUNCTION__、__LINE__</span><br></pre></td></tr></table></figure></p>
<p>特定上下文中被保留的关键字:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">associativity、didset、get、infix、inout、left、mutating、none、nonmutating、operator、override、postfix、precedence、prefix、rightset、unowned、unowned(sale)、unowned(unsafe)、weak、willset</span><br></pre></td></tr></table></figure></p>
<p>常见的关键字的处理：</p>
<p>class : 用来声明一个类<br>enum : 用来声明一个枚举<br>init : 相对于类的释构方法的修饰。<br>deinit : 相对于类的释构方法的修饰。<br>对于类的构造和释构在swift 中需要使用关键词来修饰，而很多高级语言并不需要特别的指定，便C++ 只需要类名与构造函数名相同就可以，不需要额外的关键词。</p>
<p>extension:扩展(类似于OC的categories)，</p>
<ol>
<li>Swift 中的可以扩展以下几个：</li>
<li>添加计算型属性和计算静态属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个接口</li>
</ol>
<p>let : 声明一个常量. 类似于const<br>protocol : 协议.也可以叫接口.这个往往在很多高级语言中不能多重继承的情况下使用协议是一个比较好的多态方式。<br>static : 声明静态变量或者函数<br>struct : 声明定义一个结构体<br>subscript : 下标索引修饰.可以让class、struct、以及enum使用下标访问内部的值<br>typealias : 为此类型声明一个别名.和 typedef类似.<br>break : 跳出循环.一般在控制流中使用,比如 for . while switch等语句<br>case : switch的选择分支.<br>continue : 跳过本次循环,继续执行后面的循环.<br>in : 范围或集合操作,多用于遍历.<br>fallthrough : swift语是执行完当前case,继续执行下面的case.类似于其它语言中省去break里，会继续往后一个c言特性switch语句的break可以忽略不写,满足条件时直接跳出循环.fallthrough的作用就是执行完当前case,继续执行下面的case.类似于其它语言中省去break里，会继续往后一个case跑，直到碰到break或default才完成的效果.</p>
<p>where : 用于条件判断,和数据库查询时的where ‘id &gt; 10’这样功能. swift语言的特性.OC中并没有.<br>is &amp; as : is一般用于对一些变量的类型做判断.类似于OC中的isKindClass. as 与强制转换含义雷同.<br>as的使用场合，从派生类向基类转化。<br>as！向下转类型，由于是强制类型转化，如果转化失败，会报runtime的错误。<br>as?使用的场合，as？和as!操作符的转化规则是完全一致的，但as？如果转化不成功的时候便会返回一个nil对象，成功的话，返回可选择的类型的值，需要拆包使用，并且as？及时出现错误了，也不会报错，如果对于转化需要确保100%的话，可以使用as！，需要做细节说明。</p>
<p>没看懂是怎么使用的，暂时先忽略的关键字<br>dynamicType:获取对象的动态类型,即运行时的实际类型,而非代码指定或编译器看到的类型</p>
<p><strong>COLUMN</strong> 列号<br><strong>FILE</strong> 路径<br><strong>FUNCTION</strong> 函数<br><strong>LINE</strong> 行号</p>
<p>运算符的结合性： associativity<br>inout: inout作为函数声明，引用传值的关键字，但是在调用的时候引用的地址，所以在引用的时候要加上&amp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func test(inout a : Int ,inout b : Int) &#123;</span><br><span class="line">&#125;</span><br><span class="line">var num1 = 3</span><br><span class="line">var num2 = 4</span><br><span class="line">test(&amp;num1,&amp;num2)</span><br></pre></td></tr></table></figure></p>
<p>willSet和didSet:willSet和didSet的作用是对赋值过程前后附加额外的操作<br>可以看做是捕获状态然后做操作,在将要赋值的时候和已经赋值的时候做相关操作</p>
<p>mutating:作用:写在func前面,以便于让func可以修改struct和protocol的extension中的成员的值。 如果func前面不加mutating,struct和protocol的extension中的成员的值便被保护起来,不能修改</p>
<p>class var:在swift中对于enum和struct来说支持用static关键字来标示静态变量，<br>但是对于class成员来说，只能以class var的方式返回一个只读值</p>
<p>convenience : convenience用来进行方便的初始化，就相当于构造函数重载。<br>对于class来讲，默认或指定的初始化方法作为所谓的Designated初始化。<br>若重载的初始化需要调用Designated初始化则将它作为convenience初始化，在方法前要加上convenience关键字<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Figure&#123;</span><br><span class="line">       var name:String!</span><br><span class="line">       var nikname:String?</span><br><span class="line">       init()&#123;</span><br><span class="line">          name = "John"</span><br><span class="line">       &#125;</span><br><span class="line">      convenience init(name:String!,nikname:String!) &#123;</span><br><span class="line">           self.init() self.name = name self.nikname = nikname</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>precedence : 运算的优先级，越高的话优先进行计算。swift 中乘法和除法的优先级是 150 ，加法和减法的优先级是 140 ，这里我们定义点积的优先级为 160 ，就是说应该早于普通的乘除进行运算。<br>unowned, unowned(safe), unowned(unsafe):无宿主引用。<br>infix: 表示要定义的是一个中位操作符，即前后都是输入<br>defer: 用来包裹一段代码，这个代码块将会在当前作用域结束的时候被调用。这通常被用来对当前的代码进行一些清理工作，比如关闭打开的文件等。<br>可以在同一个作用域中指定多个 defer<br>代码块，在当前作用域结束时，它们会以相反的顺序被调用，即先定义的后执行，后定义的先执行。<br>guard : 当某些条件不满足的情况下，跳出作用域. 色值</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/20180202Swift设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/20180202Swift设计模式/" itemprop="url">Swift的常用设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-02T10:11:12+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于swifter中的设计模式：</p>
<p>单例模式确保每个指定的类只存在一个实例对象，并且可以全局访问那个实例。一般情况下会使用延时加载的策略，只在第一次需要使用的时候初始化。</p>
<p>注意：在 iOS 中单例模式很常见，NSUserDefaults.standardUserDefaults() 、 UIApplication.sharedApplication() 、 UIScreen.mainScreen() 、 NSFileManager.defaultManager() 这些都是单例模式。</p>
<p>你可能会疑惑了：如果多于一个实例又会怎么样呢？代码和内存还没精贵到这个地步吧？</p>
<p>某些场景下，保持实例对象仅有一份是很有意义的。举个例子，你的应用实例 (UIApplication)，应该只有一个吧，显然是指你的当前应用。还有一个例子：设备的屏幕 (UIScreen) 实例也是这样，所以对于这些类的情况，你只想要一个实例对象。</p>
<p>单例模式的应用还有另一种情况：你需要一个全局类来处理配置文件。我们很容易通过单例模式实现线程安全的实例访问，而如果有多个类可以同时访问配置文件，那可就复杂多了。</p>
<p>如何使用单例模式<br>可以看下这个图：</p>
<p><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.6.png" alt=""><br>这是一个日志类，有一个属性 (是一个单例对象) 和两个方法 (sharedInstance() 和 init())。</p>
<p>第一次调用 sharedInstance() 的时候，instance 属性还没有初始化。所以我们要创建一个新实例并且返回。</p>
<p>下一次你再调用 sharedInstance() 的时候，instance 已经初始化完成，直接返回即可。这个逻辑确保了这个类只存在一个实例对象。</p>
<p>接下来我们继续完善单例模式，通过这个类来管理专辑数据。</p>
<p>注意到在我们前面的截图里，分组中有个 API 分组，这里可以放那些提供后台服务的类。在这个分组中创建一个新的文件 LibraryAPI.swift ，继承自 NSObject 类。</p>
<p>在 LibraryAPI 里添加下面这段代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">class var sharedInstance: LibraryAPI &#123;</span><br><span class="line">    //2</span><br><span class="line">    struct Singleton &#123;</span><br><span class="line">        //3</span><br><span class="line">        static let instance = LibraryAPI()</span><br><span class="line">    &#125;</span><br><span class="line">    //4</span><br><span class="line">    return Singleton.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这几行代码里，做了如下工作：<br>创建一个计算类型的类变量，这个类变量，就像是 objc 中的静态方法一样，可以直接通过类访问而不用实例对象。具体可参见苹果官方文档的 [属性][10] 这一章。<br>在类变量里嵌套一个 Singleton 结构体。<br>Singleton 封装了一个静态的常量，通过 static 定义意味着这个属性只存在一个，注意 Swift 中 static 的变量是延时加载的，意味着 Instance 直到需要的时候才会被创建。同时再注意一下，因为它是一个常量，所以一旦创建之后不会再创建第二次。这些就是单例模式的核心所在：一旦初始化完成，当前类存在一个实例对象，初始化方法就不会再被调用。<br>返回计算后的属性值。<br>注意：更多的单例模式实例可以看看 Github 上的这个[示例][11]，列举了单例模式的若干种实现方式。<br>你现在可以将这个单例作为专辑管理类的入口，接下来我们继续创建一个处理专辑数据持久化的类。<br>新建 PersistencyManager.swift 并添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var albums = [Album]()</span><br></pre></td></tr></table></figure></p>
<p>在这里我们定义了一个私有属性，用来存储专辑数据。这是一个可变数组，所以你可以很容易的增加或者删除数据。</p>
<p>然后加上一些初始化的数据：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">  //Dummy list of albums</span><br><span class="line">  let album1 = Album(title: "Best of Bowie",</span><br><span class="line">         artist: "David Bowie",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png",</span><br><span class="line">         year: "1992")</span><br><span class="line"></span><br><span class="line">  let album2 = Album(title: "It's My Life",</span><br><span class="line">         artist: "No Doubt",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png",</span><br><span class="line">         year: "2003")</span><br><span class="line"></span><br><span class="line">  let album3 = Album(title: "Nothing Like The Sun",</span><br><span class="line">         artist: "Sting",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png",</span><br><span class="line">         year: "1999")</span><br><span class="line"></span><br><span class="line">  let album4 = Album(title: "Staring at the Sun",</span><br><span class="line">         artist: "U2",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png",</span><br><span class="line">         year: "2000")</span><br><span class="line"></span><br><span class="line">  let album5 = Album(title: "American Pie",</span><br><span class="line">         artist: "Madonna",</span><br><span class="line">         genre: "Pop",</span><br><span class="line">         coverUrl: "http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png",</span><br><span class="line">         year: "2000")</span><br><span class="line"></span><br><span class="line">  albums = [album1, album2, album3, album4, album5]</span><br><span class="line">&#125;</span><br><span class="line">在这个初始化方法里，我们初始化了五张专辑。如果上面的专辑没有你喜欢的，你可以随意替换成你的菜:]</span><br><span class="line"></span><br><span class="line">然后添加如下方法：</span><br><span class="line">func getAlbums() -&gt; [Album] &#123;</span><br><span class="line">  return albums</span><br><span class="line">&#125;</span><br><span class="line">func addAlbum(album: Album, index: Int) &#123;</span><br><span class="line">  if (albums.count &gt;= index) &#123;</span><br><span class="line">    albums.insert(album, atIndex: index)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    albums.append(album)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func deleteAlbumAtIndex(index: Int) &#123;</span><br><span class="line">  albums.removeAtIndex(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些方法可以让你自由的访问、添加、删除专辑数据。</p>
<p>这时你可以运行一下你的项目，确保编译通过以便进行下一步操作。</p>
<p>此时你或许会感到好奇： PersistencyManager 好像不是单例啊？是的，它确实不是单例。不过没关系，在接下来的外观模式章节，你会看到 LibraryAPI 和 PersistencyManager 之间的联系。</p>
<p>Model-View-Controller (缩写 MVC ) 是 Cocoa 框架的一部分，并且毋庸置疑是最常用的设计模式之一。它可以帮你把对象根据职责进行划分和归类。</p>
<p>作为划分依据的三个基本职责是：</p>
<p>模型层 (Model) ：存储数据并且定义如何操作这些数据。在我们的例子中，就是 Album 类。<br>视图层 (View) ：负责模型层的可视化展示，并且负责用户的交互，一般来说都是继承自 UIView 这个基类。在我们的项目中就是 AlbumView 这个类。<br>控制器 (Controller) ：控制器是整个系统的掌控者，它连接了模型层和数据层，并且把数据在视图层展示出来，监听各种事件，负责数据的各种操作。不妨猜猜在我们的项目中哪个是控制器？啊哈猜对了：ViewController 这个类就是。<br>如果你的项目遵循 MVC 的设计模式，那么各种对象要不是 Model ，要不是 View ，要不就是 Controller。当然在实际的开发中也可以灵活变化，比如结合具体业务使用 MVVM 结构给 ViewController 瘦瘦身，也是可以的。</p>
<p>三者之间的关系如下<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.4.png" alt=""><br>模型层通知控制器层任何数据的变化，然后控制器层会刷新视图层中的数据。视图层可以通知控制器层用户的交互事件，然后控制器会处理各种事件以及刷新数据。</p>
<p>你可能会感觉奇怪：为什么要把这三个东西分开来，而不能揉在一个类里呢？那样似乎更简单一点嘛。</p>
<p>Naive.</p>
<p>之所以这样做，是为了将代码更好的分离和重用。理想状态下，视图层应当和模型层完全分离。如果视图层不依赖任何模型层的具体实现，那么就可以很容易的被其他模型复用，用来展示不同的数据。</p>
<p>举个例子，比如在未来我们需要添加电影或者什么书籍，我们依旧可以使用 AlbumView 这个类作为展示。更久远点来说，在以后如果你创建了一个新的项目并且需要用到和专辑相关的内容，你可以直接复用 Album 类因为它并不依赖于任何视图模块。这就是 MVC 的强大之处，三大元素，各司其职，减少依赖。</p>
<p>如何使用 MVC 模式<br>首先，你需要确定你的项目中的每个类都是三大基本类型中的一种：控制器、模型、视图。不要在一个类里糅合多个角色。目前我们创建了 Album 类和 AlbumView 类是符合要求的，做得很好。</p>
<p>然后，为了确保你遵循这种模式，你最好创建三个项目分组来存放代码，分别是 Model、View、Controller，保持每个类型的文件分别独立。</p>
<p>接下来把 Album.swift 拖到 Model 分组，把 AlbumView.swift 拖到 View 分组，然后把 ViewController.swift 拖到 Controller 分组中。</p>
<p>现在你的项目应该是这个样子：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.5.png" alt=""><br>现在你的项目已经有点样子了，不再是各个文件颠沛流离居无定所了。显然你还会有其他分组和类，但是应用的核心就在这三个类里。</p>
<p>现在你的内容已经组织好了，接下来要做的就是获取专辑的数据。你将会创建一个 API 类来管理数据 - 这里我们会用到下一个设计模式：单例模式。</p>
<p>外观模式在复杂的业务系统上提供了简单的接口。如果直接把业务的所有接口直接暴露给使用者，使用者需要单独面对这一大堆复杂的接口，学习成本很高，而且存在误用的隐患。如果使用外观模式，我们只要暴露必要的 API 就可以了。</p>
<p>下图演示了外观模式的基本概念：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.8.png" alt=""></p>
<p>API 的使用者完全不知道这内部的业务逻辑有多么复杂。当我们有大量的类并且它们使用起来很复杂而且也很难理解的时候，外观模式是一个十分理想的选择。</p>
<p>外观模式把使用和背后的实现逻辑成功解耦，同时也降低了外部代码对内部工作的依赖程度。如果底层的类发生了改变，外观的接口并不需要做修改。</p>
<p>举个例子，如果有一天你想换掉所有的后台服务，你只需要修改 API 内部的代码，外部调用 API 的代码并不会有改动。</p>
<p>如何使用外观模式<br>现在我们用 PersistencyManager 来管理专辑数据，用 HTTPClient 来处理网络请求，项目中的其他类不应该知道这个逻辑。他们只需要知道 LibraryAPI 这个”外观”就可以了。</p>
<p>为了实现外观模式，应该只让 LibraryAPI 持有 PersistencyManager 和 HTTPClient 的实例，然后 LibraryAPI 暴露一个简单的接口给其他类来访问，这样外部的访问类不需要知道内部的业务具体是怎样的，也不用知道你是通过 PersistencyManager 还是 HTTPClient 获取到数据的。</p>
<p>大致的设计是这样的：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.9.png" alt=""><br>LibraryAPI 会暴露给其他代码访问，但是 PersistencyManager 和 HTTPClient 则是不对外开放的。</p>
<p>打开 LibraryAPI.swift 然后添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private let persistencyManager: PersistencyManager</span><br><span class="line">private let httpClient: HTTPClient</span><br><span class="line">private let isOnline: Bool</span><br></pre></td></tr></table></figure></p>
<p>除了两个实例变量之外，还有个 Bool 值： isOnline ，这个是用来标识当前是否为联网状态的，如果是联网状态就会去网络获取数据。</p>
<p>我们需要在 init 里面初始化这些变量：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">  persistencyManager = PersistencyManager()</span><br><span class="line">  httpClient = HTTPClient()</span><br><span class="line">  isOnline = false</span><br><span class="line"></span><br><span class="line">  super.init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HTTPClient 并不会直接和真实的服务器交互，只是用来演示外观模式的使用。所以 inOnline 这个值我们一直设置为 false。</p>
<p>接下来在 LibraryAPI.swift 里添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func getAlbums() -&gt; [Album] &#123;</span><br><span class="line">  return persistencyManager.getAlbums()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func addAlbum(album: Album, index: Int) &#123;</span><br><span class="line">  persistencyManager.addAlbum(album, index: index)</span><br><span class="line">  if isOnline &#123;</span><br><span class="line">    httpClient.postRequest("/api/addAlbum", body: album.description())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func deleteAlbum(index: Int) &#123;</span><br><span class="line">  persistencyManager.deleteAlbumAtIndex(index)</span><br><span class="line">  if isOnline &#123;</span><br><span class="line">    httpClient.postRequest("/api/deleteAlbum", body: "(index)")</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看一下 addAlbum(_:index:) 这个方法，先更新本地缓存，然后如果是联网状态还需要向服务器发送网络请求。这便是外观模式的强大之处：如果外部文件想要添加一个新的专辑，它不会也不用去了解内部的实现逻辑是怎么样的。</p>
<p>注意：当你设计外观的时候，请务必牢记：使用者随时可能直接访问你的隐藏类。永远不要假设使用者会遵循你当初的设计做事。</p>
<h3 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式 - Decorator"></a>装饰者模式 - Decorator</h3><p>装饰者模式可以动态的给指定的类添加一些行为和职责，而不用对原代码进行任何修改。当你需要使用子类的时候，不妨考虑一下装饰者模式，可以在原始类上面封装一层。</p>
<p>在 Swift 里，有两种方式实现装饰者模式：扩展 (Extension) 和委托 (Delegation)。</p>
<p>扩展<br>扩展是一种十分强大的机制，可以让你在不用继承的情况下，给已存在的类、结构体或者枚举类添加一些新的功能。最重要的一点是，你可以在你没有访问权限的情况下扩展已有类。这意味着你甚至可以扩展 Cocoa 的类，比如 UIView 或者 UIImage 。</p>
<p>举个例子，在编译时新加的方法可以像扩展类的正常方法一样执行。这和装饰器模式有点不同，因为扩展不会持有扩展类的对象。</p>
<p>如何使用扩展<br>想象一下这个场景，我们需要在下面这个列表里展示数据：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.11.png" alt=""><br>专辑标题从哪里来？ Album 本身是个 Model 对象，所以它不应该负责如何展示数据。你需要一些额外的代码添加展示数据的逻辑，但是为了保持 Model 的干净，我们不应该直接修改代码，因为这样不符合单一职责原则。 Model 层最好就是负责纯粹的数据结构，如果有数据的操作可以放到扩展中完成。</p>
<p>接下来我们会创建一个扩展，扩展现有的 Album 类，在扩展里定义了新的方法，返回更适合 UITableView 展示用的数据结构。</p>
<p>数据的结构大概是这样：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.12.png" alt=""><br>新建一个 Swift 文件：AlbumExtensions ，在里面添加如下扩展：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Album &#123;</span><br><span class="line">  func ae_tableRepresentation() -&gt; (titles:[String], values:[String]) &#123;</span><br><span class="line">    return (["Artist", "Album", "Genre", "Year"], [artist, title, genre, year])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在方法的前面有个 ae_ 前缀，是 AlbumExtension 的缩写，这样有利于和类的原有方法进行区分，避免使用的时候产生冲突。现在很多还在维护中的第三方库都已经改成了这个风格。</p>
<p>注意：类是可以重写父类方法的，但是在扩展里不可以。扩展里的方法和属性不能和原始类里的方法和属性冲突。</p>
<p>思考一下这个设计模式的强大之处：</p>
<p>我们可以直接在扩展里使用 Album 里的属性。<br>我们给 Album 类添加了内容但是并没有继承它，事实上，使用继承来扩展业务也可以实现一样的功能。<br>这个简单的扩展让我们可以更好地把 Album 的数据展示在 UITableView 里，而且不用修改源码。<br>委托<br>装饰者模式的另一种实现方案是委托。在这种机制下，一个对象可以和另一个对象相关联。比如你在用 UITableView ，你必须实现 tableView(_:numberOfRowsInSection:) 这个委托方法。</p>
<p>你不应该指望 UITableView 知道你有多少数据，这是个应用层该解决的问题。所以，数据相关的计算应该通过 UITableView 的委托来解决。这样可以让 UITableView 和数据层分别独立。视图层就负责显示数据，你递过来什么我就显示什么。</p>
<p>下面这张图很好的解释了 UITableView 的工作过程：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/1.13.png" alt=""><br>UITableView 的工作仅仅是展示数据，但是最终它需要知道自己要展示那些数据，这时就可以向它的委托询问。在 objc 的委托模式里，一个类可以通过协议来声明可选或者必须的方法。</p>
<p>看起来似乎继承然后重写必须的方法来的更简单一点。但是考虑一下这个问题：继承的结果必定是一个独立的类，如果你想让某个对象成为多个对象的委托，那么子类这招就行不通了。<br>注意：委托模式十分重要，苹果在 UIKit 中大量使用了该模式，基本上随处可见。</p>
<p>打开 ViewController.swift 文件，添加如下私有变量：</p>
<p>private var allAlbums = <a href="">Album</a><br>private var currentAlbumData : (titles:[String], values:[String])?<br>private var currentAlbumIndex = 0<br>在 viewDidLoad 里面加入如下内容：</p>
<p>override func viewDidLoad() {<br>    super.viewDidLoad()</p>
<pre><code>self.navigationController?.navigationBar.translucent = false
currentAlbumIndex = 0

allAlbums = LibraryAPI.sharedInstance.getAlbums()

dataTable.delegate = self
dataTable.dataSource = self
dataTable.backgroundView = nil
view.addSubview(dataTable!)
</code></pre><p>}<br>对上面三个部分进行拆解：</p>
<p>关闭导航栏的透明效果</p>
<p>通过 API 获取所有的专辑数据，记住，我们使用外观模式之后，应该从 LibraryAPI 获取数据，而不是 PersistencyManager 。</p>
<p>你可以在这里设置你的 UITablweView ，在这里声明了 UITableView 的 delegate 是当前的 ViewController 。事实上你用了 XIB 或者 StoryBoard ，可以直接在可视化的页面里拖拽完成。<br>接下来添加一个新的方法用来更方便的获取数据：</p>
<p>func showDataForAlbum(albumIndex: Int) {</p>
<pre><code>if (albumIndex &lt; allAlbums.count &amp;&amp; albumIndex &gt; -1) {

    let album = allAlbums[albumIndex]

    currentAlbumData = album.ae_tableRepresentation()
} else {
    currentAlbumData = nil
}

dataTable!.reloadData()
</code></pre><p>}<br>showDataForAlbum() 这个方法获取最新的专辑数据，当你想要展示新数据的时候，你需要调用 reloadData() 这个方法，这样 UITableView 就会向委托请求数据，比如有多少个 section 有多少个 row 之类的。</p>
<p>在 viewDidLoad 里面调用上面的方法：</p>
<p>self.showDataForAlbum(currentAlbumIndex)<br>这样应用一启动就会去加载当前的专辑数据。因为 currentAlbumIndex 的默认值是 0 ，所以一开始会默认显示第一章专辑的信息。</p>
<p>接下来我们该去完善 DataSource 的协议方法了。你可以直接把委托方法写在类里面，当然如果你想让你的代码看起来更整洁一点，则可以放在扩展里。</p>
<p>在文件底部添加如下方法，注意一定要放在类定义的大括号外面，因为这两个家伙不是类定义的一部分，它们是扩展：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: UITableViewDataSource &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ViewController: UITableViewDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是实现委托的方法 - 你可以把协议想象成是与委托之间的约定，只要你实现了约定的方法，就算是实现了委托。在我们的代码中， ViewController 需要遵守 UITableViewDataSource 和 UITableViewDelegate 的协议。这样 UITableView 才能确保必要的委托方法都已经实现了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在 UITableViewDataSource 对应的那个扩展里加上如下方法：</span><br><span class="line">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">  if let albumData = currentAlbumData &#123;</span><br><span class="line">    return albumData.titles.count</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">  var cell:UITableViewCell = tableView.dequeueReusableCellWithIdentifier("Cell", forIndexPath: indexPath) as UITableViewCell</span><br><span class="line">  if let albumData = currentAlbumData &#123;</span><br><span class="line">    cell.textLabel?.text = albumData.titles[indexPath.row]</span><br><span class="line">      if let detailTextLabel = cell.detailTextLabel &#123;</span><br><span class="line">        detailTextLabel.text = albumData.values[indexPath.row]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br><span class="line">tableView(_:numberOfRowsInSection:) 返回需要展示的行数，和存储的数据中的 title 的数目相同。</span><br><span class="line"></span><br><span class="line">tableView(_:cellForRowAtIndexPath:) 创建并且返回了一个单元格，上面有标题和对应的值。</span><br></pre></td></tr></table></figure></p>
<p>注意：你可以把这些方法直接加在类声明里面，也可以放在扩展里，编译器不会去管数据源到底在哪里，只要能找到对应的方法就可以了。而我们之所以这样做，是为了方便其他人阅读。</p>
<h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 - Adapter"></a>适配器模式 - Adapter</h3><p>适配器把自己封装起来然后暴露统一的接口给其他类，这样即使其他类的接口各不相同，也能相安无事，一起工作。</p>
<p>如果你熟悉适配器模式，那么你会发现苹果在实现适配器模式的方式稍有不同：苹果通过委托实现了适配器模式。委托相信大家都不陌生。举个例子，如果一个类遵循了 NSCoying 的协议，那么它一定要实现 copy 方法。</p>
<p>如何使用适配器模式<br>横滑的滚动栏理论上应该是这个样子的：</p>
<p>新建一个 Swift 文件：HorizontalScroller.swift ，作为我们的横滑滚动控件， HorizontalScroller 继承自 UIView 。</p>
<p>打开 HorizontalScroller.swift 文件并添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol HorizontalScrollerDelegate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这行代码定义了一个新的协议： HorizontalScrollerDelegate 。我们在前面加上了 @objc 的标记，这样我们就可以像在 objc 里一样使用 @optional 的委托方法了。</p>
<p>接下来我们在大括号里定义所有的委托方法，包括必须的和可选的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 在横滑视图中有多少页面需要展示</span><br><span class="line">func numberOfViewsForHorizontalScroller(scroller: HorizontalScroller) -&gt; Int</span><br><span class="line">// 展示在第 index 位置显示的 UIView</span><br><span class="line">func horizontalScrollerViewAtIndex(scroller: HorizontalScroller, index:Int) -&gt; UIView</span><br><span class="line">// 通知委托第 index 个视图被点击了</span><br><span class="line">func horizontalScrollerClickedViewAtIndex(scroller: HorizontalScroller, index:Int)</span><br><span class="line">// 可选方法，返回初始化时显示的图片下标，默认是0</span><br><span class="line">optional func initialViewIndex(scroller: HorizontalScroller) -&gt; Int</span><br><span class="line">​``` xml</span><br><span class="line">其中，没有 option 标记的方法是必须实现的，一般来说包括那些用来显示的必须数据，比如如何展示数据，有多少数据需要展示，点击事件如何处理等等，不可或缺；有 option 标记的方法为可选实现的，相当于是一些辅助设置和功能，就算没有实现也有默认值进行处理。</span><br><span class="line"></span><br><span class="line">在 HorizontalScroller 类里添加一个新的委托对象：</span><br><span class="line"></span><br><span class="line">weak var delegate: HorizontalScrollerDelegate?</span><br><span class="line">为了避免循环引用的问题，委托是 weak 类型。如果委托是 strong 类型的，当前对象持有了委托的强引用，委托又持有了当前对象的强引用，这样谁都无法释放就会导致内存泄露。</span><br><span class="line"></span><br><span class="line">委托是可选类型，所以很有可能当前类的使用者并没有指定委托。但是如果指定了委托，那么它一定会遵循 HorizontalScrollerDelegate 里约定的内容。</span><br><span class="line"></span><br><span class="line">再添加一些新的属性：</span><br><span class="line">​``` xml</span><br><span class="line">// 1</span><br><span class="line">private let VIEW_PADDING = 10</span><br><span class="line">private let VIEW_DIMENSIONS = 100</span><br><span class="line">private let VIEWS_OFFSET = 100</span><br><span class="line">// 2</span><br><span class="line">private var scroller : UIScrollView!</span><br><span class="line">// 3</span><br><span class="line">var viewArray = [UIView]()</span><br><span class="line">上面标注的三点分别做了这些事情：</span><br><span class="line"></span><br><span class="line">定义一个常量，用来方便的改变布局。现在默认的是显示的内容长宽为100，间隔为10。</span><br><span class="line">创建一个 UIScrollView 作为容器。</span><br><span class="line">创建一个数组用来存放需要展示的数据</span><br><span class="line">接下来实现初始化方法：</span><br><span class="line"></span><br><span class="line">override init(frame: CGRect) &#123;</span><br><span class="line">    super.init(frame: frame)</span><br><span class="line">    initializeScrollView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">required init(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    super.init(coder: aDecoder)</span><br><span class="line">    initializeScrollView()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initializeScrollView() &#123;</span><br><span class="line">    //1</span><br><span class="line">    scroller = UIScrollView()</span><br><span class="line">    addSubview(scroller)</span><br><span class="line"></span><br><span class="line">    //2</span><br><span class="line">    scroller.setTranslatesAutoresizingMaskIntoConstraints(false)</span><br><span class="line">    //3</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Leading, relatedBy: .Equal, toItem: self, attribute: .Leading, multiplier: 1.0, constant: 0.0))</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Trailing, relatedBy: .Equal, toItem: self, attribute: .Trailing, multiplier: 1.0, constant: 0.0))</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Top, relatedBy: .Equal, toItem: self, attribute: .Top, multiplier: 1.0, constant: 0.0))</span><br><span class="line">    self.addConstraint(NSLayoutConstraint(item: scroller, attribute: .Bottom, relatedBy: .Equal, toItem: self, attribute: .Bottom, multiplier: 1.0, constant: 0.0))</span><br><span class="line"></span><br><span class="line">    //4</span><br><span class="line">    let tapRecognizer = UITapGestureRecognizer(target: self, action:Selector("scrollerTapped:"))</span><br><span class="line">    scroller.addGestureRecognizer(tapRecognizer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码做了如下工作：</p>
<p>创建一个 UIScrollView 对象并且把它加到父视图中。<br>关闭 autoresizing masks ，从而可以使用 AutoLayout 进行布局。<br>给 scrollview 添加约束。我们希望 scrollview 能填满 HorizontalScroller 。<br>创建一个点击事件，检测是否点击到了专辑封面，如果确实点击到了专辑封面，我们需要通知 HorizontalScroller 的委托。<br>添加委托方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> func scrollerTapped(gesture: UITapGestureRecognizer) &#123;</span><br><span class="line">  let location = gesture.locationInView(gesture.view)</span><br><span class="line">  if let delegate = self.delegate &#123;</span><br><span class="line">    for index in 0..<span class="tag">&lt;<span class="name">delegate.numberOfViewsForHorizontalScroller(self)</span> &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">let</span> <span class="attr">view</span> = <span class="string">scroller.subviews[index]</span> <span class="attr">as</span> <span class="attr">UIView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">if</span> <span class="attr">CGRectContainsPoint</span>(<span class="attr">view.frame</span>, <span class="attr">location</span>) &#123;</span></span><br><span class="line"><span class="tag">        <span class="attr">delegate.horizontalScrollerClickedViewAtIndex</span>(<span class="attr">self</span>, <span class="attr">index:</span> <span class="attr">index</span>)</span></span><br><span class="line"><span class="tag">        <span class="attr">scroller.setContentOffset</span>(<span class="attr">CGPointMake</span>(<span class="attr">view.frame.origin.x</span> <span class="attr">-</span> <span class="attr">self.frame.size.width</span>/<span class="attr">2</span> + <span class="attr">view.frame.size.width</span>/<span class="attr">2</span>, <span class="attr">0</span>), <span class="attr">animated:true</span>)</span></span><br><span class="line"><span class="tag">        <span class="attr">break</span></span></span><br><span class="line"><span class="tag">      &#125;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们把 gesture 作为一个参数传了进来，这样就可以获取点击的具体坐标了。</p>
<p>接下来我们调用了 numberOfViewsForHorizontalScroller 方法，HorizontalScroller 不知道自己的 delegate 具体是谁，但是知道它一定实现了 HorizontalScrollerDelegate 协议，所以可以放心的调用。</p>
<p>对于 scroll view 中的 view ，通过 CGRectContainsPoint 进行点击检测，从而获知是哪一个 view 被点击了。当找到了点击的 view 的时候，则会调用委托方法里的 horizontalScrollerClickedViewAtIndex 方法通知委托。在跳出 for 循环之前，先把点击到的 view 居中。</p>
<p>接下来我们再加个方法获取数组里的 view ：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func viewAtIndex(index :Int) -&gt; UIView &#123;</span><br><span class="line">  return viewArray[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很简单，只是用来更方便获取数组里的 view 而已。在后面实现高亮选中专辑的时候会用到这个方法。</p>
<p>添加如下代码用来重新加载 scroller ：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func reload() &#123;</span><br><span class="line">  // 1 - Check if there is a delegate, if not there is nothing to load.</span><br><span class="line">  if let delegate = self.delegate &#123;</span><br><span class="line">    //2 - Will keep adding new album views on reload, need to reset.</span><br><span class="line">    viewArray = []</span><br><span class="line">    let views: NSArray = scroller.subviews</span><br><span class="line"></span><br><span class="line">    // 3 - remove all subviews</span><br><span class="line">    views.enumerateObjectsUsingBlock &#123;</span><br><span class="line">    (object: AnyObject!, idx: Int, stop: UnsafeMutablePointer<span class="tag">&lt;<span class="name">ObjCBool</span>&gt;</span>) -&gt; Void in</span><br><span class="line">      object.removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">    // 4 - xValue is the starting point of the views inside the scroller            </span><br><span class="line">    var xValue = VIEWS_OFFSET</span><br><span class="line">    for index in 0..<span class="tag">&lt;<span class="name">delegate.numberOfViewsForHorizontalScroller(self)</span> &#123;</span></span><br><span class="line"><span class="tag">      // <span class="attr">5</span> <span class="attr">-</span> <span class="attr">add</span> <span class="attr">a</span> <span class="attr">view</span> <span class="attr">at</span> <span class="attr">the</span> <span class="attr">right</span> <span class="attr">position</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xValue</span> += <span class="string">VIEW_PADDING</span></span></span><br><span class="line"><span class="tag">      <span class="attr">let</span> <span class="attr">view</span> = <span class="string">delegate.horizontalScrollerViewAtIndex(self,</span> <span class="attr">index:</span> <span class="attr">index</span>)</span></span><br><span class="line"><span class="tag">      <span class="attr">view.frame</span> = <span class="string">CGRectMake(CGFloat(xValue),</span> <span class="attr">CGFloat</span>(<span class="attr">VIEW_PADDING</span>), <span class="attr">CGFloat</span>(<span class="attr">VIEW_DIMENSIONS</span>), <span class="attr">CGFloat</span>(<span class="attr">VIEW_DIMENSIONS</span>))</span></span><br><span class="line"><span class="tag">      <span class="attr">scroller.addSubview</span>(<span class="attr">view</span>)</span></span><br><span class="line"><span class="tag">      <span class="attr">xValue</span> += <span class="string">VIEW_DIMENSIONS</span> + <span class="attr">VIEW_PADDING</span></span></span><br><span class="line"><span class="tag">      // <span class="attr">6</span> <span class="attr">-</span> <span class="attr">Store</span> <span class="attr">the</span> <span class="attr">view</span> <span class="attr">so</span> <span class="attr">we</span> <span class="attr">can</span> <span class="attr">reference</span> <span class="attr">it</span> <span class="attr">later</span></span></span><br><span class="line"><span class="tag">     <span class="attr">viewArray.append</span>(<span class="attr">view</span>)</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">    // <span class="attr">7</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scroller.contentSize</span> = <span class="string">CGSizeMake(CGFloat(xValue</span> + <span class="attr">VIEWS_OFFSET</span>), <span class="attr">frame.size.height</span>)</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    // <span class="attr">8</span> <span class="attr">-</span> <span class="attr">If</span> <span class="attr">an</span> <span class="attr">initial</span> <span class="attr">view</span> <span class="attr">is</span> <span class="attr">defined</span>, <span class="attr">center</span> <span class="attr">the</span> <span class="attr">scroller</span> <span class="attr">on</span> <span class="attr">it</span></span></span><br><span class="line"><span class="tag">    <span class="attr">if</span> <span class="attr">let</span> <span class="attr">initialView</span> = <span class="string">delegate.initialViewIndex?(self)</span> &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">scroller.setContentOffset</span>(<span class="attr">CGPointMake</span>(<span class="attr">CGFloat</span>(<span class="attr">initialView</span>)*<span class="attr">CGFloat</span>((<span class="attr">VIEW_DIMENSIONS</span> + (<span class="attr">2</span> * <span class="attr">VIEW_PADDING</span>))), <span class="attr">0</span>), <span class="attr">animated:</span> <span class="attr">true</span>)</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个 reload 方法有点像是 UITableView 里面的 reloadData 方法，它会重新加载所有数据。</p>
<p>一段一段的看下上面的代码：</p>
<p>在调用 reload 之前，先检查一下是否有委托。<br>既然要清除专辑封面，那么也需要重新设置 viewArray ，要不然以前的数据会累加进来。<br>移除先前加入到 scrollview 的子视图。<br>所有的 view 都有一个偏移量，目前默认是100，我们可以修改 VIEW_OFFSET 这个常量轻松的修改它。<br>HorizontalScroller 通过委托获取对应位置的 view 并且把它们放在对应的位置上。<br>把 view 存进 viewArray 以便后面的操作。<br>当所有 view 都安放好了，再设置一下 content size 这样才可以进行滑动。<br>HorizontalScroller 检查一下委托是否实现了 initialViewIndex() 这个可选方法，这种检查十分必要，因为这个委托方法是可选的，如果委托没有实现这个方法则用0作为默认值。最终设置 scroll view 将初始的 view 放置到居中的位置。<br>当数据发生改变的时候，我们需要调用 reload 方法。当 HorizontalScroller 被加到其他页面的时候也需要调用这个方法，我们在 HorizontalScroller.swift 里面加入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func didMoveToSuperview() &#123;</span><br><span class="line">    reload()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在当前 view 添加到其他 view 里的时候就会自动调用 didMoveToSuperview 方法，这样可以在正确的时间重新加载数据。</p>
<p>HorizontalScroller 的最后一部分是用来确保当前浏览的内容时刻位于正中心的位置，为了实现这个功能我们需要在用户滑动结束的时候做一些额外的计算和修正。</p>
<p>添加下面这个方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func centerCurrentView() &#123;</span><br><span class="line">    var xFinal = scroller.contentOffset.x + CGFloat((VIEWS_OFFSET/2) + VIEW_PADDING)</span><br><span class="line">    let viewIndex = xFinal / CGFloat((VIEW_DIMENSIONS + (2*VIEW_PADDING)))</span><br><span class="line">    xFinal = viewIndex * CGFloat(VIEW_DIMENSIONS + (2*VIEW_PADDING))</span><br><span class="line">    scroller.setContentOffset(CGPointMake(xFinal, 0), animated: true)</span><br><span class="line">    if let delegate = self.delegate &#123;</span><br><span class="line">        delegate.horizontalScrollerClickedViewAtIndex(self, index: Int(viewIndex))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码计算了当前视图里中心位置距离多少，然后算出正确的居中坐标并滑动到那个位置。最后一行是通知委托所选视图已经发生了改变。</p>
<p>为了检测到用户滑动的结束时间，我们还需要实现 UIScrollViewDelegate 的方法。在文件结尾加上下面这个扩展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension HorizontalScroller: UIScrollViewDelegate &#123;</span><br><span class="line">    func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123;</span><br><span class="line">        if !decelerate &#123;</span><br><span class="line">            centerCurrentView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123;</span><br><span class="line">        centerCurrentView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当用户停止滑动的时候，scrollViewDidEndDragging(_:willDecelerate:) 这个方法会通知委托。如果滑动还没有停止，decelerate 的值为 true 。当滑动完全结束的时候，则会调用 scrollViewDidEndDecelerating 这个方法。在这两种情况下，你都应该把当前的视图居中，因为用户的操作可能会改变当前视图。</p>
<p>你的 HorizontalScroller 已经可以使用了！回头看看前面写的代码，你会看到我们并没有涉及什么 Album 或者 AlbumView 的代码。这是极好的，因为这样意味着这个 scroller 是完全独立的，可以复用。</p>
<p>运行一下你的项目，确保编译通过。</p>
<p>这样，我们的 HorizontalScroller 就完成了，接下来我们就要把它应用到我们的项目里了。首先，打开 Main.Sstoryboard 文件，点击上面的灰色矩形，设置 Class 为 HorizontalScroller ：</p>
<p>接下来，在 assistant editor 模式下向 ViewController.swift 拖拽生成 outlet ，命名为 scroller ：</p>
<p>接下来打开 ViewController.swift 文件，是时候实现 HorizontalScrollerDelegate 委托里的方法啦！</p>
<p>添加如下扩展：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension ViewController: HorizontalScrollerDelegate &#123;</span><br><span class="line">    func horizontalScrollerClickedViewAtIndex(scroller: HorizontalScroller, index: Int) &#123;</span><br><span class="line">        //1</span><br><span class="line">        let previousAlbumView = scroller.viewAtIndex(currentAlbumIndex) as AlbumView</span><br><span class="line">        previousAlbumView.highlightAlbum(didHighlightView: false)</span><br><span class="line">        //2</span><br><span class="line">        currentAlbumIndex = index</span><br><span class="line">        //3</span><br><span class="line">        let albumView = scroller.viewAtIndex(index) as AlbumView</span><br><span class="line">        albumView.highlightAlbum(didHighlightView: true)</span><br><span class="line">        //4</span><br><span class="line">        showDataForAlbum(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们一行一行的看下这个委托的实现：</p>
<p>获取上一个选中的相册，然后取消高亮<br>存储当前点击的相册封面<br>获取当前选中的相册，设置为高亮<br>在 table view 里面展示新数据<br>接下来在扩展里添加如下方法：</p>
<p>func numberOfViewsForHorizontalScroller(scroller: HorizontalScroller) -&gt; (Int) {<br>    return allAlbums.count<br>}<br>这个委托方法返回 scroll vew 里面的视图数量，因为是用来展示所有的专辑的封面，所以数目也就是专辑数目。</p>
<p>然后添加如下代码：</p>
<p>func horizontalScrollerViewAtIndex(scroller: HorizontalScroller, index: Int) -&gt; (UIView) {<br>    let album = allAlbums[index]<br>    let albumView = AlbumView(frame: CGRectMake(0, 0, 100, 100), albumCover: album.coverUrl)<br>    if currentAlbumIndex == index {<br>        albumView.highlightAlbum(didHighlightView: true)<br>    } else {<br>        albumView.highlightAlbum(didHighlightView: false)<br>    }<br>    return albumView<br>}<br>我们创建了一个新的 AlbumView ，然后检查一下是不是当前选中的专辑，如果是则设为高亮，最后返回结果。</p>
<p>是的就是这么简单！三个方法，完成了一个横向滚动的浏览视图。</p>
<p>我们还需要创建这个滚动视图并把它加到主视图里，但是在这之前，先添加如下方法：</p>
<p>func reloadScroller() {<br>    allAlbums = LibraryAPI.sharedInstance.getAlbums()<br>    if currentAlbumIndex &lt; 0 {<br>        currentAlbumIndex = 0<br>    } else if currentAlbumIndex &gt;= allAlbums.count {<br>        currentAlbumIndex = allAlbums.count - 1<br>    }<br>    scroller.reload()<br>    showDataForAlbum(currentAlbumIndex)<br>}<br>这个方法通过 LibraryAPI 加载专辑数据，然后根据 currentAlbumIndex 的值设置当前视图。在设置之前先进行了校正，如果小于0则设置第一个专辑为展示的视图，如果超出了范围则设置最后一个专辑为展示的视图。</p>
<p>接下来只需要指定委托就可以了，在 viewDidLoad 最后加入一下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scroller.delegate = self</span><br><span class="line">reloadScroller()</span><br></pre></td></tr></table></figure></p>
<p>因为 HorizontalScroller 是在 StoryBoard 里初始化的，所以我们需要做的只是指定委托，然后调用 reloadScroller() 方法，从而加载所有的子视图并且展示专辑数据。</p>
<p>标注：如果协议里的方法过多，可以考虑把它分解成几个更小的协议。UITableViewDelegate 和 UITableViewDataSource 就是很好的例子，它们都是 UITableView 的协议。尝试去设计你自己的协议，让每个协议都单独负责一部分功能。</p>
<p>运行一下当前项目，看一下我们的新页面：<br><img src="http://wiki.jikexueyuan.com/project/ios-design-patterns-in-swift/images/7.png" alt=""><br>等下，滚动视图显示出来了，但是专辑的封面怎么不见了？</p>
<p>啊哈，是的。我们还没完成下载部分的代码，我们需要添加下载图片的方法。因为我们所有的访问都是通过 LibraryAPI 实现的，所以很显然我们下一步应该去完善这个类了。不过在这之前，我们还需要考虑一些问题：</p>
<p>AlbumView 不应该直接和 LibraryAPI 交互，我们不应该把视图的逻辑和业务逻辑混在一起。<br>同样， LibraryAPI 也不应该知道 AlbumView 这个类。<br>如果 AlbumView 要展示封面，LibraryAPI 需要告诉 AlbumView 图片下载完成。<br>看起来好像很难的样子？别绝望，接下来我们会用观察者模式 (Observer Pattern) 解决这个问题！</p>
<p>###观察者模式 - Observer</p>
<p>在观察者模式里，一个对象在状态变化的时候会通知另一个对象。参与者并不需要知道其他对象的具体是干什么的 - 这是一种降低耦合度的设计。这个设计模式常用于在某个属性改变的时候通知关注该属性的对象。</p>
<p>常见的使用方法是观察者注册监听，然后再状态改变的时候，所有观察者们都会收到通知。</p>
<p>在 MVC 里，观察者模式意味着需要允许 Model 对象和 View 对象进行交流，而不能有直接的关联。</p>
<p>Cocoa 使用两种方式实现了观察者模式： Notification 和 Key-Value Observing (KVO)。</p>
<p>通知 - Notification<br>不要把这里的通知和推送通知或者本地通知搞混了，这里的通知是基于订阅-发布模型的，即一个对象 (发布者) 向其他对象 (订阅者) 发送消息。发布者永远不需要知道订阅者的任何数据。</p>
<p>Apple 对于通知的使用很频繁，比如当键盘弹出或者收起的时候，系统会分别发送 UIKeyboardWillShowNotification/UIKeyboardWillHideNotification 的通知。当你的应用切到后台的时候，又会发送 UIApplicationDidEnterBackgroundNotification 的通知。</p>
<p>注意：打开 UIApplication.swift 文件，在文件结尾你会看到二十多种系统发送的通知。</p>
<p>如何使用通知<br>打开 AlbumView.swift 然后在 init 的最后插入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().postNotificationName("BLDownloadImageNotification", object: self, userInfo: ["imageView":coverImage, "coverUrl" : albumCover])</span><br></pre></td></tr></table></figure></p>
<p>这行代码通过 NSNotificationCenter 发送了一个通知，通知信息包含了 UIImageView 和图片的下载地址。这是下载图像需要的所有数据。</p>
<p>然后在 LibraryAPI.swift 的 init 方法的 super.init() 后面加上如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector:"downloadImage:", name: "BLDownloadImageNotification", object: nil)</span><br></pre></td></tr></table></figure></p>
<p>这是等号的另一边：观察者。每当 AlbumView 发出一个 BLDownloadImageNotification 通知的时候，由于 LibraryAPI 已经注册了成为观察者，所以系统会调用 downloadImage() 方法。</p>
<p>但是，在实现 downloadImage() 之前，我们必须先在 dealloc 里取消监听。如果没有取消监听消息，消息会发送给一个已经销毁的对象，导致程序崩溃。</p>
<p>在 LibaratyAPI.swift 里加上取消订阅的代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NSNotificationCenter.defaultCenter().removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对象销毁的时候，把它从所有消息的订阅列表里去除。</p>
<p>这里还要做一件事情：我们最好把图片存储到本地，这样可以避免一次又一次下载相同的封面。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">打开 PersistencyManager.swift 添加如下代码：</span><br><span class="line"></span><br><span class="line">func saveImage(image: UIImage, filename: String) &#123;</span><br><span class="line">    let path = NSHomeDirectory().stringByAppendingString("/Documents/\(filename)")</span><br><span class="line">    let data = UIImagePNGRepresentation(image)</span><br><span class="line">    data.writeToFile(path, atomically: true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getImage(filename: String) -&gt; UIImage? &#123;</span><br><span class="line">    var error: NSError?</span><br><span class="line">    let path = NSHomeDirectory().stringByAppendingString("/Documents/\(filename)")</span><br><span class="line">    let data = NSData(contentsOfFile: path, options: .UncachedRead, error: &amp;error)</span><br><span class="line">    if let unwrappedError = error &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return UIImage(data: data!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单直接，下载的图片会存储在 Documents 目录下，如果没有检查到缓存文件， getImage() 方法则会返回 nil 。</p>
<p>然后在 LibraryAPI.swift 添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func downloadImage(notification: NSNotification) &#123;</span><br><span class="line">    //1</span><br><span class="line">    let userInfo = notification.userInfo as [String: AnyObject]</span><br><span class="line">    var imageView = userInfo["imageView"] as UIImageView?</span><br><span class="line">    let coverUrl = userInfo["coverUrl"] as NSString</span><br><span class="line"></span><br><span class="line">    //2</span><br><span class="line">    if let imageViewUnWrapped = imageView &#123;</span><br><span class="line">        imageViewUnWrapped.image = persistencyManager.getImage(coverUrl.lastPathComponent)</span><br><span class="line">        if imageViewUnWrapped.image == nil &#123;</span><br><span class="line">            //3</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), &#123; () -&gt; Void in</span><br><span class="line">                let downloadedImage = self.httpClient.downloadImage(coverUrl)</span><br><span class="line">                //4</span><br><span class="line">                dispatch_sync(dispatch_get_main_queue(), &#123; () -&gt; Void in</span><br><span class="line">                    imageViewUnWrapped.image = downloadedImage</span><br><span class="line">                    self.persistencyManager.saveImage(downloadedImage, filename: coverUrl.lastPathComponent)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拆解一下上面的代码：</p>
<p>downloadImage 通过通知调用，所以这个方法的参数就是 NSNotification 本身。 UIImageView 和 URL 都可以从其中获取到。<br>如果以前下载过，从 PersistencyManager 里获取缓存。<br>如果图片没有缓存，则通过 HTTPClient 获取。<br>如果下载完成，展示图片并用 PersistencyManager 存储到本地。<br>再回顾一下，我们使用外观模式隐藏了下载图片的复杂程度。通知的发送者并不在乎图片是如何从网上下载到本地的。</p>
<p>运行一下项目，可以看到专辑封面已经显示出来了：</p>
<p>关了应用再重新运行，注意这次没有任何延时就显示了所有的图片，因为我们已经有了本地缓存。我们甚至可以在没有网络的情况下正常使用我们的应用。不过出了问题：这个用来提示加载网络请求的小菊花怎么一直在显示！</p>
<p>我们在下载图片的时候开启了这个白色小菊花，但是在图片下载完毕的时候我们并没有停掉它。我们可以在每次下载成功的时候发送一个通知，但是我们不这样做，这次我们来用用另一个观察者模式： KVO 。</p>
<p>键值观察 - KVO<br>在 KVO 里，对象可以注册监听任何属性的变化，不管它是否持有。如果感兴趣的话，可以读一读苹果 KVO 编程指南。</p>
<p>如何使用 KVO<br>正如前面所提及的， 对象可以关注任何属性的变化。在我们的例子里，我们可以用 KVO 关注 UIImageView 的 image 属性变化。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">打开 AlbumView.swift 文件，找到 init(frame:albumCover:) 方法，在把 coverImage 添加到 subView 的代码后面添加如下代码：</span><br><span class="line"></span><br><span class="line">coverImage.addObserver(self, forKeyPath: "image", options: nil, context: nil)</span><br><span class="line">这行代码把 self (也就是当前类) 添加到了 coverImage 的 image 属性的观察者里。</span><br><span class="line"></span><br><span class="line">在销毁的时候，我们也需要取消观察。还是在 AlbumView.swift 文件里，添加如下代码：</span><br><span class="line"></span><br><span class="line">deinit &#123;</span><br><span class="line">    coverImage.removeObserver(self, forKeyPath: "image")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终添加如下方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func observeValueForKeyPath(keyPath: String, ofObject object: AnyObject, change: [NSObject : AnyObject], context: UnsafeMutablePointer<span class="tag">&lt;<span class="name">Void</span>&gt;</span>) &#123;</span><br><span class="line">    if keyPath == "image" &#123;</span><br><span class="line">        indicator.stopAnimating()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>必须在所有的观察者里实现上面的代码。在检测到属性变化的时候，系统会自动调用这个方法。在上面的代码里，我们在图片加载完成的时候把那个提示加载的小菊花去掉了。</p>
<p>再次运行项目，你会发现一切正常了：</p>
<p>注意：一定要记得移除观察者，否则如果对象已经销毁了还给它发送消息会导致应用崩溃。</p>
<p>此时你可以把玩一下当前的应用然后再关掉它，你会发现你的应用的状态并没有存储下来。最后看见的专辑并不会再下次打开应用的时候出现。</p>
<p>为了解决这个问题，我们可以使用下一种模式：备忘录模式。</p>
<h3 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 - Memento"></a>备忘录模式 - Memento</h3><p>备忘录模式捕捉并且具象化一个对象的内在状态。换句话说，它把你的对象存在了某个地方，然后在以后的某个时间再把它恢复出来，而不会打破它本身的封装性，私有数据依旧是私有数据。</p>
<p>如何使用备忘录模式<br>在 ViewController.swift 里加上下面两个方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//MARK: Memento Pattern</span><br><span class="line">func saveCurrentState() &#123;</span><br><span class="line">    // When the user leaves the app and then comes back again, he wants it to be in the exact same state</span><br><span class="line">    // he left it. In order to do this we need to save the currently displayed album.</span><br><span class="line">    // Since it's only one piece of information we can use NSUserDefaults.</span><br><span class="line">    NSUserDefaults.standardUserDefaults().setInteger(currentAlbumIndex, forKey: "currentAlbumIndex")</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func loadPreviousState() &#123;</span><br><span class="line">    currentAlbumIndex = NSUserDefaults.standardUserDefaults().integerForKey("currentAlbumIndex")</span><br><span class="line">    showDataForAlbum(currentAlbumIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>saveCurrentState 把当前相册的索引值存到 NSUserDefaults 里。NSUserDefaults 是 iOS 提供的一个标准存储方案，用于保存应用的配置信息和数据。</p>
<p>loadPreviousState 方法加载上次存储的索引值。这并不是备忘录模式的完整实现，但是已经离目标不远了。</p>
<p>接下来在 viewDidLoad 的 scroller.delegate = self 前面调用：<br>loadPreviousState()<br>这样在刚初始化的时候就加载了上次存储的状态。但是什么时候存储当前状态呢？这个时候我们可以用通知来做。在应用进入到后台的时候， iOS 会发送一个 UIApplicationDidEnterBackgroundNotification 的通知，我们可以在这个通知里调用 saveCurrentState 这个方法。是不是很方便？</p>
<p>在 viewDidLoad 的最后加上如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSNotificationCenter.defaultCenter().addObserver(self, selector:"saveCurrentState", name: UIApplicationDidEnterBackgroundNotification, object: nil)</span><br></pre></td></tr></table></figure></p>
<p>现在，当应用即将进入后台的时候，ViewController 会调用 saveCurrentState 方法自动存储当前状态。</p>
<p>当然也别忘了取消监听通知，添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line">    NSNotificationCenter.defaultCenter().removeObserver(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就确保在 ViewController 销毁的时候取消监听通知。</p>
<p>这时再运行程序，随意移到某个专辑上，然后按下 Home 键把应用切换到后台，再在 Xcode 上把 App 关闭。重新启动，会看见上次记录的专辑已经存了下来并成功还原了：</p>
<p>看起来专辑数据好像是对了，但是上面的滚动条似乎出了问题，没有居中啊！</p>
<p>这时 initialViewIndex 方法就派上用场了。由于在委托里 (也就是 ViewController ) 还没实现这个方法，所以初始化的结果总是第一张专辑。</p>
<p>为了修复这个问题，我们可以在 ViewController.swift 里添加如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func initialViewIndex(scroller: HorizontalScroller) -&gt; Int &#123;</span><br><span class="line">    return currentAlbumIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在 HorizontalScroller 可以根据 currentAlbumIndex 自动滑到相应的索引位置了。</p>
<p>再次重复上次的步骤，切到后台，关闭应用，重启，一切顺利：</p>
<p>回头看看 PersistencyManager 的 init 方法，你会发现专辑数据是我们硬编码写进去的，而且每次创建 PersistencyManager 的时候都会再创建一次专辑数据。而实际上一个比较好的方案是只创建一次，然后把专辑数据存到本地文件里。我们如何把专辑数据存到文件里呢？</p>
<p>一种方案是遍历 Album 的属性然后把它们写到一个 plist 文件里，然后如果需要的时候再重新创建 Album 对象。这并不是最好的选择，因为数据和属性不同，你的代码也就要相应的产生变化。举个例子，如果我们以后想添加 Movie 对象，它有着完全不同的属性，那么存储和读取数据又需要重写新的代码。</p>
<p>况且你也无法存储这些对象的私有属性，因为其他类是没有访问权限的。这也就是为什么 Apple 提供了 归档 的机制。</p>
<p>归档 - Archiving<br>苹果通过归档的方法来实现备忘录模式。它把对象转化成了流然后在不暴露内部属性的情况下存储数据。你可以读一读 《iOS 6 by Tutorials》 这本书的第 16 章，或者看下[苹果的归档和序列化文档][14]。</p>
<p>如何使用归档<br>首先，我们需要让 Album 实现 NSCoding 协议，声明这个类是可被归档的。打开 Album.swift 在 class 那行后面加上 NSCoding ：</p>
<p>class Album: NSObject, NSCoding {<br>然后添加如下的两个方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">required init(coder decoder: NSCoder) &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    self.title = decoder.decodeObjectForKey("title") as String?</span><br><span class="line">    self.artist = decoder.decodeObjectForKey("artist") as String?</span><br><span class="line">    self.genre = decoder.decodeObjectForKey("genre") as String?</span><br><span class="line">    self.coverUrl = decoder.decodeObjectForKey("cover_url") as String?</span><br><span class="line">    self.year = decoder.decodeObjectForKey("year") as String?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func encodeWithCoder(aCoder: NSCoder) &#123;</span><br><span class="line">    aCoder.encodeObject(title, forKey: "title")</span><br><span class="line">    aCoder.encodeObject(artist, forKey: "artist")</span><br><span class="line">    aCoder.encodeObject(genre, forKey: "genre")</span><br><span class="line">    aCoder.encodeObject(coverUrl, forKey: "cover_url")</span><br><span class="line">    aCoder.encodeObject(year, forKey: "year")</span><br><span class="line">&#125;</span><br><span class="line">encodeWithCoder 方法是 NSCoding 的一部分，在被归档的时候调用。相对的， init(coder:) 方法则是用来解档的。很简单，很强大。</span><br></pre></td></tr></table></figure></p>
<p>现在 Album 对象可以被归档了，添加一些代码来存储和加载 Album 数据。</p>
<p>在 PersistencyManager.swift 里添加如下代码：</p>
<p>func saveAlbums() {<br>    var filename = NSHomeDirectory().stringByAppendingString(“/Documents/albums.bin”)<br>    let data = NSKeyedArchiver.archivedDataWithRootObject(albums)<br>    data.writeToFile(filename, atomically: true)<br>}<br>这个方法可以用来存储专辑。 NSKeyedArchiver 把专辑数组归档到了 albums.bin 这个文件里。</p>
<p>当我们归档一个包含子对象的对象时，系统会自动递归的归档子对象，然后是子对象的子对象，这样一层层递归下去。在我们的例子里，我们归档的是 albums 因为 Array 和 Album 都是实现 NSCopying 接口的，所以数组里的对象都可以自动归档。</p>
<p>用下面的代码取代 PersistencyManager 中的 init 方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">override init() &#123;</span><br><span class="line">    super.init()</span><br><span class="line">    if let data = NSData(contentsOfFile: NSHomeDirectory().stringByAppendingString("/Documents/albums.bin")) &#123;</span><br><span class="line">        let unarchiveAlbums = NSKeyedUnarchiver.unarchiveObjectWithData(data) as [Album]?</span><br><span class="line">        if let unwrappedAlbum = unarchiveAlbums &#123;</span><br><span class="line">            albums = unwrappedAlbum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createPlaceholderAlbum()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createPlaceholderAlbum() &#123;</span><br><span class="line">    //Dummy list of albums</span><br><span class="line">    let album1 = Album(title: "Best of Bowie",</span><br><span class="line">             artist: "David Bowie",</span><br><span class="line">             genre: "Pop",</span><br><span class="line">             coverUrl: "http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png",</span><br><span class="line">             year: "1992")</span><br><span class="line"></span><br><span class="line">    let album2 = Album(title: "It's My Life",</span><br><span class="line">           artist: "No Doubt",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png",</span><br><span class="line">           year: "2003")</span><br><span class="line"></span><br><span class="line">    let album3 = Album(title: "Nothing Like The Sun",</span><br><span class="line">               artist: "Sting",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png",</span><br><span class="line">           year: "1999")</span><br><span class="line"></span><br><span class="line">    let album4 = Album(title: "Staring at the Sun",</span><br><span class="line">           artist: "U2",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png",</span><br><span class="line">           year: "2000")</span><br><span class="line"></span><br><span class="line">    let album5 = Album(title: "American Pie",</span><br><span class="line">           artist: "Madonna",</span><br><span class="line">           genre: "Pop",</span><br><span class="line">           coverUrl: "http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png",</span><br><span class="line">           year: "2000")</span><br><span class="line">    albums = [album1, album2, album3, album4, album5]</span><br><span class="line">    saveAlbums()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们把创建专辑数据的方法放到了 createPlaceholderAlbum 里，这样代码可读性更高。在新的代码里，如果存在归档文件， NSKeyedUnarchiver 从归档文件加载数据；否则就创建归档文件，这样下次程序启动的时候可以读取本地文件加载数据。</p>
<p>我们还想在每次程序进入后台的时候存储专辑数据。看起来现在这个功能并不是必须的，但是如果以后我们加了编辑功能，这样做还是很有必要的，那时我们肯定希望确保新的数据会同步到本地的归档文件。</p>
<p>因为我们的程序通过 LibraryAPI 来访问所有服务，所以我们需要通过 LibraryAPI 来通知 PersistencyManager 存储专辑数据。</p>
<p>在 LibraryAPI 里添加存储专辑数据的方法：</p>
<p>func saveAlbums() {<br>    persistencyManager.saveAlbums()<br>}<br>这个方法很简单，就是把 LibraryAPI 的 saveAlbums 方法传递给了 persistencyManager 的 saveAlbums 方法。</p>
<p>然后在 ViewController.swift 的 saveCurrentState 方法的最后加上：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibraryAPI.sharedInstance.saveAlbums()</span><br></pre></td></tr></table></figure></p>
<p>在 ViewController 需要存储状态的时候，上面的代码通过 LibraryAPI 归档当前的专辑数据。</p>
<p>运行一下程序，检查一下没有编译错误。</p>
<p>不幸的是似乎没什么简单的方法来检查归档是否正确完成。你可以检查一下 Documents 目录，看下是否存在归档文件。如果要查看其他数据变化的话，还需要添加编辑专辑数据的功能。</p>
<p>不过和编辑数据相比，似乎加个删除专辑的功能更好一点，如果不想要这张专辑直接删除即可。再进一步，万一误删了话，是不是还可以再加个撤销按钮？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/01/20180201Swift基础版/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/01/20180201Swift基础版/" itemprop="url">Swift基础知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-01T10:11:12+08:00">
                2018-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>
<p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，Int表示整型值； Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数据。 Swift 还提供了三个基本的集合类型，Array ，Set 和 Dictionary ，详见集合类型。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示 “那儿有一个值，并且它等于 x ” 或者 “那儿没有值” 。可选有点像在 Objective-C 中使用 nil ，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的 nil 指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<p>Swift 是一门类型安全的语言，这意味着 Swift 可以让你清楚地知道值的类型。如果你的代码需要一个 String ，类型安全会阻止你不小心传入一个 Int 。同样的，如果你的代码需要一个 String，类型安全会阻止你意外传入一个可选的 String 。类型安全可以帮助你在开发阶段尽早发现并修正错误。</p>
<p>常量和变量<br>常量和变量把一个名字（比如 maximumNumberOfLoginAttempts 或者 welcomeMessage ）和一个指定类型的值（比如数字 10 或者字符串 “Hello” ）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>
<p>声明常量和变量<br>常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>
<p>let maximumNumberOfLoginAttempts = 10<br>var currentLoginAttempt = 0<br>这两行代码可以被理解为：</p>
<p>“声明一个名字是 maximumNumberOfLoginAttempts 的新常量，并给它一个值 10 。然后，声明一个名字是 currentLoginAttempt 的变量并将它的值初始化为 0 。”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>
<p>var x = 0.0, y = 0.0, z = 0.0<br>注意：<br>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。</p>
<p>类型标注<br>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给 welcomeMessage 变量添加了类型标注，表示这个变量可以存储 String 类型的值：</p>
<p>var welcomeMessage: String<br>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：</p>
<p>“声明一个类型为 String ，名字为 welcomeMessage 的变量。”</p>
<p>“类型为 String ”的意思是“可以存储任意 String 类型的值。”</p>
<p>welcomeMessage 变量现在可以被设置成任意字符串：</p>
<p>welcomeMessage = “Hello”<br>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：</p>
<p>var red, green, blue: Double<br>注意：<br>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给 welcomeMessage 赋初始值，所以变量 welcomeMessage 的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
<p>常量和变量的命名<br>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>
<p>let π = 3.14159<br>let 你好 = “你好世界”<br>let 🐶🐮 = “dogcow”<br>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>
<p>注意：<br>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，friendlyWelcome的值从”Hello!”改为了”Bonjour!”:</p>
<p>var friendlyWelcome = “Hello!”<br>friendlyWelcome = “Bonjour!”<br>// friendlyWelcome 现在是 “Bonjour!”<br>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>
<p>let languageName = “Swift”<br>languageName = “Swift++”<br>// 这会报编译时错误 - languageName 不可改变</p>
<p>输出常量和变量<br>你可以用print(_:separator:terminator:)函数来输出当前常量或变量的值:</p>
<p>print(friendlyWelcome)<br>// 输出 “Bonjour!”<br>print(<em>:separator:terminator:) 是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，print(</em>:separator:terminator:) 将会输出内容到“console”面板上。separator 和 terminator 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 terminator 参数–例如，print(someValue, terminator:””) 。关于参数默认值的更多信息，请参考默认参数值。</p>
<p>Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<p>print(“The current value of friendlyWelcome is (friendlyWelcome)”)<br>// 输出 “The current value of friendlyWelcome is Bonjour!<br>注意：<br>字符串插值所有可用的选项，请参考字符串插值。</p>
<p>注释<br>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与 C 语言的注释非常相似。单行注释以双正斜杠（//）作为起始标记:</p>
<p>// 这是一个注释<br>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号（/<em>），终止标记为一个星号后跟随单个正斜杠（</em>/）:</p>
<p>/<em> 这是一个,<br>多行注释 </em>/<br>与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>
<p>/<em> 这是第一个多行注释的开头<br>/</em> 这是第二个被嵌套的多行注释 <em>/<br>这是第一个多行注释的结尾 </em>/<br>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<p>分号<br>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>
<p>let cat = “🐱”; print(cat)<br>// 输出 “🐱”</p>
<p>整数<br>整数就是没有小数部分的数字，比如 42 和 -23 。整数可以是 有符号（正、负、零）或者 无符号（正、零）。</p>
<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是UInt8，32位有符号整数类型是 Int32 。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>
<p>整数范围<br>你可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：</p>
<p>let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型<br>let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型<br>min 和 max 所传回值的类型，正是其所对的整数类型(如上例UInt8, 所传回的类型是UInt8)，可用在表达式中相同类型值旁。</p>
<p>Int<br>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：</p>
<p>在32位平台上，Int 和 Int32 长度相同。<br>在64位平台上，Int 和 Int64 长度相同。<br>除非你需要特定长度的整数，一般来说使用 Int 就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int 可以存储的整数范围也可以达到 -2,147,483,648 ~ 2,147,483,647 ，大多数时候这已经足够大了。</p>
<p>UInt<br>Swift 也提供了一个特殊的无符号类型 UInt，长度与当前平台的原生字长相同：</p>
<p>在32位平台上，UInt 和 UInt32 长度相同。<br>在64位平台上，UInt 和 UInt64 长度相同。<br>注意：<br>尽量不要使用UInt，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用Int，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断，请参考类型安全和类型推断。</p>
<p>浮点数<br>浮点数是有小数部分的数字，比如 3.14159 ，0.1 和 -273.15。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<p>Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。<br>Float表示32位浮点数。精度要求不高的话可以使用此类型。<br>注意：<br>Double精确度很高，至少有15位数字，而Float只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 Double。</p>
<p>类型安全和类型推断<br>Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如 42 和 3.14159 。）</p>
<p>例如，如果你给一个新常量赋值 42 并且没有标明类型，Swift 可以推断出常量类型是 Int ，因为你给它赋的初始值看起来像一个整数：</p>
<p>let meaningOfLife = 42<br>// meaningOfLife 会被推测为 Int 类型<br>同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是 Double：</p>
<p>let pi = 3.14159<br>// pi 会被推测为 Double 类型<br>当推断浮点数的类型时，Swift 总是会选择 Double 而不是Float。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型：</p>
<p>let anotherPi = 3 + 0.14159<br>// anotherPi 会被推测为 Double 类型<br>原始值 3 没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为 Double 类型。</p>
<p>数值型字面量<br>整数字面量可以被写作：</p>
<p>一个十进制数，没有前缀<br>一个二进制数，前缀是0b<br>一个八进制数，前缀是0o<br>一个十六进制数，前缀是0x<br>下面的所有整数字面量的十进制值都是17:</p>
<p>let decimalInteger = 17<br>let binaryInteger = 0b10001       // 二进制的17<br>let octalInteger = 0o21           // 八进制的17<br>let hexadecimalInteger = 0x11     // 十六进制的17<br>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 0x ）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 e 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 p 来指定。</p>
<p>如果一个十进制数的指数为 exp，那这个数相当于基数和10^exp的乘积：</p>
<p>1.25e2 表示 1.25 × 10^2，等于 125.0。<br>1.25e-2 表示 1.25 × 10^-2，等于 0.0125。<br>如果一个十六进制数的指数为exp，那这个数相当于基数和2^exp的乘积：</p>
<p>0xFp2 表示 15 × 2^2，等于 60.0。<br>0xFp-2 表示 15 × 2^-2，等于 3.75。<br>下面的这些浮点字面量都等于十进制的12.1875：</p>
<p>let decimalDouble = 12.1875<br>let exponentDouble = 1.21875e1<br>let hexadecimalDouble = 0xC.3p0<br>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<p>let paddedDouble = 000123.456<br>let oneMillion = 1_000_000<br>let justOverOneMillion = 1_000_000.000_000_1</p>
<p>数值型类型转换<br>通常来讲，即使代码中的整数常量和变量已知非负，也请使用Int类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。</p>
<p>只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>
<p>整数转换<br>不同整数类型的变量和常量可以存储不同范围的数字。Int8类型的常量或者变量可以存储的数字范围是-128~127，而UInt8类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>
<p>let cannotBeNegative: UInt8 = -1<br>// UInt8 类型不能存储负数，所以会报错<br>let tooBig: Int8 = Int8.max + 1<br>// Int8 类型不能存储超过最大值的数，所以会报错<br>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量twoThousand是UInt16类型，然而常量one是UInt8类型。它们不能直接相加，因为它们类型不同。所以要调用UInt16(one)来创建一个新的UInt16数字并用one的值来初始化，然后使用这个新数字来计算：</p>
<p>let twoThousand: UInt16 = 2_000<br>let one: UInt8 = 1<br>let twoThousandAndOne = twoThousand + UInt16(one)<br>现在两个数字的类型都是 UInt16，可以进行相加。目标常量 twoThousandAndOne 的类型被推断为 UInt16，因为它是两个 UInt16 值的和。</p>
<p>SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，UInt16 有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16。注意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考扩展。</p>
<p>整数和浮点数转换<br>整数和浮点数的转换必须显式指定类型：</p>
<p>let three = 3<br>let pointOneFourOneFiveNine = 0.14159<br>let pi = Double(three) + pointOneFourOneFiveNine<br>// pi 等于 3.14159，所以被推测为 Double 类型<br>这个例子中，常量 three 的值被用来创建一个 Double 类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用 Double 或者 Float 类型来初始化：</p>
<p>let integerPi = Int(pi)<br>// integerPi 等于 3，所以被推测为 Int 类型<br>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 4.75 会变成 4，-3.9 会变成 -3。</p>
<p>注意：<br>结合数字类常量和变量不同于结合数字类字面量。字面量3可以直接和字面量0.14159相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
<p>类型别名<br>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>
<p>typealias AudioSample = UInt16<br>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<p>var maxAmplitudeFound = AudioSample.min<br>// maxAmplitudeFound 现在是 0<br>本例中，AudioSample被定义为UInt16的一个别名。因为它是别名，AudioSample.min实际上是UInt16.min，所以会给maxAmplitudeFound赋一个初值0。</p>
<p>布尔值<br>Swift 有一个基本的布尔（Boolean）类型，叫做Bool。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false：</p>
<p>let orangesAreOrange = true<br>let turnipsAreDelicious = false<br>orangesAreOrange 和 turnipsAreDelicious 的类型会被推断为 Bool，因为它们的初值是布尔字面量。就像之前提到的 Int 和 Double 一样，如果你创建变量的时候给它们赋值 true 或者 false，那你不需要将常量或者变量声明为 Bool 类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如 if 语句的时候，布尔值非常有用：</p>
<p>if turnipsAreDelicious {<br>    print(“Mmm, tasty turnips!”)<br>} else {<br>    print(“Eww, turnips are horrible.”)<br>}<br>// 输出 “Eww, turnips are horrible.”<br>条件语句，例如if，请参考控制流。</p>
<p>如果你在需要使用 Bool 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>
<p>let i = 1<br>if i {<br>    // 这个例子不会通过编译，会报错<br>}<br>然而，下面的例子是合法的：</p>
<p>let i = 1<br>if i == 1 {<br>    // 这个例子会编译成功<br>}<br>i == 1 的比较结果是 Bool 类型，所以第二个例子可以通过类型检查。类似 i == 1 这样的比较，请参考基本操作符。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>
<p>元组<br>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，(404, “Not Found”) 是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个 404 Not Found 状态码。</p>
<p>let http404Error = (404, “Not Found”)<br>// http404Error 的类型是 (Int, String)，值是 (404, “Not Found”)<br>(404, “Not Found”) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 (Int, Int, Int) 或者 (String, Bool) 或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<p>let (statusCode, statusMessage) = http404Error<br>print(“The status code is (statusCode)”)<br>// 输出 “The status code is 404”<br>print(“The status message is (statusMessage)”)<br>// 输出 “The status message is Not Found”<br>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：</p>
<p>let (justTheStatusCode, _) = http404Error<br>print(“The status code is (justTheStatusCode)”)<br>// 输出 “The status code is 404”<br>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<p>print(“The status code is (http404Error.0)”)<br>// 输出 “The status code is 404”<br>print(“The status message is (http404Error.1)”)<br>// 输出 “The status message is Not Found”<br>你可以在定义元组的时候给单个元素命名：</p>
<p>let http200Status = (statusCode: 200, description: “OK”)<br>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<p>print(“The status code is (http200Status.statusCode)”)<br>// 输出 “The status code is 200”<br>print(“The status message is (http200Status.description)”)<br>// 输出 “The status message is OK”<br>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 (Int, String) 元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考函数参数与返回值。</p>
<p>注意：<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考类和结构体。</p>
<p>可选类型<br>使用可选类型（optionals）来处理值可能缺失的情况。可选类型表示：</p>
<p>有值，等于 x<br>或者</p>
<p>没有值<br>注意：<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回nil，nil表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如NSNotFound）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示任意类型的值缺失，并不需要一个特殊值。</p>
<p>来看一个例子。Swift 的 Int 类型有一种构造器，作用是将一个 String 值转换成一个 Int 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 “123” 可以被转换成数字 123 ，但是字符串 “hello, world” 不行。</p>
<p>下面的例子使用这种构造器来尝试将一个 String 转换成 Int：</p>
<p>let possibleNumber = “123”<br>let convertedNumber = Int(possibleNumber)<br>// convertedNumber 被推测为类型 “Int?”， 或者类型 “optional Int”<br>因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。一个可选的 Int 被写作 Int? 而不是 Int。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。（不能包含其他任何值比如 Bool 值或者 String 值。只能是 Int 或者什么都没有。）</p>
<p>nil<br>你可以给可选变量赋值为nil来表示它没有值：</p>
<p>var serverResponseCode: Int? = 404<br>// serverResponseCode 包含一个可选的 Int 值 404<br>serverResponseCode = nil<br>// serverResponseCode 现在不包含值<br>注意：<br>nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：</p>
<p>var surveyAnswer: String?<br>// surveyAnswer 被自动设置为 nil<br>注意：<br>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p>
<p>if 语句以及强制解析<br>你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。你可以使用“相等”(==)或“不等”(!=)来执行比较。</p>
<p>如果可选类型有值，它将不等于 nil：</p>
<p>if convertedNumber != nil {<br>    print(“convertedNumber contains some integer value.”)<br>}<br>// 输出 “convertedNumber contains some integer value.”<br>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：</p>
<p>if convertedNumber != nil {<br>    print(“convertedNumber has an integer value of (convertedNumber!).”)<br>}<br>// 输出 “convertedNumber has an integer value of 123.”<br>更多关于 if 语句的内容，请参考控制流。</p>
<p>注意：<br>使用 ! 来获取一个不存在的可选值会导致运行时错误。使用 ! 来强制解析值之前，一定要确定可选包含一个非 nil 的值。</p>
<p>可选绑定<br>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。if 和 while 语句，请参考控制流。</p>
<p>像下面这样在 if 语句中写一个可选绑定：</p>
<p>if let constantName = someOptional {<br>    statements<br>}<br>你可以像上面这样使用可选绑定来重写 possibleNumber 这个例子：</p>
<p>if let actualNumber = Int(possibleNumber) {<br>    print(“\’(possibleNumber)\’ has an integer value of (actualNumber)”)<br>} else {<br>    print(“\’(possibleNumber)\’ could not be converted to an integer”)<br>}<br>// 输出 “‘123’ has an integer value of 123”<br>这段代码可以被理解为：</p>
<p>“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作 actualNumber 的值，你可以改成 if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为nil，或者任意一个布尔条件为false，则整个if条件判断为false，这时你就需要使用嵌套 if 条件语句来处理，如下所示：</p>
<p>if let firstNumber = Int(“4”), let secondNumber = Int(“42”), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>    print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>}<br>// 输出 “4 &lt; 42 &lt; 100”</p>
<p>if let firstNumber = Int(“4”) {<br>    if let secondNumber = Int(“42”) {<br>        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {<br>            print(“(firstNumber) &lt; (secondNumber) &lt; 100”)<br>        }<br>    }<br>}<br>// 输出 “4 &lt; 42 &lt; 100”<br>注意： 在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的句中(body)中才能获取到值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取到值，请参考提前退出。</p>
<p>隐式解析可选类型<br>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型_总会_有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，请参考无主引用以及隐式解析可选属性。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：</p>
<p>let possibleString: String? = “An optional string.”<br>let forcedString: String = possibleString! // 需要感叹号来获取值</p>
<p>let assumedString: String! = “An implicitly unwrapped optional string.”<br>let implicitString: String = assumedString  // 不需要感叹号<br>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<p>注意：<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
<p>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
<p>if assumedString != nil {<br>    print(assumedString)<br>}<br>// 输出 “An implicitly unwrapped optional string.”<br>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<p>if let definiteString = assumedString {<br>    print(definiteString)<br>}<br>// 输出 “An implicitly unwrapped optional string.”<br>注意：<br>如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>
<p>错误处理<br>你可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。</p>
<p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p>
<p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<p>func canThrowAnError() throws {<br>    // 这个函数有可能抛出错误<br>}<br>一个函数可以通过在声明中添加throws关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置try关键词。</p>
<p>do {<br>    try canThrowAnError()<br>    // 没有错误消息抛出<br>} catch {<br>    // 有一个错误消息抛出<br>}<br>一个do语句创建了一个新的包含作用域,使得错误能被传播到一个或多个catch从句。</p>
<p>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<p>func makeASandwich() throws {<br>    // …<br>}</p>
<p>do {<br>    try makeASandwich()<br>    eatASandwich()<br>} catch SandwichError.outOfCleanDishes {<br>    washDishes()<br>} catch SandwichError.missingIngredients(let ingredients) {<br>    buyGroceries(ingredients)<br>}<br>在此例中，makeASandwich()（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为 makeASandwich() 抛出错误，函数调用被包裹在 try 表达式中。将函数包裹在一个 do 语句中，任何被抛出的错误会被传播到提供的 catch 从句中。</p>
<p>如果没有错误被抛出，eatASandwich() 函数会被调用。如果一个匹配 SandwichError.outOfCleanDishes 的错误被抛出，washDishes() 函数会被调用。如果一个匹配 SandwichError.missingIngredients 的错误被抛出，buyGroceries(_:) 函数会被调用，并且使用 catch 所捕捉到的关联值 [String] 作为参数。</p>
<p>抛出，捕捉，以及传播错误会在错误处理章节详细说明。</p>
<p>断言和先决条件<br>断言和先决条件是在运行时所做的检查。你可以用他们来检查在执行后续代码之前是否一个必要的条件已经被满足了。如果断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。如果布尔条件评估结果为false（假），程序的当前状态是无效的，则代码执行结束，应用程序中止。</p>
<p>你使用断言和先决条件来表达你所做的假设和你在编码时候的期望。你可以将这些包含在你的代码中。断言帮助你在开发阶段找到错误和不正确的假设，先决条件帮助你在生产环境中探测到存在的问题。</p>
<p>除了在运行时验证你的期望值，断言和先决条件也变成了一个在你的代码中的有用的文档形式。和在上面讨论过的错误处理不同，断言和先决条件并不是用来处理可以恢复的或者可预期的错误。因为一个断言失败表明了程序正处于一个无效的状态，没有办法去捕获一个失败的断言。</p>
<p>使用断言和先决条件不是一个能够避免出现程序出现无效状态的编码方法。然而，如果一个无效状态程序产生了，断言和先决条件可以强制检查你的数据和程序状态，使得你的程序可预测的中止（译者：不是系统强制的，被动的中止），并帮助使这个问题更容易调试。一旦探测到无效的状态，执行则被中止，防止无效的状态导致的进一步对于系统的伤害。</p>
<p>断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。</p>
<p>使用断言进行调试<br>你可以调用 Swift 标准库的 assert(_:_:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>
<p>let age = -3<br>assert(age &gt;= 0, “A person’s age cannot be less than zero”)<br>// 因为 age &lt; 0，所以断言会触发<br>在这个例子中，只有 age &gt;= 0 为 true 时，即 age 的值非负的时候，代码才会继续执行。如果 age 的值是负数，就像代码中那样，age &gt;= 0 为 false，断言被触发，终止应用。</p>
<p>如果不需要断言信息，可以就像这样忽略掉：</p>
<p>assert(age &gt;= 0)<br>如果代码已经检查了条件，你可以使用 assertionFailure(_:file:line:)函数来表明断言失败了，例如：</p>
<p>if age &gt; 10 {<br>    print(“You can ride the roller-coaster or the ferris wheel.”)<br>} else if age &gt; 0 {<br>    print(“You can ride the ferris wheel.”)<br>} else {<br>    assertionFailure(“A person’s age can’t be less than zero.”)<br>}<br>强制执行先决条件<br>当一个条件可能为false（假），但是继续执行代码要求条件必须为true（真）的时候，需要使用先决条件。例如使用先决条件来检查是否下标越界，或者来检查是否将一个正确的参数传给函数。</p>
<p>你可以使用全局 precondition(_:_:file:line:) 函数来写一个先决条件。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>
<p>// 在一个下标的实现里…<br>precondition(index &gt; 0, “Index must be greater than zero.”)<br>你可以调用　precondition(_:_:file:line:)方法来表明出现了一个错误，例如，switch 进入了 default 分支，但是所有的有效值应该被任意一个其他分支（非 default 分支）处理。</p>
<p>注意：<br>如果你使用unchecked模式（-Ounchecked）编译代码，先决条件将不会进行检查。编译器假设所有的先决条件总是为true（真），他将优化你的代码。然而，fatalError(<em>:file:line:)函数总是中断执行，无论你怎么进行优化设定。<br>你能使用 fatalError(</em>:file:line:)函数在设计原型和早期开发阶段，这个阶段只有方法的声明，但是没有具体实现，你可以在方法体中写上fatalError(“Unimplemented”)作为具体实现。因为fatalError不会像断言和先决条件那样被优化掉，所以你可以确保当代码执行到一个没有被实现的方法时，程序会被中断。</p>
<p>运算符是检查、改变、合并值的特殊符号或短语。例如，加号（+）将两个数相加（如 let i = 1 + 2）。更复杂的运算例子包括逻辑与运算符 &amp;&amp;（如 if enteredDoorCode &amp;&amp; passedRetinaScan）。</p>
<p>Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如：赋值符（=）不返回值，以防止把想要判断相等运算符（==）的地方写成赋值符导致的错误。算术运算符（+，-，*，/，%等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见溢出运算符。</p>
<p>Swift 还提供了 C 语言没有的区间运算符，例如 a..&lt;b 或 a…b，这方便我们表达一个区间内的数值。</p>
<p>本章节只描述了 Swift 中的基本运算符，高级运算符这章会包含 Swift 中的高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>
<p>术语<br>运算符分为一元、二元和三元运算符:</p>
<p>一元运算符对单一操作对象操作（如 -a）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如 !b），后置运算符需紧跟在操作对象之后（如 c!）。<br>二元运算符操作两个操作对象（如 2 + 3），是中置的，因为它们出现在两个操作对象之间。<br>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（a ? b : c）。<br>受运算符影响的值叫操作数，在表达式 1 + 2 中，加号 + 是二元运算符，它的两个操作数是值 1 和 2。</p>
<p>赋值运算符<br>赋值运算符（a = b），表示用 b 的值来初始化或更新 a 的值：</p>
<p>let b = 10<br>var a = 5<br>a = b<br>// a 现在等于 10<br>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p>
<p>let (x, y) = (1, 2)<br>// 现在 x 等于 1，y 等于 2<br>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p>
<p>if x = y {<br>    // 此句错误, 因为 x = y 并不返回任何值<br>}<br>这个特性使你无法把（==）错写成（=），由于 if x = y 是错误代码，Swift 能帮你避免此类错误发生。</p>
<p>算术运算符<br>Swift 中所有数值类型都支持了基本的四则算术运算符：</p>
<p>加法（+）<br>减法（-）<br>乘法（<em>）<br>除法（/）<br>1 + 2       // 等于 3<br>5 - 3       // 等于 2<br>2 </em> 3       // 等于 6<br>10.0 / 2.5  // 等于 4.0<br>与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如 a &amp;+ b）。详情参见溢出运算符。</p>
<p>加法运算符也可用于 String 的拼接：</p>
<p>“hello, “ + “world”  // 等于 “hello, world”<br>求余运算符<br>求余运算符（a % b）是计算 b 的多少倍刚刚好可以容入a，返回多出来的那部分（余数）。</p>
<p>注意：<br>求余运算符（%）在其他语言也叫取模运算符。但是严格说来，我们看该运算符对负数的操作结果，「求余」比「取模」更合适些。</p>
<p>我们来谈谈取余是怎么回事，计算 9 % 4，你先计算出 4 的多少倍会刚好可以容入 9 中：</p>
<p>Art/remainderInteger_2x.png</p>
<p>你可以在 9 中放入两个 4，那余数是 1（用橙色标出）。</p>
<p>在 Swift 中可以表达为：</p>
<p>9 % 4    // 等于 1<br>为了得到 a % b 的结果，% 计算了以下等式，并输出余数作为结果：</p>
<p>a = (b × 倍数) + 余数<br>当倍数取最大值的时候，就会刚好可以容入 a 中。</p>
<p>把 9 和 4 代入等式中，我们得 1：</p>
<p>9 = (4 × 2) + 1<br>同样的方法，我们来计算 -9 % 4：</p>
<p>-9 % 4   // 等于 -1<br>把 -9 和 4 代入等式，-2 是取到的最大整数：</p>
<p>-9 = (4 × -2) + -1<br>余数是 -1。</p>
<p>在对负数 b 求余时，b 的符号会被忽略。这意味着 a % b 和 a % -b 的结果是相同的。</p>
<p>一元负号运算符<br>数值的正负号可以使用前缀 -（即一元负号符）来切换：</p>
<p>let three = 3<br>let minusThree = -three       // minusThree 等于 -3<br>let plusThree = -minusThree   // plusThree 等于 3, 或 “负负3”<br>一元负号符（-）写在操作数之前，中间没有空格。</p>
<p>一元正号运算符<br>一元正号符（+）不做任何改变地返回操作数的值：</p>
<p>let minusSix = -6<br>let alsoMinusSix = +minusSix  // alsoMinusSix 等于 -6<br>虽然一元正号符什么都不会改变，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>
<p>组合赋值运算符<br>如同 C 语言，Swift 也提供把其他运算符和赋值运算（=）组合的组合赋值运算符，组合加运算（+=）是其中一个例子：</p>
<p>var a = 1<br>a += 2<br>// a 现在是 3<br>表达式 a += 2 是 a = a + 2 的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同时完成两个运算任务。</p>
<p>注意：<br>复合赋值运算没有返回值，let b = a += 2这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
<p>更多 Swift 标准库运算符的信息，请看运算符声明。 ‌</p>
<p>比较运算符（Comparison Operators）<br>所有标准 C 语言中的比较运算符都可以在 Swift 中使用：</p>
<p>等于（a == b）<br>不等于（a != b）<br>大于（a &gt; b）<br>小于（a &lt; b）<br>大于等于（a &gt;= b）<br>小于等于（a &lt;= b）<br>注意： Swift 也提供恒等（===）和不恒等（!==）这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在类与结构。</p>
<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>
<p>1 == 1   // true, 因为 1 等于 1<br>2 != 1   // true, 因为 2 不等于 1<br>2 &gt; 1    // true, 因为 2 大于 1<br>1 &lt; 2    // true, 因为 1 小于2<br>1 &gt;= 1   // true, 因为 1 大于等于 1<br>2 &lt;= 1   // false, 因为 2 并不小于等于 1<br>比较运算多用于条件语句，如if条件：</p>
<p>let name = “world”<br>if name == “world” {<br>    print(“hello, world”)<br>} else {<br>    print(“I’m sorry (name), but I don’t recognize you”)<br>}<br>// 输出 “hello, world”, 因为 <code>name</code> 就是等于 “world”<br>关于 if 语句，请看控制流。</p>
<p>如果两个元组的元素相同，且长度相同的话，元组就可以被比较。比较元组大小会按照从左到右、逐值比较的方式，直到发现有两个值不等时停止。如果所有的值都相等，那么这一对元组我们就称它们是相等的。例如：</p>
<p>(1, “zebra”) &lt; (2, “apple”)   // true，因为 1 小于 2<br>(3, “apple”) &lt; (3, “bird”)    // true，因为 3 等于 3，但是 apple 小于 bird<br>(4, “dog”) == (4, “dog”)      // true，因为 4 等于 4，dog 等于 dog<br>在上面的例子中，你可以看到，在第一行中从左到右的比较行为。因为1小于2，所以(1, “zebra”)小于(2, “apple”)，不管元组剩下的值如何。所以”zebra”大于”apple”对结果没有任何影响，因为元组的比较结果已经被第一个元素决定了。不过，当元组的第一个元素相同时候，第二个元素将会用作比较-第二行和第三行代码就发生了这样的比较。</p>
<p>当元组中的元素都可以被比较时，你也可以使用这些运算符来比较它们的大小。例如，像下面展示的代码，你可以比较两个类型为 (String, Int) 的元组，因为 Int 和 String 类型的值可以比较。相反，Bool 不能被比较，也意味着存有布尔类型的元组不能被比较。</p>
<p>(“blue”, -1) &lt; (“purple”, 1)       // 正常，比较的结果为 true<br>(“blue”, false) &lt; (“purple”, true) // 错误，因为 &lt; 不能比较布尔类型<br>注意：<br>Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，你需要自己实现比较运算符。</p>
<p>三目运算符（Ternary Conditional Operator）<br>三目运算符的特殊在于它是有三个操作数的运算符，它的形式是 问题 ? 答案 1 : 答案 2。它简洁地表达根据 问题成立与否作出二选一的操作。如果 问题 成立，返回 答案 1 的结果；反之返回 答案 2 的结果。</p>
<p>三目运算符是以下代码的缩写形式：</p>
<p>if question {<br>    answer1<br>} else {<br>    answer2<br>}<br>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出 50 点；如果没有表头，只需高出 20 点：</p>
<p>let contentHeight = 40<br>let hasHeader = true<br>let rowHeight = contentHeight + (hasHeader ? 50 : 20)<br>// rowHeight 现在是 90<br>上面的写法比下面的代码更简洁：</p>
<p>let contentHeight = 40<br>let hasHeader = true<br>var rowHeight = contentHeight<br>if hasHeader {<br>    rowHeight = rowHeight + 50<br>} else {<br>    rowHeight = rowHeight + 20<br>}<br>// rowHeight 现在是 90<br>第一段代码例子使用了三目运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将 rowHeight 定义成变量，因为它的值无需在 if 语句中改变。</p>
<p>三目运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三目运算符会使简洁的代码变的难懂。我们应避免在一个组合语句中使用多个三目运算符。</p>
<p>空合运算符（Nil Coalescing Operator）<br>空合运算符（a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认值 b。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。</p>
<p>空合运算符是对以下代码的简短表达方法：</p>
<p>a != nil ? a! : b<br>上述代码使用了三目运算符。当可选类型 a 的值不为空时，进行强制解封（a!），访问 a 中的值；反之返回默认值 b。无疑空合运算符（??）提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p>
<p>注意： 如果 a 为非空值（non-nil），那么值 b 将不会被计算。这也就是所谓的短路求值。</p>
<p>下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p>
<p>let defaultColorName = “red”<br>var userDefinedColorName: String?   //默认值为 nil</p>
<p>var colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 “red”<br>userDefinedColorName 变量被定义为一个可选的 String 类型，默认值为 nil。由于 userDefinedColorName 是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为 colorNameToUse 的变量赋予一个字符串类型初始值。 由于 userDefinedColorName 值为空，因此表达式 userDefinedColorName ?? defaultColorName 返回 defaultColorName 的值，即 red。</p>
<p>另一种情况，分配一个非空值（non-nil）给 userDefinedColorName，再次执行空合运算，运算结果为封包在 userDefaultColorName 中的值，而非默认值。</p>
<p>userDefinedColorName = “green”<br>colorNameToUse = userDefinedColorName ?? defaultColorName<br>// userDefinedColorName 非空，因此 colorNameToUse 的值为 “green”</p>
<p>区间运算符（Range Operators）<br>Swift 提供了几种方便表达一个区间的值的区间运算符。</p>
<p>闭区间运算符<br>闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。a 的值不能超过 b。 ‌ 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在 for-in 循环中：</p>
<p>for index in 1…5 {<br>    print(“(index) <em> 5 = (index </em> 5)”)<br>}<br>// 1 <em> 5 = 5<br>// 2 </em> 5 = 10<br>// 3 <em> 5 = 15<br>// 4 </em> 5 = 20<br>// 5 * 5 = 25<br>关于 for-in，请看控制流。</p>
<p>半开区间运算符<br>半开区间运算符（a..&lt;b）定义一个从 a 到 b 但不包括 b 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。</p>
<p>半开区间的实用性在于当你使用一个从 0 开始的列表（如数组）时，非常方便地从0数到列表的长度。</p>
<p>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>let count = names.count<br>for i in 0..&lt;count {<br>    print(“第 (i + 1) 个人叫 (names[i])”)<br>}<br>// 第 1 个人叫 Anna<br>// 第 2 个人叫 Alex<br>// 第 3 个人叫 Brian<br>// 第 4 个人叫 Jack<br>数组有 4 个元素，但 0..&lt;count 只数到3（最后一个元素的下标），因为它是半开区间。关于数组，请查阅数组。</p>
<p>单侧区间<br>闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间 —— 例如，一个包含了数组从索引 2 到结尾的所有值的区间。在这些情况下，你可以省略掉区间操作符一侧的值。这种区间叫做单侧区间，因为操作符只有一侧有值。例如：</p>
<p>for name in names[2…] {<br>    print(name)<br>}<br>// Brian<br>// Jack</p>
<p>for name in names[…2] {<br>    print(name)<br>}<br>// Anna<br>// Alex<br>// Brian<br>半开区间操作符也有单侧表达形式，附带上它的最终值。就像你使用区间去包含一个值，最终值并不会落在区间内。例如：</p>
<p>for name in names[..&lt;2] {<br>    print(name)<br>}<br>// Anna<br>// Alex<br>单侧区间不止可以在下标里使用，也可以在别的情境下使用。你不能遍历省略了初始值的单侧区间，因为遍历的开端并不明显。你可以遍历一个省略最终值的单侧区间；然而，由于这种区间无限延伸的特性，请保证你在循环里有一个结束循环的分支。你也可以查看一个单侧区间是否包含某个特定的值，就像下面展示的那样。</p>
<p>let range = …5<br>range.contains(7)   // false<br>range.contains(4)   // true<br>range.contains(-1)  // true</p>
<p>逻辑运算符（Logical Operators）<br>逻辑运算符的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>
<p>逻辑非（!a）<br>逻辑与（a &amp;&amp; b）<br>逻辑或（a || b）<br>逻辑非运算符<br>逻辑非运算符（!a）对一个布尔值取反，使得 true 变 false，false 变 true。</p>
<p>它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作 非 a ，例子如下：</p>
<p>let allowedEntry = false<br>if !allowedEntry {<br>    print(“ACCESS DENIED”)<br>}<br>// 输出 “ACCESS DENIED”<br>if !allowedEntry 语句可以读作「如果非 allowedEntry」，接下一行代码只有在「非 allowedEntry」为 true，即 allowEntry 为 false 时被执行。</p>
<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>
<p>逻辑与运算符<br>逻辑与运算符（a &amp;&amp; b）表达了只有 a 和 b 的值都为 true 时，整个表达式的值才会是 true。</p>
<p>只要任意一个值为 false，整个表达式的值就为 false。事实上，如果第一个值为 false，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做短路计算（short-circuit evaluation）。</p>
<p>以下例子，只有两个 Bool 值都为 true 的时候才允许进入 if：</p>
<p>let enteredDoorCode = true<br>let passedRetinaScan = false<br>if enteredDoorCode &amp;&amp; passedRetinaScan {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// 输出 “ACCESS DENIED”<br>逻辑或运算符<br>逻辑或运算符（a || b）是一个由两个连续的 | 组成的中置运算符。它表示了两个逻辑表达式的其中一个为 true，整个表达式就为 true。</p>
<p>同逻辑与运算符类似，逻辑或也是「短路计算」的，当左端的表达式为 true 时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>
<p>以下示例代码中，第一个布尔值（hasDoorKey）为 false，但第二个值（knowsOverridePassword）为 true，所以整个表达是 true，于是允许进入：</p>
<p>let hasDoorKey = false<br>let knowsOverridePassword = true<br>if hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// 输出 “Welcome!”<br>逻辑运算符组合计算<br>我们可以组合多个逻辑运算符来表达一个复合逻辑：</p>
<p>if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// 输出 “Welcome!”<br>这个例子使用了含多个 &amp;&amp; 和 || 的复合逻辑。但无论怎样，&amp;&amp; 和 || 始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>
<p>如果我们输入了正确的密码并通过了视网膜扫描，或者我们有一把有效的钥匙，又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>
<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是 false，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是 true。</p>
<p>注意： Swift 逻辑操作符 &amp;&amp; 和 || 是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。</p>
<p>使用括号来明确优先级<br>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使它看起来逻辑更明确：</p>
<p>if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {<br>    print(“Welcome!”)<br>} else {<br>    print(“ACCESS DENIED”)<br>}<br>// 输出 “Welcome!”<br>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰的地方加个括号吧！</p>
<p>字符串是例如”hello, world”，”albatross”这样的有序的Character（字符）类型的值的集合。通过String类型来表示。 一个String的内容可以用许多方式读取，包括作为一个Character值的集合。</p>
<p>Swift 的String和Character类型提供了快速和兼容 Unicode 的方式供你的代码使用。创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。 字符串连接操作只需要简单地通过+符号将两个字符串相连即可。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。你也可以在字符串内插过程中使用字符串插入常量、变量、字面量表达成更长的字符串，这样可以很容易的创建自定义的字符串值，进行展示、存储以及打印。</p>
<p>尽管语法简易，但String类型是一种快速、现代化的字符串实现。 每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式（representations）。</p>
<p>注意：<br>Swift 的String类型与 Foundation NSString类进行了无缝桥接。Foundation 也可以对String进行扩展，暴露在NSString中定义的方法。 这意味着，如果你在String中调用这些NSString的方法，将不用进行转换。<br>更多关于在 Foundation 和 Cocoa 中使用String的信息请查看 Using Swift with Cocoa and Objective-C (Swift 4)。</p>
<p>字符串字面量<br>你可以在代码里使用一段预定义的字符串值作为字符串字面量。字符串字面量是由一对双引号包裹着的具有固定顺序的字符集。</p>
<p>字符串字面量可以用于为常量和变量提供初始值：</p>
<p>let someString = “Some string literal value”<br>注意someString常量通过字符串字面量进行初始化，Swift 会推断该常量为String类型。</p>
<p>多行字符串字面量<br>如果你需要一个字符串是跨越多行的，那就使用多行字符串字面量 —— 由一对三个双引号包裹着的具有固定顺序的文本字符集：</p>
<p>let quotation = “””<br>The White Rabbit put on his spectacles.  “Where shall I begin,<br>please your Majesty?” he asked.</p>
<p>“Begin at the beginning,” the King said gravely, “and go on<br>till you come to the end; then stop.”<br>“””<br>一个多行字符串字面量包含了所有的在开启和关闭引号（”””）中的行。这个字符从开启引号(“””)之后的第一行开始，到关闭引号(“””)之前为止。这就意味着字符串开启引号之后(“””)或者结束引号(“””)之前都没有换行符号。（译者：下面两个字符串其实是一样的，虽然第二个使用了多行字符串的形式）</p>
<p>let singleLineString = “These are the same.”<br>let multilineString = “””<br>These are the same.<br>“””<br>如果你的代码中，多行字符串字面量包含换行符的话，则多行字符串字面量中也会包含换行符。如果你想换行，以便加强代码的可读性，但是你又不想在你的多行字符串字面量中出现换行符的话，你可以用在行尾写一个反斜杠()作为续行符。</p>
<p>let softWrappedQuotation = “””<br>The White Rabbit put on his spectacles.  “Where shall I begin, \<br>please your Majesty?” he asked.</p>
<p>“Begin at the beginning,” the King said gravely, “and go on \<br>till you come to the end; then stop.”<br>“””<br>为了让一个多行字符串字面量开始和结束于换行符，请将换行写在第一行和最后一行，例如：</p>
<p>let lineBreaks = “””</p>
<p>This string starts with a line break.<br>It also ends with a line break.</p>
<p>“””<br>一个多行字符串字面量能够缩进来匹配周围的代码。关闭引号(“””)之前的空白字符串告诉Swift编译器其他各行多少空白字符串需要忽略。然而，如果你在某行的前面写的空白字符串超出了关闭引号(“””)之前的空白字符串，则超出部分将被包含在多行字符串字面量中。</p>
<p>在上面的例子中，尽管整个多行字符串字面量都是缩进的（源代码缩进），第一行和最后一行没有以空白字符串开始（实际的变量值）。中间一行的缩进用空白字符串（源代码缩进）比关闭引号(“””)之前的空白字符串多，所以，它的行首将有4个空格。</p>
<p>字符串字面量的特殊字符<br>字符串字面量可以包含以下特殊字符：</p>
<p>转义字符\0(空字符)、\(反斜线)、\t(水平制表符)、\n(换行符)、\r(回车符)、\”(双引号)、\’(单引号)。<br>Unicode 标量，写成\u{n}(u为小写)，其中n为任意一到八位十六进制数且可用的 Unicode 位码。<br>下面的代码为各种特殊字符的使用示例。 wiseWords常量包含了两个双引号。 dollarSign、blackHeart和sparklingHeart常量演示了三种不同格式的 Unicode 标量：</p>
<p>let wiseWords = “\”Imagination is more important than knowledge\” - Einstein”<br>// “Imageination is more important than knowledge” - Enistein<br>let dollarSign = “\u{24}”             // $, Unicode 标量 U+0024<br>let blackHeart = “\u{2665}”           // ♥, Unicode 标量 U+2665<br>let sparklingHeart = “\u{1F496}”      // 💖, Unicode 标量 U+1F496<br>由于多行字符串字面量使用了三个双引号，而不是一个，所以你可以在多行字符串字面量里直接使用双引号（”）而不必加上转义符（\）。要在多行字符串字面量中使用 “”” 的话，就需要使用至少一个转义符（\）：</p>
<p>let threeDoubleQuotes = “””<br>Escaping the first quote \”””<br>Escaping all three quotes \”\”\”<br>“””</p>
<p>初始化空字符串<br>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的String实例：</p>
<p>var emptyString = “”               // 空字符串字面量<br>var anotherEmptyString = String()  // 初始化方法<br>// 两个字符串均为空并等价。<br>您可以通过检查其Bool类型的isEmpty属性来判断该字符串是否为空：</p>
<p>if emptyString.isEmpty {<br>    print(“Nothing to see here”)<br>}<br>// 打印输出：”Nothing to see here”</p>
<p>字符串可变性<br>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>
<p>var variableString = “Horse”<br>variableString += “ and carriage”<br>// variableString 现在为 “Horse and carriage”</p>
<p>let constantString = “Highlander”<br>constantString += “ and another Highlander”<br>// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。<br>注意：<br>在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类(NSString和NSMutableString)来指定字符串是否可以被修改。</p>
<p>字符串是值类型<br>Swift 的String类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 值类型在 结构体和枚举是值类型 中进行了详细描述。</p>
<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。 很明显无论该值来自于哪里，都是您独自拥有的。 您可以确信传递的字符串不会被修改，除非你自己去修改它。</p>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
<p>使用字符<br>您可通过for-in循环来遍历字符串，获取字符串中每一个字符的值：</p>
<p>for character in “Dog!🐶” {<br>    print(character)<br>}<br>// D<br>// o<br>// g<br>// !<br>// 🐶<br>for-in循环在 For 循环 中进行了详细描述。</p>
<p>另外，通过标明一个Character类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>
<p>let exclamationMark: Character = “!”<br>字符串可以通过传递一个值类型为Character的数组作为自变量来初始化：</p>
<p>let catCharacters: [Character] = [“C”, “a”, “t”, “!”, “🐱”]<br>let catString = String(catCharacters)<br>print(catString)<br>// 打印输出：”Cat!🐱”</p>
<p>连接字符串和字符<br>字符串可以通过加法运算符（+）相加在一起（或称“连接”）创建一个新的字符串：</p>
<p>let string1 = “hello”<br>let string2 = “ there”<br>var welcome = string1 + string2<br>// welcome 现在等于 “hello there”<br>您也可以通过加法赋值运算符 (+=) 将一个字符串添加到一个已经存在字符串变量上：</p>
<p>var instruction = “look over”<br>instruction += string2<br>// instruction 现在等于 “look over there”<br>您可以用append()方法将一个字符附加到一个字符串变量的尾部：</p>
<p>let exclamationMark: Character = “!”<br>welcome.append(exclamationMark)<br>// welcome 现在等于 “hello there!”<br>注意：<br>您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
<p>如果你需要使用多行字符串字面量来拼接字符串，并且你需要字符串每一行都以换行符结尾，包括最后一行：</p>
<p>let badStart = “””<br>one<br>two<br>“””<br>let end = “””<br>three<br>“””<br>print(badStart + end)<br>// 打印两行:<br>// one<br>// twothree</p>
<p>let goodStart = “””<br>one<br>two</p>
<p>“””<br>print(goodStart + end)<br>// 打印三行:<br>// one<br>// two<br>// three<br>上面的代码，把 badStart 和 end 拼接起来的字符串非我们想要的结果。因为 badStart 最后一行没有换行符，它与 end 的第一行结合到了一起。相反的，goodStart 的每一行都以换行符结尾，所以它与 end 拼接的字符串总共有三行，正如我们期望的那样。</p>
<p>字符串插值<br>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。字符串字面量和多行字符串字面量都可以使用字符串插值。 您插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中：</p>
<p>let multiplier = 3<br>let message = “(multiplier) times 2.5 is (Double(multiplier) * 2.5)”<br>// message 是 “3 times 2.5 is 7.5”<br>在上面的例子中，multiplier作为(multiplier)被插入到一个字符串常量量中。 当创建字符串执行插值计算时此占位符会被替换为multiplier实际的值。</p>
<p>multiplier的值也作为字符串中后面表达式的一部分。 该表达式计算Double(multiplier) <em> 2.5的值并将结果 (7.5) 插入到字符串中。 在这个例子中，表达式写为(Double(multiplier) </em> 2.5)并包含在字符串字面量中。</p>
<p>注意：<br>插值字符串中写在括号中的表达式不能包含非转义反斜杠 ()，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
<p>Unicode<br>Unicode是一个国际标准，用于文本的编码和表示。 它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。 Swift 的String和Character类型是完全兼容 Unicode 标准的。</p>
<p>Unicode 标量<br>Swift 的String类型是基于 Unicode 标量 建立的。 Unicode 标量是对应字符或者修饰符的唯一的21位数字，例如U+0061表示小写的拉丁字母(LATIN SMALL LETTER A)(“a”)，U+1F425表示小鸡表情(FRONT-FACING BABY CHICK) (“🐥”)。</p>
<p>注意： Unicode 码位(code poing) 的范围是U+0000到U+D7FF或者U+E000到U+10FFFF。Unicode 标量不包括 Unicode 代理项(surrogate pair) 码位，其码位范围是U+D800到U+DFFF。</p>
<p>注意不是所有的21位 Unicode 标量都代表一个字符，因为有一些标量是留作未来分配的。已经代表一个典型字符的标量都有自己的名字，例如上面例子中的LATIN SMALL LETTER A和FRONT-FACING BABY CHICK。</p>
<p>可扩展的字形群集<br>每一个 Swift 的Character类型代表一个可扩展的字形群。 一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。<br>举个例子，字母é可以用单一的 Unicode 标量é(LATIN SMALL LETTER E WITH ACUTE, 或者U+00E9)来表示。然而一个标准的字母e(LATIN SMALL LETTER E或者U+0065) 加上一个急促重音(COMBINING ACTUE ACCENT)的标量(U+0301)，这样一对标量就表示了同样的字母é。 这个急促重音的标量形象的将e转换成了é。</p>
<p>在这两种情况中，字母é代表了一个单一的 Swift 的Character值，同时代表了一个可扩展的字形群。 在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<p>let eAcute: Character = “\u{E9}”                         // é<br>let combinedEAcute: Character = “\u{65}\u{301}”          // e 后面加上  ́<br>// eAcute 是 é, combinedEAcute 是 é<br>可扩展的字符群集是一个灵活的方法，用许多复杂的脚本字符表示单一的Character值。 例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。 在 Swift 都会表示为同一个单一的Character值：</p>
<p>let precomposed: Character = “\u{D55C}”                  // 한<br>let decomposed: Character = “\u{1112}\u{1161}\u{11AB}”   // ᄒ, ᅡ, ᆫ<br>// precomposed 是 한, decomposed 是 한<br>可拓展的字符群集可以使包围记号(例如COMBINING ENCLOSING CIRCLE或者U+20DD)的标量包围其他 Unicode 标量，作为一个单一的Character值：</p>
<p>let enclosedEAcute: Character = “\u{E9}\u{20DD}”<br>// enclosedEAcute 是 é⃝<br>地域性指示符号的 Unicode 标量可以组合成一个单一的Character值，例如REGIONAL INDICATOR SYMBOL LETTER U(U+1F1FA)和REGIONAL INDICATOR SYMBOL LETTER S(U+1F1F8)：</p>
<p>let regionalIndicatorForUS: Character = “\u{1F1FA}\u{1F1F8}”<br>// regionalIndicatorForUS 是 🇺🇸</p>
<p>计算字符数量<br>如果想要获得一个字符串中Character值的数量，可以使用count属性：</p>
<p>let unusualMenagerie = “Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪”<br>print(“unusualMenagerie has (unusualMenagerie.count) characters”)<br>// 打印输出 “unusualMenagerie has 40 characters”<br>注意在 Swift 中，使用可拓展的字符群集作为Character值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
<p>例如，如果你用四个字符的单词cafe初始化一个新的字符串，然后添加一个COMBINING ACTUE ACCENT(U+0301)作为字符串的结尾。最终这个字符串的字符数量仍然是4，因为第四个字符是é，而不是e：</p>
<p>var word = “cafe”<br>print(“the number of characters in (word) is (word.count)”)<br>// 打印输出 “the number of characters in cafe is 4”</p>
<p>word += “\u{301}”    // 拼接一个重音, U+0301</p>
<p>print(“the number of characters in (word) is (word.count)”)<br>// 打印输出 “the number of characters in café is 4”<br>注意：<br>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意count属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。</p>
<p>另外需要注意的是通过count属性返回的字符数量并不总是与包含相同字符的NSString的length属性相同。NSString的length属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。</p>
<p>访问和修改字符串<br>你可以通过字符串的属性和方法来访问和修改它，当然也可以用下标语法完成。</p>
<p>字符串索引<br>每一个String值都有一个关联的索引(index)类型，String.Index，它对应着字符串中的每一个Character的位置。</p>
<p>前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道Character的确定位置，就必须从String开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数(integer)做索引。</p>
<p>使用startIndex属性可以获取一个String的第一个Character的索引。使用endIndex属性可以获取最后一个Character的后一个位置的索引。因此，endIndex属性不能作为一个字符串的有效下标。如果String是空串，startIndex和endIndex是相等的。</p>
<p>通过调用 String 的 index(before:) 或 index(after:) 方法，可以立即得到前面或后面的一个索引。您还可以通过调用 index(_:offsetBy:) 方法来获取对应偏移量的索引，这种方式可以避免多次调用 index(before:) 或 index(after:) 方法。</p>
<p>你可以使用下标语法来访问 String 特定索引的 Character。</p>
<p>let greeting = “Guten Tag!”<br>greeting[greeting.startIndex]<br>// G<br>greeting[greeting.index(before: greeting.endIndex)]<br>// !<br>greeting[greeting.index(after: greeting.startIndex)]<br>// u<br>let index = greeting.index(greeting.startIndex, offsetBy: 7)<br>greeting[index]<br>// a<br>试图获取越界索引对应的 Character，将引发一个运行时错误。</p>
<p>greeting[greeting.endIndex] // error<br>greeting.index(after: endIndex) // error<br>使用 indices 属性会创建一个包含全部索引的范围(Range)，用来在一个字符串中访问单个字符。</p>
<p>for index in greeting.indices {<br>   print(“(greeting[index]) “, terminator: “”)<br>}<br>// 打印输出 “G u t e n   T a g ! “<br>注意：<br>您可以使用 startIndex 和 endIndex 属性或者 index(before:) 、index(after:) 和 index(_:offsetBy:) 方法在任意一个确认的并遵循 Collection 协议的类型里面，如上文所示是使用在 String 中，您也可以使用在 Array、Dictionary 和 Set中。</p>
<p>插入和删除<br>调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一个段字符串。</p>
<p>var welcome = “hello”<br>welcome.insert(“!”, at: welcome.endIndex)<br>// welcome 变量现在等于 “hello!”</p>
<p>welcome.insert(contentsOf:” there”, at: welcome.index(before: welcome.endIndex))<br>// welcome 变量现在等于 “hello there!”<br>调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以在一个字符串的指定索引删除一个子字符串。</p>
<p>welcome.remove(at: welcome.index(before: welcome.endIndex))<br>// welcome 现在等于 “hello there”</p>
<p>let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex<br>welcome.removeSubrange(range)<br>// welcome 现在等于 “hello”<br>注意： 您可以使用 insert(<em>:at:)、insert(contentsOf:at:)、remove(at:) 和 removeSubrange(</em>:) 方法在任意一个确认的并遵循 RangeReplaceableCollection 协议的类型里面，如上文所示是使用在 String 中，您也可以使用在 Array、Dictionary 和 Set 中。</p>
<p>子字符串<br>当你从字符串中获取一个子字符串 —— 例如，使用下标或者 prefix(_:) 之类的方法 —— 就可以得到一个 SubString 的实例，而非另外一个 String。Swift 里的 SubString 绝大部分函数都跟 String 一样，意味着你可以使用同样的方式去操作 SubString 和 String。然而，跟 String 不同的是，你只有在短时间内需要操作字符串时，才会使用 SubString。当你需要长时间保存结果时，就把 SubString 转化为 String 的实例：</p>
<p>let greeting = “Hello, world!”<br>let index = greeting.index(of: “,”) ?? greeting.endIndex<br>let beginning = greeting[..&lt;index]<br>// beginning 的值为 “Hello”</p>
<p>// 把结果转化为 String 以便长期存储。<br>let newString = String(beginning)<br>就像 String，每一个 SubString 都会在内存里保存字符集。而 String 和 SubString 的区别在于性能优化上，SubString 可以重用原 String 的内存空间，或者另一个 SubString 的内存空间（String 也有同样的优化，但如果两个 String 共享内存的话，它们就会相等）。这一优化意味着你在修改 String 和 SubString 之前都不需要消耗性能去复制内存。就像前面说的那样，SubString 不适合长期存储 —— 因为它重用了原 String 的内存空间，原 String 的内存空间必须保留直到它的 SubString 不再被使用为止。</p>
<p>上面的例子，greeting 是一个 String，意味着它在内存里有一片空间保存字符集。而由于 beginning 是 greeting 的 SubString，它重用了 greeting 的内存空间。相反，newString 是一个 String —— 它是使用 SubString 创建的，拥有一片自己的内存空间。下面的图展示了他们之间的关系：</p>
<p>注意 String 和 SubString 都遵循 StringProtocol&lt;//apple_ref/swift/intf/s:s14StringProtocolP&gt; 协议，这意味着操作字符串的函数使用 StringProtocol 会更加方便。你可以传入 String 或 SubString 去调用函数。</p>
<p>比较字符串<br>Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p>
<p>字符串/字符相等<br>字符串/字符可以用等于操作符(==)和不等于操作符(!=)，详细描述在比较运算符：</p>
<p>let quotation = “We’re a lot alike, you and I.”<br>let sameQuotation = “We’re a lot alike, you and I.”<br>if quotation == sameQuotation {<br>    print(“These two strings are considered equal”)<br>}<br>// 打印输出 “These two strings are considered equal”<br>如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等的，那就认为它们是相等的。在这个情况下，即使可扩展的字形群集是有不同的 Unicode 标量构成的，只要它们有同样的语言意义和外观，就认为它们标准相等。</p>
<p>例如，LATIN SMALL LETTER E WITH ACUTE(U+00E9)就是标准相等于LATIN SMALL LETTER E(U+0065)后面加上COMBINING ACUTE ACCENT(U+0301)。这两个字符群集都是表示字符é的有效方式，所以它们被认为是标准相等的：</p>
<p>// “Voulez-vous un café?” 使用 LATIN SMALL LETTER E WITH ACUTE<br>let eAcuteQuestion = “Voulez-vous un caf\u{E9}?”</p>
<p>// “Voulez-vous un café?” 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT<br>let combinedEAcuteQuestion = “Voulez-vous un caf\u{65}\u{301}?”</p>
<p>if eAcuteQuestion == combinedEAcuteQuestion {<br>    print(“These two strings are considered equal”)<br>}<br>// 打印输出 “These two strings are considered equal”<br>相反，英语中的LATIN CAPITAL LETTER A(U+0041，或者A)不等于俄语中的CYRILLIC CAPITAL LETTER A(U+0410，或者A)。两个字符看着是一样的，但却有不同的语言意义：</p>
<p>let latinCapitalLetterA: Character = “\u{41}”</p>
<p>let cyrillicCapitalLetterA: Character = “\u{0410}”</p>
<p>if latinCapitalLetterA != cyrillicCapitalLetterA {<br>    print(“These two characters are not equivalent”)<br>}<br>// 打印 “These two characters are not equivalent”<br>注意：<br>在 Swift 中，字符串和字符并不区分地域(not locale-sensitive)。</p>
<p>前缀/后缀相等<br>通过调用字符串的hasPrefix(<em>:)/hasSuffix(</em>:)方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个String类型的参数，并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>
<p>let romeoAndJuliet = [<br>    “Act 1 Scene 1: Verona, A public place”,<br>    “Act 1 Scene 2: Capulet’s mansion”,<br>    “Act 1 Scene 3: A room in Capulet’s mansion”,<br>    “Act 1 Scene 4: A street outside Capulet’s mansion”,<br>    “Act 1 Scene 5: The Great Hall in Capulet’s mansion”,<br>    “Act 2 Scene 1: Outside Capulet’s mansion”,<br>    “Act 2 Scene 2: Capulet’s orchard”,<br>    “Act 2 Scene 3: Outside Friar Lawrence’s cell”,<br>    “Act 2 Scene 4: A street in Verona”,<br>    “Act 2 Scene 5: Capulet’s mansion”,<br>    “Act 2 Scene 6: Friar Lawrence’s cell”<br>]<br>您可以调用hasPrefix(_:)方法来计算话剧中第一幕的场景数：</p>
<p>var act1SceneCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasPrefix(“Act 1 “) {<br>        act1SceneCount += 1<br>    }<br>}<br>print(“There are (act1SceneCount) scenes in Act 1”)<br>// 打印输出 “There are 5 scenes in Act 1”<br>相似地，您可以用hasSuffix(_:)方法来计算发生在不同地方的场景数：</p>
<p>var mansionCount = 0<br>var cellCount = 0<br>for scene in romeoAndJuliet {<br>    if scene.hasSuffix(“Capulet’s mansion”) {<br>        mansionCount += 1<br>    } else if scene.hasSuffix(“Friar Lawrence’s cell”) {<br>        cellCount += 1<br>    }<br>}<br>print(“(mansionCount) mansion scenes; (cellCount) cell scenes”)<br>// 打印输出 “6 mansion scenes; 2 cell scenes”<br>注意：<br>hasPrefix(<em>:)和hasSuffix(</em>:)方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等，详细描述在字符串/字符相等。</p>
<p>字符串的 Unicode 表示形式<br>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式（encoding forms）编码。每一个字符串中的小块编码都被称代码单元（code units）。这些包括 UTF-8 编码格式（编码字符串为8位的代码单元）， UTF-16 编码格式（编码字符串位16位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p>
<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示形式。 您可以利用for-in来对字符串进行遍历，从而以 Unicode 可扩展的字符群集的方式访问每一个Character值。 该过程在 使用字符 中进行了描述。</p>
<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>
<p>UTF-8 代码单元集合 (利用字符串的utf8属性进行访问)<br>UTF-16 代码单元集合 (利用字符串的utf16属性进行访问)<br>21位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式 (利用字符串的unicodeScalars属性进行访问)<br>下面由D,o,g,‼(DOUBLE EXCLAMATION MARK, Unicode 标量 U+203C)和🐶(DOG FACE，Unicode 标量为U+1F436)组成的字符串中的每一个字符代表着一种不同的表示：</p>
<p>let dogString = “Dog‼🐶”</p>
<p>UTF-8 表示<br>您可以通过遍历String的utf8属性来访问它的UTF-8表示。 其为String.UTF8View类型的属性，UTF8View是无符号8位 (UInt8) 值的集合，每一个UInt8值都是一个字符的 UTF-8 表示：</p>
<p>Character    D<br>U+0044    o<br>U+006F    g<br>U+0067    ‼<br>U+203C    🐶<br>U+1F436<br>UTF-8<br>Code Unit    68    111    103    226    128    188    240    159    144    182<br>Position    0    1    2    3    4    5    6    7    8    9<br>for codeUnit in dogString.utf8 {<br>    print(“(codeUnit) “, terminator: “”)<br>}<br>print(“”)<br>// 68 111 103 226 128 188 240 159 144 182<br>上面的例子中，前三个10进制codeUnit值 (68, 111, 103) 代表了字符D、o和 g，它们的 UTF-8 表示与 ASCII 表示相同。 接下来的三个10进制codeUnit值 (226, 128, 188) 是DOUBLE EXCLAMATION MARK的3字节 UTF-8 表示。 最后的四个codeUnit值 (240, 159, 144, 182) 是DOG FACE的4字节 UTF-8 表示。</p>
<p>UTF-16 表示<br>您可以通过遍历String的utf16属性来访问它的UTF-16表示。 其为String.UTF16View类型的属性，UTF16View是无符号16位 (UInt16) 值的集合，每一个UInt16都是一个字符的 UTF-16 表示：</p>
<p>Character    D<br>U+0044    o<br>U+006F    g<br>U+0067    ‼<br>U+203C    🐶<br>U+1F436<br>UTF-16<br>Code Unit    68    111    103    8252    55357    56374<br>Position    0    1    2    3    4    5<br>for codeUnit in dogString.utf16 {<br>    print(“(codeUnit) “, terminator: “”)<br>}<br>print(“”)<br>// 68 111 103 8252 55357 56374<br>同样，前三个codeUnit值 (68, 111, 103) 代表了字符D、o和g，它们的 UTF-16 代码单元和 UTF-8 完全相同（因为这些 Unicode 标量表示 ASCII 字符）。</p>
<p>第四个codeUnit值 (8252) 是一个等于十六进制203C的的十进制值。这个代表了DOUBLE EXCLAMATION MARK字符的 Unicode 标量值U+203C。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个codeUnit值 (55357和56374) 是DOG FACE字符的 UTF-16 表示。 第一个值为U+D83D(十进制值为55357)，第二个值为U+DC36(十进制值为56374)。</p>
<p>Unicode 标量表示<br>您可以通过遍历String值的unicodeScalars属性来访问它的 Unicode 标量表示。 其为UnicodeScalarView类型的属性，UnicodeScalarView是UnicodeScalar类型的值的集合。 UnicodeScalar是21位的 Unicode 代码点。</p>
<p>每一个UnicodeScalar拥有一个value属性，可以返回对应的21位数值，用UInt32来表示：</p>
<p>Character    D<br>U+0044    o<br>U+006F    g<br>U+0067    ‼<br>U+203C    🐶<br>U+1F436<br>Unicode Scalar<br>Code Unit    68    111    103    8252    128054<br>Position    0    1    2    3    4<br>for scalar in dogString.unicodeScalars {<br>    print(“(scalar.value) “, terminator: “”)<br>}<br>print(“”)<br>// 68 111 103 8252 128054<br>前三个UnicodeScalar值(68, 111, 103)的value属性仍然代表字符D、o和g。 第四个codeUnit值(8252)仍然是一个等于十六进制203C的十进制值。这个代表了DOUBLE EXCLAMATION MARK字符的 Unicode 标量U+203C。</p>
<p>第五个UnicodeScalar值的value属性，128054，是一个十六进制1F436的十进制表示。其等同于DOG FACE的 Unicode 标量U+1F436。</p>
<p>作为查询它们的value属性的一种替代方法，每个UnicodeScalar值也可以用来构建一个新的String值，比如在字符串插值中使用：</p>
<p>for scalar in dogString.unicodeScalars {<br>    print(“(scalar) “)<br>}</p>
<p>Swift 语言提供Arrays、Sets和Dictionaries三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。</p>
<p>Swift 语言中的Arrays、Sets和Dictionaries中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。</p>
<p>注意：<br>Swift 的Arrays、Sets和Dictionaries类型被实现为泛型集合。更多关于泛型类型和集合，参见 泛型章节。</p>
<p>集合的可变性<br>如果创建一个Arrays、Sets或Dictionaries并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把Arrays、Sets或Dictionaries分配成常量，那么它就是不可变的，它的大小和内容都不能被改变。</p>
<p>注意：<br>在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。</p>
<p>数组(Arrays)<br>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p>
<p>注意: Swift 的Array类型被桥接到Foundation中的NSArray类。 更多关于在Foundation和Cocoa中使用Array的信息，参见 Using Swift with Cocoa and Obejective-C(Swift 3.0.1) 中使用 Cocoa 数据类型部分。</p>
<p>数组的简单语法<br>写 Swift 数组应该遵循像Array<element>这样的形式，其中Element是这个数组中唯一允许存在的数据类型。我们也可以使用像[Element]这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</element></p>
<p>创建一个空数组<br>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>
<p>var someInts = <a href="">Int</a><br>print(“someInts is of type [Int] with (someInts.count) items.”)<br>// 打印 “someInts is of type [Int] with 0 items.”<br>注意，通过构造函数的类型，someInts的值类型被推断为[Int]。</p>
<p>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：[]（一对空方括号）：</p>
<p>someInts.append(3)<br>// someInts 现在包含一个 Int 值<br>someInts = []<br>// someInts 现在是空数组，但是仍然是 [Int] 类型的。</p>
<p>创建一个带有默认值的数组<br>Swift 中的Array类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeating）传入数组构造函数：</p>
<p>var threeDoubles = Array(repeating: 0.0, count: 3)<br>// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</p>
<p>通过两个数组相加创建一个数组<br>我们可以使用加法操作符（+）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>
<p>var anotherThreeDoubles = Array(repeating: 2.5, count: 3)<br>// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</p>
<p>var sixDoubles = threeDoubles + anotherThreeDoubles<br>// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</p>
<p>用数组字面量构造数组<br>我们可以使用数组字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值：</p>
<p>[value 1, value 2, value 3]。</p>
<p>下面这个例子创建了一个叫做shoppingList并且存储String的数组：</p>
<p>var shoppingList: [String] = [“Eggs”, “Milk”]<br>// shoppingList 已经被构造并且拥有两个初始项。<br>shoppingList变量被声明为“字符串值类型的数组“，记作[String]。 因为这个数组被规定只有String一种数据结构，所以只有String类型可以在其中被存取。 在这里，shoppingList数组由两个String值（”Eggs” 和”Milk”）构造，并且由数组字面量定义。</p>
<p>注意：<br>shoppingList数组被声明为变量（var关键字创建）而不是常量（let创建）是因为以后可能会有更多的数据项被插入其中。</p>
<p>在这个例子中，字面量仅仅包含两个String值。匹配了该数组的变量声明（只能包含String的数组），所以这个字面量的分配过程可以作为用两个初始项来构造shoppingList的一种方式。</p>
<p>由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 shoppingList的构造也可以这样写：</p>
<p>var shoppingList = [“Eggs”, “Milk”]<br>因为所有数组字面量中的值都是相同的类型，Swift 可以推断出[String]是shoppingList中变量的正确类型。</p>
<p>访问和修改数组<br>我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。</p>
<p>可以使用数组的只读属性count来获取数组中的数据项数量：</p>
<p>print(“The shopping list contains (shoppingList.count) items.”)<br>// 输出 “The shopping list contains 2 items.”（这个数组有2个项）<br>使用布尔属性isEmpty作为一个缩写形式去检查count属性是否为0：</p>
<p>if shoppingList.isEmpty {<br>    print(“The shopping list is empty.”)<br>} else {<br>    print(“The shopping list is not empty.”)<br>}<br>// 打印 “The shopping list is not empty.”（shoppinglist 不是空的）<br>也可以使用append(_:)方法在数组后面添加新的数据项：</p>
<p>shoppingList.append(“Flour”)<br>// shoppingList 现在有3个数据项，有人在摊煎饼<br>除此之外，使用加法赋值运算符（+=）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：</p>
<p>shoppingList += [“Baking Powder”]<br>// shoppingList 现在有四项了<br>shoppingList += [“Chocolate Spread”, “Cheese”, “Butter”]<br>// shoppingList 现在有七项了<br>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>
<p>var firstItem = shoppingList[0]<br>// 第一项是 “Eggs”<br>注意：<br>第一项在数组中的索引值是0而不是1。 Swift 中的数组索引总是从零开始。</p>
<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>
<p>shoppingList[0] = “Six eggs”<br>// 其中的第一项现在是 “Six eggs” 而不是 “Eggs”<br>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把”Chocolate Spread”，”Cheese”，和”Butter”替换为”Bananas”和 “Apples”：</p>
<p>shoppingList[4…6] = [“Bananas”, “Apples”]<br>// shoppingList 现在有6项<br>注意：<br>不可以用下标访问的形式去在数组尾部添加新项。</p>
<p>调用数组的insert(_:at:)方法来在某个具体索引值之前添加数据项：</p>
<p>shoppingList.insert(“Maple Syrup”, at: 0)<br>// shoppingList 现在有7项<br>// “Maple Syrup” 现在是这个列表中的第一项<br>这次insert(_:at:)方法调用把值为”Maple Syrup”的新数据项插入列表的最开始位置，并且使用0作为索引值。</p>
<p>类似的我们可以使用remove(at:)方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：</p>
<p>let mapleSyrup = shoppingList.remove(at: 0)<br>// 索引值为0的数据项被移除<br>// shoppingList 现在只有6项，而且不包括 Maple Syrup<br>// mapleSyrup 常量的值等于被移除数据项的值 “Maple Syrup”<br>注意：<br>如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的count属性进行比较来在使用某个索引之前先检验是否有效。除了当count等于 0 时（说明这是个空数组），最大索引值一直是count - 1，因为数组都是零起索引。</p>
<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为0的数据项的值再次等于”Six eggs”：</p>
<p>firstItem = shoppingList[0]<br>// firstItem 现在等于 “Six eggs”<br>如果我们只想把数组中的最后一项移除，可以使用removeLast()方法而不是remove(at:)方法来避免我们需要获取数组的count属性。就像后者一样，前者也会返回被移除的数据项：</p>
<p>let apples = shoppingList.removeLast()<br>// 数组的最后一项被移除了<br>// shoppingList 现在只有5项，不包括 Apples<br>// apples 常量的值现在等于 “Apples” 字符串</p>
<p>数组的遍历<br>我们可以使用for-in循环来遍历所有数组中的数据项：</p>
<p>for item in shoppingList {<br>    print(item)<br>}<br>// Six eggs<br>// Milk<br>// Flour<br>// Baking Powder<br>// Bananas<br>如果我们同时需要每个数据项的值和索引值，可以使用enumerated()方法来进行数组遍历。enumerated()返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</p>
<p>for (index, value) in shoppingList. enumerated() {<br>    print(“Item (String(index + 1)): (value)”)<br>}<br>// Item 1: Six eggs<br>// Item 2: Milk<br>// Item 3: Flour<br>// Item 4: Baking Powder<br>// Item 5: Bananas<br>更多关于for-in循环的介绍请参见for 循环。</p>
<p>集合（Sets）<br>集合(Set)用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>
<p>注意：<br>Swift的Set类型被桥接到Foundation中的NSSet类。<br>关于使用Foundation和Cocoa中Set的知识，参见 Using Swift with Cocoa and Obejective-C(Swift 3.0.1) 中使用 Cocoa 数据类型部分。</p>
<p>集合类型的哈希值<br>一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是Int类型的，相等的对象哈希值必须相同，比如a==b,因此必须a.hashValue == b.hashValue。</p>
<p>Swift 的所有基本类型(比如String,Int,Double和Bool)默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值(在枚举有讲述)默认也是可哈希化的。</p>
<p>注意：<br>你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的Hashable协议。符合Hashable协议的类型需要提供一个类型为Int的可读属性hashValue。由类型的hashValue属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。</p>
<p>因为Hashable协议符合Equatable协议，所以遵循该协议的类型也必须提供一个”是否相等”运算符(==)的实现。这个Equatable协议要求任何符合==实现的实例间都是一种相等的关系。也就是说，对于a,b,c三个值来说，==的实现必须满足下面三种情况：</p>
<p>a == a(自反性)<br>a == b意味着b == a(对称性)<br>a == b &amp;&amp; b == c意味着a == c(传递性)<br>关于遵循协议的更多信息，请看协议。</p>
<p>集合类型语法<br>Swift 中的Set类型被写为Set<element>，这里的Element表示Set中允许存储的类型，和数组不同的是，集合没有等价的简化形式。</element></p>
<p>创建和构造一个空的集合<br>你可以通过构造器语法创建一个特定类型的空集合：</p>
<p>var letters = Set<character>()<br>print(“letters is of type Set<character> with (letters.count) items.”)<br>// 打印 “letters is of type Set<character> with 0 items.”<br>注意：<br>通过构造器，这里的letters变量的类型被推断为Set<character>。</character></character></character></character></p>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的Set：</p>
<p>letters.insert(“a”)<br>// letters 现在含有1个 Character 类型的值<br>letters = []<br>// letters 现在是一个空的 Set, 但是它依然是 Set<character> 类型</character></p>
<p>用数组字面量创建集合<br>你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。</p>
<p>下面的例子创建一个称之为favoriteGenres的集合来存储String类型的值：</p>
<p>var favoriteGenres: Set<string> = [“Rock”, “Classical”, “Hip hop”]<br>// favoriteGenres 被构造成含有三个初始值的集合<br>这个favoriteGenres变量被声明为“一个String值的集合”，写为Set<string>。由于这个特定的集合含有指定String类型的值，所以它只允许存储String类型值。这里的favoriteGenres变量有三个String类型的初始值(“Rock”，”Classical”和”Hip hop”)，并以数组字面量的方式出现。</string></string></p>
<p>注意：<br>favoriteGenres被声明为一个变量(拥有var标示符)而不是一个常量(拥有let标示符),因为它里面的元素将会在下面的例子中被增加或者移除。</p>
<p>一个Set类型不能从数组字面量中被单独推断出来，因此Set类型必须显式声明。然而，由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个Set并且该数组字面量中的所有元素类型相同，那么你无须写出Set的具体类型。favoriteGenres的构造形式可以采用简化的方式代替：</p>
<p>var favoriteGenres: Set = [“Rock”, “Classical”, “Hip hop”]<br>由于数组字面量中的所有元素类型相同，Swift 可以推断出Set<string>作为favoriteGenres变量的正确类型。</string></p>
<p>访问和修改一个集合<br>你可以通过Set的属性和方法来访问和修改一个Set。</p>
<p>为了找出一个Set中元素的数量，可以使用其只读属性count：</p>
<p>print(“I have (favoriteGenres.count) favorite music genres.”)<br>// 打印 “I have 3 favorite music genres.”<br>使用布尔属性isEmpty作为一个缩写形式去检查count属性是否为0：</p>
<p>if favoriteGenres.isEmpty {<br>    print(“As far as music goes, I’m not picky.”)<br>} else {<br>    print(“I have particular music preferences.”)<br>}<br>// 打印 “I have particular music preferences.”<br>你可以通过调用Set的insert(_:)方法来添加一个新元素：</p>
<p>favoriteGenres.insert(“Jazz”)<br>// favoriteGenres 现在包含4个元素<br>你可以通过调用Set的remove(_:)方法去删除一个元素，如果该值是该Set的一个元素则删除该元素并且返回被删除的元素值，否则如果该Set不包含该值，则返回nil。另外，Set中的所有元素可以通过它的removeAll()方法删除。</p>
<p>if let removedGenre = favoriteGenres.remove(“Rock”) {<br>    print(“(removedGenre)? I’m over it.”)<br>} else {<br>    print(“I never much cared for that.”)<br>}<br>// 打印 “Rock? I’m over it.”<br>使用contains(_:)方法去检查Set中是否包含一个特定的值：</p>
<p>if favoriteGenres.contains(“Funk”) {<br>    print(“I get up on the good foot.”)<br>} else {<br>    print(“It’s too funky in here.”)<br>}<br>// 打印 “It’s too funky in here.”</p>
<p>遍历一个集合<br>你可以在一个for-in循环中遍历一个Set中的所有值。</p>
<p>for genre in favoriteGenres {<br>    print(“(genre)”)<br>}<br>// Classical<br>// Jazz<br>// Hip hop<br>更多关于for-in循环的信息，参见For 循环。</p>
<p>Swift 的Set类型没有确定的顺序，为了按照特定顺序来遍历一个Set中的值可以使用sorted()方法，它将返回一个有序数组，这个数组的元素排列顺序由操作符’&lt;’对元素进行比较的结果来确定.</p>
<p>for genre in favoriteGenres.sorted() {<br>    print(“(genre)”)<br>}<br>// prints “Classical”<br>// prints “Hip hop”<br>// prints “Jazz</p>
<p>集合操作<br>你可以高效地完成Set的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。</p>
<p>基本集合操作<br>下面的插图描述了两个集合-a和b-以及通过阴影部分的区域显示集合各种操作的结果。</p>
<p>使用intersection(<em>:)方法根据两个集合中都包含的值创建的一个新的集合。<br>使用symmetricDifference(</em>:)方法根据在一个集合中但不在两个集合中的值创建一个新的集合。<br>使用union(<em>:)方法根据两个集合的值创建一个新的集合。<br>使用subtracting(</em>:)方法根据不在该集合中的值创建一个新的集合。<br>let oddDigits: Set = [1, 3, 5, 7, 9]<br>let evenDigits: Set = [0, 2, 4, 6, 8]<br>let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]</p>
<p>oddDigits.union(evenDigits).sorted()<br>// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>oddDigits. intersection(evenDigits).sorted()<br>// []<br>oddDigits.subtracting(singleDigitPrimeNumbers).sorted()<br>// [1, 9]<br>oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()<br>// [1, 2, 9]</p>
<p>集合成员关系和相等<br>下面的插图描述了三个集合-a,b和c,以及通过重叠区域表述集合间共享的元素。集合a是集合b的父集合，因为a包含了b中所有的元素，相反的，集合b是集合a的子集合，因为属于b的元素也被a包含。集合b和集合c彼此不关联，因为它们之间没有共同的元素。</p>
<p>使用“是否相等”运算符(==)来判断两个集合是否包含全部相同的值。<br>使用isSubset(of:)方法来判断一个集合中的值是否也被包含在另外一个集合中。<br>使用isSuperset(of:)方法来判断一个集合中包含另一个集合中所有的值。<br>使用isStrictSubset(of:)或者isStrictSuperset(of:)方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。<br>使用isDisjoint(with:)方法来判断两个集合是否不含有相同的值(是否没有交集)。<br>let houseAnimals: Set = [“🐶”, “🐱”]<br>let farmAnimals: Set = [“🐮”, “🐔”, “🐑”, “🐶”, “🐱”]<br>let cityAnimals: Set = [“🐦”, “🐭”]</p>
<p>houseAnimals.isSubset(of: farmAnimals)<br>// true<br>farmAnimals.isSuperset(of: houseAnimals)<br>// true<br>farmAnimals.isDisjoint(with: cityAnimals)<br>// true</p>
<p>字典<br>字典是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>
<p>注意：<br>Swift 的Dictionary类型被桥接到Foundation的NSDictionary类。<br>更多关于在Foundation和Cocoa中使用Dictionary类型的信息，参见 Using Swift with Cocoa and Obejective-C(Swift 3.0.1) 中使用 Cocoa 数据类型部分。</p>
<p>字典类型简化语法<br>Swift 的字典使用Dictionary&lt;Key, Value&gt;定义，其中Key是字典中键的数据类型，Value是字典中对应于这些键所存储值的数据类型。</p>
<p>注意：<br>一个字典的Key类型必须遵循Hashable协议，就像Set的值类型。</p>
<p>我们也可以用[Key: Value]这样简化的形式去创建一个字典类型。虽然这两种形式功能上相同，但是后者是首选，并且这本指导书涉及到字典类型时通篇采用后者。</p>
<p>创建一个空字典<br>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p>
<p>var namesOfIntegers = <a href="">Int: String</a><br>// namesOfIntegers 是一个空的 [Int: String] 字典<br>这个例子创建了一个[Int: String]类型的空字典来储存整数的英语命名。它的键是Int型，值是String型。</p>
<p>如果上下文已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作[:]（中括号中放一个冒号）：</p>
<p>namesOfIntegers[16] = “sixteen”<br>// namesOfIntegers 现在包含一个键值对<br>namesOfIntegers = [:]<br>// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</p>
<p>用字典字面量创建字典<br>我们可以使用字典字面量来构造字典，这和我们刚才介绍过的数组字面量拥有相似语法。字典字面量是一种将一个或多个键值对写作Dictionary集合的快捷途径。</p>
<p>一个键值对是一个key和一个value的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：</p>
<p>[key 1: value 1, key 2: value 2, key 3: value 3]<br>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>
<p>var airports: [String: String] = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br>airports字典被声明为一种[String: String]类型，这意味着这个字典的键和值都是String类型。</p>
<p>注意：<br>airports字典被声明为变量（用var关键字）而不是常量（let关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
<p>airports字典使用字典字面量初始化，包含两个键值对。第一对的键是YYZ，值是Toronto Pearson。第二对的键是DUB，值是Dublin。</p>
<p>这个字典语句包含了两个String: String类型的键值对。它们对应airports变量声明的类型（一个只有String键和String值的字典）所以这个字典字面量的任务是构造拥有两个初始数据项的airport字典。</p>
<p>和数组一样，我们在用字典字面量构造字典时，如果它的键和值都有各自一致的类型，那么就不必写出字典的类型。 airports字典也可以用这种简短方式定义：</p>
<p>var airports = [“YYZ”: “Toronto Pearson”, “DUB”: “Dublin”]<br>因为这个语句中所有的键和值都各自拥有相同的数据类型，Swift 可以推断出Dictionary&lt;String, String&gt;是airports字典的正确类型。</p>
<p>访问和修改字典<br>我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。</p>
<p>和数组一样，我们可以通过字典的只读属性count来获取某个字典的数据项数量：</p>
<p>print(“The dictionary of airports contains (airports.count) items.”)<br>// 打印 “The dictionary of airports contains 2 items.”（这个字典有两个数据项）<br>使用布尔属性isEmpty作为一个缩写形式去检查count属性是否为0：</p>
<p>if airports.isEmpty {<br>    print(“The airports dictionary is empty.”)<br>} else {<br>    print(“The airports dictionary is not empty.”)<br>}<br>// 打印 “The airports dictionary is not empty.”<br>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：</p>
<p>airports[“LHR”] = “London”<br>// airports 字典现在有三个数据项<br>我们也可以使用下标语法来改变特定键对应的值：</p>
<p>airports[“LHR”] = “London Heathrow”<br>// “LHR”对应的值 被改为 “London Heathrow<br>作为另一种下标方法，字典的updateValue(<em>:forKey:)方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，updateValue(</em>:forKey:)方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的，updateValue(_:forKey:)这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。</p>
<p>updateValue(_:forKey:)方法会返回对应值的类型的可选值。举例来说：对于存储String值的字典，这个函数会返回一个String?或者“可选 String”类型的值。</p>
<p>如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是nil。</p>
<p>if let oldValue = airports.updateValue(“Dublin Airport”, forKey: “DUB”) {<br>    print(“The old value for DUB was (oldValue).”)<br>}<br>// 输出 “The old value for DUB was Dublin.”<br>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回nil：</p>
<p>if let airportName = airports[“DUB”] {<br>    print(“The name of the airport is (airportName).”)<br>} else {<br>    print(“That airport is not in the airports dictionary.”)<br>}<br>// 打印 “The name of the airport is Dublin Airport.”<br>我们还可以使用下标语法来通过给某个键的对应值赋值为nil来从字典里移除一个键值对：</p>
<p>airports[“APL”] = “Apple Internation”<br>// “Apple Internation” 不是真的 APL 机场, 删除它<br>airports[“APL”] = nil<br>// APL 现在被移除了<br>此外，removeValue(forKey:)方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回nil：</p>
<p>if let removedValue = airports. removeValue(forKey: “DUB”) {<br>    print(“The removed airport’s name is (removedValue).”)<br>} else {<br>    print(“The airports dictionary does not contain a value for DUB.”)<br>}<br>// prints “The removed airport’s name is Dublin Airport.”</p>
<p>字典遍历<br>我们可以使用for-in循环来遍历某个字典中的键值对。每一个字典中的数据项都以(key, value)元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：</p>
<p>for (airportCode, airportName) in airports {<br>    print(“(airportCode): (airportName)”)<br>}<br>// YYZ: Toronto Pearson<br>// LHR: London Heathrow<br>更多关于for-in循环的信息，参见For 循环。</p>
<p>通过访问keys或者values属性，我们也可以遍历字典的键或者值：</p>
<p>for airportCode in airports.keys {<br>    print(“Airport code: (airportCode)”)<br>}<br>// Airport code: YYZ<br>// Airport code: LHR</p>
<p>for airportName in airports.values {<br>    print(“Airport name: (airportName)”)<br>}<br>// Airport name: Toronto Pearson<br>// Airport name: London Heathrow<br>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受Array实例的 API 的参数，可以直接使用keys或者values属性构造一个新数组：</p>
<p>let airportCodes = <a href="airports.keys">String</a><br>// airportCodes 是 [“YYZ”, “LHR”]</p>
<p>let airportNames = <a href="airports.values">String</a><br>// airportNames 是 [“Toronto Pearson”, “London Heathrow”]<br>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的keys或values属性使用sorted()方法。</p>
<p>Swift提供了多种流程控制结构，包括可以多次执行任务的while循环，基于特定条件选择执行不同代码分支的if、guard和switch语句，还有控制流程跳转到其他代码位置的break和continue语句。</p>
<p>Swift 还提供了for-in循环，用来更简单地遍历数组（Array），字典（Dictionary），区间（Range），字符串（String）和其他序列类型。</p>
<p>Swift 的switch语句比 C 语言中更加强大。case 还可以匹配很多不同的模式，包括范围匹配，元组（tuple）和特定类型匹配。switch语句的 case 中匹配的值可以声明为临时常量或变量，在 case 作用域内使用，也可以配合where来描述更复杂的匹配条件。</p>
<p>For-In 循环<br>你可以使用 for-in 循环来遍历一个集合中的所有元素，例如数组中的元素、范围内的数字或者字符串中的字符。</p>
<p>以下例子使用 for-in 遍历一个数组所有元素：</p>
<p>let names = [“Anna”, “Alex”, “Brian”, “Jack”]<br>for name in names {<br>    print(“Hello, (name)!”)<br>}<br>// Hello, Anna!<br>// Hello, Alex!<br>// Hello, Brian!<br>// Hello, Jack!<br>你也可以通过遍历一个字典来访问它的键值对。遍历字典时，字典的每项元素会以 (key, value) 元组的形式返回，你可以在 for-in 循环中使用显式的常量名称来解读 (key, value) 元组。下面的例子中，字典的键声明会为 animalName 常量，字典的值会声明为 legCount 常量：</p>
<p>let numberOfLegs = [“spider”: 8, “ant”: 6, “cat”: 4]<br>for (animalName, legCount) in numberOfLegs {<br>    print(“(animalName)s have (legCount) legs”)<br>}<br>// ants have 6 legs<br>// spiders have 8 legs<br>// cats have 4 legs<br>字典的内容理论上是无序的，遍历元素时的顺序是无法确定的。将元素插入字典的顺序并不会决定它们被遍历的顺序。关于数组和字典的细节，参见集合类型。</p>
<p>for-in 循环还可以使用数字范围。下面的例子用来输出乘法表的一部分内容：</p>
<p>for index in 1…5 {<br>    print(“(index) times 5 is (index * 5)”)<br>}<br>// 1 times 5 is 5<br>// 2 times 5 is 10<br>// 3 times 5 is 15<br>// 4 times 5 is 20<br>// 5 times 5 is 25<br>例子中用来进行遍历的元素是使用闭区间操作符（…）表示的从 1 到 5 的数字区间。index 被赋值为闭区间中的第一个数字（1），然后循环中的语句被执行一次。在本例中，这个循环只包含一个语句，用来输出当前 index 值所对应的乘 5 乘法表的结果。该语句执行后，index 的值被更新为闭区间中的第二个数字（2），之后 print(_:separator:terminator:) 函数会再执行一次。整个过程会进行到闭区间结尾为止。</p>
<p>上面的例子中，index 是一个每次循环遍历开始时被自动赋值的常量。这种情况下，index 在使用前不需要声明，只需要将它包含在循环的声明中，就可以对其进行隐式声明，而无需使用 let 关键字声明。</p>
<p>如果你不需要区间序列内每一项的值，你可以使用下划线（_）替代变量名来忽略这个值：</p>
<p>let base = 3<br>let power = 10<br>var answer = 1<br>for _ in 1…power {<br>    answer *= base<br>}<br>print(“(base) to the power of (power) is (answer)”)<br>// 输出 “3 to the power of 10 is 59049”<br>这个例子计算 base 这个数的 power 次幂（本例中，是 3 的 10 次幂），从 1（ 3 的 0 次幂）开始做 3 的乘法， 进行 10 次，使用 1 到 10 的闭区间循环。这个计算并不需要知道每一次循环中计数器具体的值，只需要执行了正确的循环次数即可。下划线符号 _ （替代循环中的变量）能够忽略当前值，并且不提供循环遍历时对值的访问。</p>
<p>在某些情况下，你可能不想使用闭区间，包括两个端点。想象一下，你在一个手表上绘制分钟的刻度线。总共 60 个刻度，从 0 分开始。使用半开区间运算符（..&lt;）来表示一个左闭右开的区间。有关区间的更多信息，请参阅区间运算符。</p>
<p>let minutes = 60<br>for tickMark in 0..&lt;minutes {<br>    // 每一分钟都渲染一个刻度线（60次）<br>}<br>一些用户可能在其UI中可能需要较少的刻度。他们可以每5分钟作为一个刻度。使用 stride(from:to:by:) 函数跳过不需要的标记。</p>
<p>let minuteInterval = 5<br>for tickMark in stride(from: 0, to: minutes, by: minuteInterval) {<br>    // 每5分钟渲染一个刻度线 (0, 5, 10, 15 … 45, 50, 55)<br>}<br>可以在闭区间使用 stride(from:through:by:) 起到同样作用：</p>
<p>let hours = 12<br>let hourInterval = 3<br>for tickMark in stride(from: 3, through: hours, by: hourInterval) {<br>    // 每3小时渲染一个刻度线 (3, 6, 9, 12)<br>}</p>
<p>While 循环<br>while循环会一直运行一段语句直到条件变成false。这类循环适合使用在第一次迭代前，迭代次数未知的情况下。Swift 提供两种while循环形式：</p>
<p>while循环，每次在循环开始时计算条件是否符合；<br>repeat-while循环，每次在循环结束时计算条件是否符合。</p>
<p>While<br>while循环从计算一个条件开始。如果条件为true，会重复运行一段语句，直到条件变为false。</p>
<p>下面是 while 循环的一般格式：</p>
<p>while condition {<br>    statements<br>}<br>下面的例子来玩一个叫做蛇和梯子（也叫做滑道和梯子）的小游戏：</p>
<p>image</p>
<p>游戏的规则如下：</p>
<p>游戏盘面包括 25 个方格，游戏目标是达到或者超过第 25 个方格；<br>每一轮，你通过掷一个六面体骰子来确定你移动方块的步数，移动的路线由上图中横向的虚线所示；<br>如果在某轮结束，你移动到了梯子的底部，可以顺着梯子爬上去；<br>如果在某轮结束，你移动到了蛇的头部，你会顺着蛇的身体滑下去。<br>游戏盘面可以使用一个Int数组来表达。数组的长度由一个finalSquare常量储存，用来初始化数组和检测最终胜利条件。游戏盘面由 26 个 Int 0 值初始化，而不是 25 个（由0到25，一共 26 个）：</p>
<p>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="noopener">Int</a><br>一些方格被设置成特定的值来表示有蛇或者梯子。梯子底部的方格是一个正值，使你可以向上移动，蛇头处的方格是一个负值，会让你向下移动：</p>
<p>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>3 号方格是梯子的底部，会让你向上移动到 11 号方格，我们使用board[03]等于+08（来表示11和3之间的差值）。为了对齐语句，这里使用了一元正运算符（+i）和一元负运算符（-i），并且小于 10 的数字都使用 0 补齐（这些语法的技巧不是必要的，只是为了让代码看起来更加整洁）。</p>
<p>玩家由左下角空白处编号为 0 的方格开始游戏。玩家第一次掷骰子后才会进入游戏盘面：</p>
<p>var square = 0<br>var diceRoll = 0<br>while square &lt; finalSquare {<br>    // 掷骰子<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // 根据点数移动<br>    square += diceRoll<br>    if square &lt; board.count {<br>        // 如果玩家还在棋盘上，顺着梯子爬上去或者顺着蛇滑下去<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br>本例中使用了最简单的方法来模拟掷骰子。 diceRoll的值并不是一个随机数，而是以0为初始值，之后每一次while循环，diceRoll的值增加 1 ，然后检测是否超出了最大值。当diceRoll的值等于 7 时，就超过了骰子的最大值，会被重置为1。所以diceRoll的取值顺序会一直是 1 ，2，3，4，5，6，1，2 等。</p>
<p>掷完骰子后，玩家向前移动diceRoll个方格，如果玩家移动超过了第 25 个方格，这个时候游戏将会结束，为了应对这种情况，代码会首先判断square的值是否小于board的count属性，只有小于才会在board[square]上增加square，来向前或向后移动（遇到了梯子或者蛇）。</p>
<p>注意：<br>如果没有这个检测（square &lt; board.count），board[square]可能会越界访问board数组，导致错误。</p>
<p>当本轮while循环运行完毕，会再检测循环条件是否需要再运行一次循环。如果玩家移动到或者超过第 25 个方格，循环条件结果为false，此时游戏结束。</p>
<p>while 循环比较适合本例中的这种情况，因为在 while 循环开始时，我们并不知道游戏要跑多久，只有在达成指定条件时循环才会结束。</p>
<p>Repeat-While<br>while循环的另外一种形式是repeat-while，它和while的区别是在判断循环条件之前，先执行一次循环的代码块。然后重复循环直到条件为false。</p>
<p>注意：<br>Swift语言的repeat-while循环和其他语言中的do-while循环是类似的。</p>
<p>下面是 repeat-while循环的一般格式：</p>
<p>repeat {<br>    statements<br>} while condition<br>还是蛇和梯子的游戏，使用repeat-while循环来替代while循环。finalSquare、board、square和diceRoll的值初始化同while循环时一样：</p>
<p>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="noopener">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br>repeat-while的循环版本，循环中第一步就需要去检测是否在梯子或者蛇的方块上。没有梯子会让玩家直接上到第 25 个方格，所以玩家不会通过梯子直接赢得游戏。这样在循环开始时先检测是否踩在梯子或者蛇上是安全的。</p>
<p>游戏开始时，玩家在第 0 个方格上，board[0]一直等于 0， 不会有什么影响：</p>
<p>repeat {<br>    // 顺着梯子爬上去或者顺着蛇滑下去<br>    square += board[square]<br>    // 掷骰子<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    // 根据点数移动<br>    square += diceRoll<br>} while square &lt; finalSquare<br>print(“Game over!”)<br>检测完玩家是否踩在梯子或者蛇上之后，开始掷骰子，然后玩家向前移动diceRoll个方格，本轮循环结束。</p>
<p>循环条件（while square &lt; finalSquare）和while方式相同，但是只会在循环结束后进行计算。在这个游戏中，repeat-while表现得比while循环更好。repeat-while方式会在条件判断square没有超出后直接运行square += board[square]，这种方式可以比起前面 while 循环的版本，可以省去数组越界的检查。</p>
<p>条件语句<br>根据特定的条件执行特定的代码通常是十分有用的。当错误发生时，你可能想运行额外的代码；或者，当值太大或太小时，向用户显示一条消息。要实现这些功能，你就需要使用条件语句。</p>
<p>Swift 提供两种类型的条件语句：if语句和switch语句。通常，当条件较为简单且可能的情况很少时，使用if语句。而switch语句更适用于条件较复杂、有更多排列组合的时候。并且switch在需要用到模式匹配（pattern-matching）的情况下会更有用。</p>
<p>If<br>if语句最简单的形式就是只包含一个条件，只有该条件为true时，才执行相关代码：</p>
<p>var temperatureInFahrenheit = 30<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>}<br>// 输出 “It’s very cold. Consider wearing a scarf.”<br>上面的例子会判断温度是否小于等于 32 华氏度（水的冰点）。如果是，则打印一条消息；否则，不打印任何消息，继续执行if块后面的代码。</p>
<p>当然，if语句允许二选一执行，叫做else从句。也就是当条件为false时，执行 else 语句：</p>
<p>temperatureInFahrenheit = 40<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 输出 “It’s not that cold. Wear a t-shirt.”<br>显然，这两条分支中总有一条会被执行。由于温度已升至 40 华氏度，不算太冷，没必要再围围巾。因此，else分支就被触发了。</p>
<p>你可以把多个if语句链接在一起，来实现更多分支：</p>
<p>temperatureInFahrenheit = 90<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>} else {<br>    print(“It’s not that cold. Wear a t-shirt.”)<br>}<br>// 输出 “It’s really warm. Don’t forget to wear sunscreen.”<br>在上面的例子中，额外的if语句用于判断是不是特别热。而最后的else语句被保留了下来，用于打印既不冷也不热时的消息。</p>
<p>实际上，当不需要完整判断情况的时候，最后的else语句是可选的：</p>
<p>temperatureInFahrenheit = 72<br>if temperatureInFahrenheit &lt;= 32 {<br>    print(“It’s very cold. Consider wearing a scarf.”)<br>} else if temperatureInFahrenheit &gt;= 86 {<br>    print(“It’s really warm. Don’t forget to wear sunscreen.”)<br>}<br>在这个例子中，由于既不冷也不热，所以不会触发if或else if分支，也就不会打印任何消息。</p>
<p>Switch<br>switch语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，switch语句会执行对应的代码。当有可能的情况较多时，通常用switch语句替换if语句。</p>
<p>switch语句最简单的形式就是把某个值与一个或若干个相同类型的值作比较：</p>
<p>switch some value to consider {<br>case value 1:<br>    respond to value 1<br>case value 2,<br>    value 3:<br>    respond to value 2 or 3<br>default:<br>    otherwise, do something else<br>}<br>switch语句由多个 case 构成，每个由case关键字开始。为了匹配某些更特定的值，Swift 提供了几种方法来进行更复杂的模式匹配，这些模式将在本节的稍后部分提到。</p>
<p>与if语句类似，每一个 case 都是代码执行的一条分支。switch语句会决定哪一条分支应该被执行，这个流程被称作根据给定的值切换(switching)。</p>
<p>switch语句必须是完备的。这就是说，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值的情况下，你可以使用默认（default）分支来涵盖其它所有没有对应的值，这个默认分支必须在switch语句的最后面。</p>
<p>下面的例子使用switch语句来匹配一个名为someCharacter的小写字符：</p>
<p>let someCharacter: Character = “z”<br>switch someCharacter {<br>case “a”:<br>    print(“The first letter of the alphabet”)<br>case “z”:<br>    print(“The last letter of the alphabet”)<br>default:<br>    print(“Some other character”)<br>}<br>// 输出 “The last letter of the alphabet”<br>在这个例子中，第一个 case 分支用于匹配第一个英文字母a，第二个 case 分支用于匹配最后一个字母z。 因为switch语句必须有一个case分支用于覆盖所有可能的字符，而不仅仅是所有的英文字母，所以switch语句使用default分支来匹配除了a和z外的所有值，这个分支保证了swith语句的完备性。</p>
<p>不存在隐式的贯穿<br>与 C 和 Objective-C 中的switch语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止switch语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用break语句。这使得switch语句更安全、更易用，也避免了因忘记写break语句而产生的错误。</p>
<p>注意： 虽然在Swift中break不是必须的，但你依然可以在 case 分支中的代码执行完毕前使用break跳出，详情请参见Switch 语句中的 break。</p>
<p>每一个 case 分支都必须包含至少一条语句。像下面这样书写代码是无效的，因为第一个 case 分支是空的：</p>
<p>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”: // 无效，这个分支下面没有语句<br>case “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// 这段代码会报编译错误<br>不像 C 语言里的switch语句，在 Swift 中，switch语句不会一起匹配”a”和”A”。相反的，上面的代码会引起编译期错误：case “a”: 不包含任何可执行语句——这就避免了意外地从一个 case 分支贯穿到另外一个，使得代码更安全、也更直观。</p>
<p>为了让单个case同时匹配a和A，可以将这个两个值组合成一个复合匹配，并且用逗号分开：</p>
<p>let anotherCharacter: Character = “a”<br>switch anotherCharacter {<br>case “a”, “A”:<br>    print(“The letter A”)<br>default:<br>    print(“Not the letter A”)<br>}<br>// 输出 “The letter A<br>为了可读性，符合匹配可以写成多行形式，详情请参考复合匹配</p>
<p>注意： 如果想要显式贯穿case分支，请使用fallthrough语句，详情请参考贯穿。</p>
<p>区间匹配<br>case 分支的模式也可以是一个值的区间。下面的例子展示了如何使用区间匹配来输出任意数字对应的自然语言格式：</p>
<p>let approximateCount = 62<br>let countedThings = “moons orbiting Saturn”<br>let naturalCount: String<br>switch approximateCount {<br>case 0:<br>    naturalCount = “no”<br>case 1..&lt;5:<br>    naturalCount = “a few”<br>case 5..&lt;12:<br>    naturalCount = “several”<br>case 12..&lt;100:<br>    naturalCount = “dozens of”<br>case 100..&lt;1000:<br>    naturalCount = “hundreds of”<br>default:<br>    naturalCount = “many”<br>}<br>print(“There are (naturalCount) (countedThings).”)<br>// 输出 “There are dozens of moons orbiting Saturn.”<br>在上例中，approximateCount在一个switch声明中被评估。每一个case都与之进行比较。因为approximateCount落在了 12 到 100 的区间，所以naturalCount等于”dozens of”值，并且此后的执行跳出了switch语句。</p>
<p>元组<br>我们可以使用元组在同一个switch语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（_）来匹配所有可能的值。</p>
<p>下面的例子展示了如何使用一个(Int, Int)类型的元组来分类下图中的点(x, y)：</p>
<p>let somePoint = (1, 1)<br>switch somePoint {<br>case (0, 0):<br>    print(“(somePoint) is at the origin”)<br>case (_, 0):<br>    print(“(somePoint) is on the x-axis”)<br>case (0, _):<br>    print(“(somePoint) is on the y-axis”)<br>case (-2…2, -2…2):<br>    print(“(somePoint) is inside the box”)<br>default:<br>    print(“(somePoint) is outside of the box”)<br>}<br>// 输出 “(1, 1) is inside the box”<br>image</p>
<p>在上面的例子中，switch语句会判断某个点是否是原点(0, 0)，是否在红色的x轴上，是否在橘黄色的y轴上，是否在一个以原点为中心的4x4的蓝色矩形里，或者在这个矩形外面。</p>
<p>不像 C 语言，Swift 允许多个 case 匹配同一个值。实际上，在这个例子中，点(0, 0)可以匹配所有四个 case。但是，如果存在多个匹配，那么只会执行第一个被匹配到的 case 分支。考虑点(0, 0)会首先匹配case (0, 0)，因此剩下的能够匹配的分支都会被忽视掉。</p>
<p>值绑定（Value Bindings）<br>case 分支允许将匹配的值声明为临时常量或变量，并且在case分支体内使用 —— 这种行为被称为值绑定（value binding），因为匹配的值在case分支体内，与临时的常量或变量绑定。</p>
<p>下面的例子将下图中的点(x, y)，使用(Int, Int)类型的元组表示，然后分类表示：</p>
<p>let anotherPoint = (2, 0)<br>switch anotherPoint {<br>case (let x, 0):<br>    print(“on the x-axis with an x value of (x)”)<br>case (0, let y):<br>    print(“on the y-axis with a y value of (y)”)<br>case let (x, y):<br>    print(“somewhere else at ((x), (y))”)<br>}<br>// 输出 “on the x-axis with an x value of 2”<br>image</p>
<p>在上面的例子中，switch语句会判断某个点是否在红色的x轴上，是否在橘黄色的y轴上，或者不在坐标轴上。</p>
<p>这三个 case 都声明了常量x和y的占位符，用于临时获取元组anotherPoint的一个或两个值。第一个 case ——case (let x, 0)将匹配一个纵坐标为0的点，并把这个点的横坐标赋给临时的常量x。类似的，第二个 case ——case (0, let y)将匹配一个横坐标为0的点，并把这个点的纵坐标赋给临时的常量y。</p>
<p>一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里使用。在这个例子中，它们用于打印给定点的类型。</p>
<p>请注意，这个switch语句不包含默认分支。这是因为最后一个 case ——case let(x, y)声明了一个可以匹配余下所有值的元组。这使得switch语句已经完备了，因此不需要再书写默认分支。</p>
<p>Where<br>case 分支的模式可以使用where语句来判断额外的条件。</p>
<p>下面的例子把下图中的点(x, y)进行了分类：</p>
<p>let yetAnotherPoint = (1, -1)<br>switch yetAnotherPoint {<br>case let (x, y) where x == y:<br>    print(“((x), (y)) is on the line x == y”)<br>case let (x, y) where x == -y:<br>    print(“((x), (y)) is on the line x == -y”)<br>case let (x, y):<br>    print(“((x), (y)) is just some arbitrary point”)<br>}<br>// 输出 “(1, -1) is on the line x == -y”<br>image</p>
<p>在上面的例子中，switch语句会判断某个点是否在绿色的对角线x == y上，是否在紫色的对角线x == -y上，或者不在对角线上。</p>
<p>这三个 case 都声明了常量x和y的占位符，用于临时获取元组yetAnotherPoint的两个值。这两个常量被用作where语句的一部分，从而创建一个动态的过滤器(filter)。当且仅当where语句的条件为true时，匹配到的 case 分支才会被执行。</p>
<p>就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值，switch语句就已经完备了，因此不需要再书写默认分支。</p>
<p>复合匹配<br>当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个case后面，并且用逗号隔开。当case后面的任意一种模式匹配的时候，这条分支就会被匹配。并且，如果匹配列表过长，还可以分行书写：</p>
<p>let someCharacter: Character = “e”<br>switch someCharacter {<br>case “a”, “e”, “i”, “o”, “u”:<br>    print(“(someCharacter) is a vowel”)<br>case “b”, “c”, “d”, “f”, “g”, “h”, “j”, “k”, “l”, “m”,<br>     “n”, “p”, “q”, “r”, “s”, “t”, “v”, “w”, “x”, “y”, “z”:<br>    print(“(someCharacter) is a consonant”)<br>default:<br>    print(“(someCharacter) is not a vowel or a consonant”)<br>}<br>// 输出 “e is a vowel”<br>这个switch语句中的第一个case，匹配了英语中的五个小写元音字母。相似的，第二个case匹配了英语中所有的小写辅音字母。最终，default分支匹配了其它所有字符。 复合匹配同样可以包含值绑定。复合匹配里所有的匹配模式，都必须包含相同的值绑定。并且每一个绑定都必须获取到相同类型的值。这保证了，无论复合匹配中的哪个模式发生了匹配，分支体内的代码，都能获取到绑定的值，并且绑定的值都有一样的类型。</p>
<p>let stillAnotherPoint = (9, 0)<br>switch stillAnotherPoint {<br>case (let distance, 0), (0, let distance):<br>    print(“On an axis, (distance) from the origin”)<br>default:<br>    print(“Not on an axis”)<br>}</p>
<p>// 输出 “On an axis, 9 from the origin”<br>上面的case有两个模式：(let distance, 0)匹配了在x轴上的值，(0, let distance)匹配了在y轴上的值。两个模式都绑定了distance，并且distance在两种模式下，都是整型——这意味着分支体内的代码，只要case匹配，都可以获取到distance值</p>
<p>控制转移语句<br>控制转移语句改变你代码的执行顺序，通过它可以实现代码的跳转。Swift 有五种控制转移语句：</p>
<p>continue<br>break<br>fallthrough<br>return<br>throw<br>我们将会在下面讨论continue、break和fallthrough语句。return语句将会在函数章节讨论，throw语句会在错误抛出章节讨论。</p>
<p>Continue<br>continue语句告诉一个循环体立刻停止本次循环，重新开始下次循环。就好像在说“本次循环我已经执行完了”，但是并不会离开整个循环体。</p>
<p>下面的例子把一个小写字符串中的元音字母和空格字符移除，生成了一个含义模糊的短句：</p>
<p>let puzzleInput = “great minds think alike”<br>var puzzleOutput = “”<br>for character in puzzleInput {<br>    switch character {<br>    case “a”, “e”, “i”, “o”, “u”, “ “:<br>        continue<br>    default:<br>        puzzleOutput.append(character)<br>    }<br>}<br>print(puzzleOutput)<br>    // 输出 “grtmndsthnklk”<br>在上面的代码中，只要匹配到元音字母或者空格字符，就调用continue语句，使本次循环结束，重新开始下次循环。这种行为使switch匹配到元音字母和空格字符时不做处理，而不是让每一个匹配到的字符都被打印。</p>
<p>Break<br>break语句会立刻结束整个控制流的执行。break 可以在 switch 或循环语句中使用，用来提前结束switch或循环语句。</p>
<p>循环语句中的 break<br>当在一个循环体中使用break时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号(})后的第一行代码。不会再有本次循环的代码被执行，也不会再有下次的循环产生。</p>
<p>Switch 语句中的 break<br>当在一个switch代码块中使用break时，会立即中断该switch代码块的执行，并且跳转到表示switch代码块结束的大括号(})后的第一行代码。</p>
<p>这种特性可以被用来匹配或者忽略一个或多个分支。因为 Swift 的switch需要包含所有的分支而且不允许有为空的分支，有时为了使你的意图更明显，需要特意匹配或者忽略某个分支。那么当你想忽略某个分支时，可以在该分支内写上break语句。当那个分支被匹配到时，分支内的break语句立即结束switch代码块。</p>
<p>注意： 当一个switch分支仅仅包含注释时，会被报编译时错误。注释不是代码语句而且也不能让switch分支达到被忽略的效果。你应该使用break来忽略某个分支。</p>
<p>下面的例子通过switch来判断一个Character值是否代表下面四种语言之一。为了简洁，多个值被包含在了同一个分支情况中。</p>
<p>let numberSymbol: Character = “三”  // 简体中文里的数字 3<br>var possibleIntegerValue: Int?<br>switch numberSymbol {<br>case “1”, “١”, “一”, “๑”:<br>    possibleIntegerValue = 1<br>case “2”, “٢”, “二”, “๒”:<br>    possibleIntegerValue = 2<br>case “3”, “٣”, “三”, “๓”:<br>    possibleIntegerValue = 3<br>case “4”, “٤”, “四”, “๔”:<br>    possibleIntegerValue = 4<br>default:<br>    break<br>}<br>if let integerValue = possibleIntegerValue {<br>    print(“The integer value of (numberSymbol) is (integerValue).”)<br>} else {<br>    print(“An integer value could not be found for (numberSymbol).”)<br>}<br>// 输出 “The integer value of 三 is 3.”<br>这个例子检查numberSymbol是否是拉丁，阿拉伯，中文或者泰语中的1到4之一。如果被匹配到，该switch分支语句给Int?类型变量possibleIntegerValue设置一个整数值。</p>
<p>当switch代码块执行完后，接下来的代码通过使用可选绑定来判断possibleIntegerValue是否曾经被设置过值。因为是可选类型的缘故，possibleIntegerValue有一个隐式的初始值nil，所以仅仅当possibleIntegerValue曾被switch代码块的前四个分支中的某个设置过一个值时，可选的绑定才会被判定为成功。</p>
<p>在上面的例子中，想要把Character所有的的可能性都枚举出来是不现实的，所以使用default分支来包含所有上面没有匹配到字符的情况。由于这个default分支不需要执行任何动作，所以它只写了一条break语句。一旦落入到default分支中后，break语句就完成了该分支的所有代码操作，代码继续向下，开始执行if let语句。</p>
<p>贯穿<br>在 Swift 里，switch语句不会从上一个 case 分支跳转到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个switch代码块完成了它的执行。相比之下，C 语言要求你显式地插入break语句到每个 case 分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的switch 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。</p>
<p>如果你确实需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用fallthrough关键字。下面的例子使用fallthrough来创建一个数字的描述语句。</p>
<p>let integerToDescribe = 5<br>var description = “The number (integerToDescribe) is”<br>switch integerToDescribe {<br>case 2, 3, 5, 7, 11, 13, 17, 19:<br>    description += “ a prime number, and also”<br>    fallthrough<br>default:<br>    description += “ an integer.”<br>}<br>print(description)<br>// 输出 “The number 5 is a prime number, and also an integer.”<br>这个例子定义了一个String类型的变量description并且给它设置了一个初始值。函数使用switch逻辑来判断integerToDescribe变量的值。当integerToDescribe的值属于列表中的质数之一时，该函数在description后添加一段文字，来表明这个数字是一个质数。然后它使用fallthrough关键字来“贯穿”到default分支中。default分支在description的最后添加一段额外的文字，至此switch代码块执行完了。</p>
<p>如果integerToDescribe的值不属于列表中的任何质数，那么它不会匹配到第一个switch分支。而这里没有其他特别的分支情况，所以integerToDescribe匹配到default分支中。</p>
<p>当switch代码块执行完后，使用print(_:separator:terminator:)函数打印该数字的描述。在这个例子中，数字5被准确的识别为了一个质数。</p>
<p>注意： fallthrough关键字不会检查它下一个将会落入执行的 case 中的匹配条件。fallthrough简单地使代码继续连接到下一个 case 中的代码，这和 C 语言标准中的switch语句特性是一样的。</p>
<p>带标签的语句<br>在 Swift 中，你可以在循环体和条件语句中嵌套循环体和条件语句来创造复杂的控制流结构。并且，循环体和条件语句都可以使用break语句来提前结束整个代码块。因此，显式地指明break语句想要终止的是哪个循环体或者条件语句，会很有用。类似地，如果你有许多嵌套的循环体，显式指明continue语句想要影响哪一个循环体也会非常有用。</p>
<p>为了实现这个目的，你可以使用标签（statement label）来标记一个循环体或者条件语句，对于一个条件语句，你可以使用break加标签的方式，来结束这个被标记的语句。对于一个循环语句，你可以使用break或者continue加标签，来结束或者继续这条被标记语句的执行。</p>
<p>声明一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，作为这个语句的前导关键字(introducor keyword)，并且该标签后面跟随一个冒号。下面是一个针对while循环体的标签语法，同样的规则适用于所有的循环体和条件语句。</p>
<p>label name: while condition { statements }</p>
<p>下面的例子是前面章节中蛇和梯子的适配版本，在此版本中，我们将使用一个带有标签的while循环体中调用break和continue语句。这次，游戏增加了一条额外的规则：</p>
<p>为了获胜，你必须刚好落在第 25 个方块中。<br>如果某次掷骰子使你的移动超出第 25 个方块，你必须重新掷骰子，直到你掷出的骰子数刚好使你能落在第 25 个方块中。</p>
<p>游戏的棋盘和之前一样：</p>
<p>image</p>
<p>finalSquare、board、square和diceRoll值被和之前一样的方式初始化：</p>
<p>let finalSquare = 25<br>var board = <a href="repeating: 0, count: finalSquare + 1" target="_blank" rel="noopener">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0<br>这个版本的游戏使用while循环和switch语句来实现游戏的逻辑。while循环有一个标签名gameLoop，来表明它是游戏的主循环。</p>
<p>该while循环体的条件判断语句是while square !=finalSquare，这表明你必须刚好落在方格25中。</p>
<p>gameLoop: while square != finalSquare {<br>    diceRoll += 1<br>    if diceRoll == 7 { diceRoll = 1 }<br>    switch square + diceRoll {<br>    case finalSquare:<br>        // 骰子数刚好使玩家移动到最终的方格里，游戏结束。<br>        break gameLoop<br>    case let newSquare where newSquare &gt; finalSquare:<br>        // 骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子<br>        continue gameLoop<br>    default:<br>        // 合法移动，做正常的处理<br>        square += diceRoll<br>        square += board[square]<br>    }<br>}<br>print(“Game over!”)<br>每次循环迭代开始时掷骰子。与之前玩家掷完骰子就立即移动不同，这里使用了switch语句来考虑每次移动可能产生的结果，从而决定玩家本次是否能够移动。</p>
<p>如果骰子数刚好使玩家移动到最终的方格里，游戏结束。break gameLoop语句跳转控制去执行while循环体后的第一行代码，意味着游戏结束。<br>如果骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子。continue gameLoop语句结束本次while循环，开始下一次循环。<br>在剩余的所有情况中，骰子数产生的都是合法的移动。玩家向前移动 diceRoll 个方格，然后游戏逻辑再处理玩家当前是否处于蛇头或者梯子的底部。接着本次循环结束，控制跳转到while循环体的条件判断语句处，再决定是否需要继续执行下次循环。<br>注意：<br>如果上述的break语句没有使用gameLoop标签，那么它将会中断switch语句而不是while循环。使用gameLoop标签清晰的表明了break想要中断的是哪个代码块。 同时请注意，当调用continue gameLoop去跳转到下一次循环迭代时，这里使用gameLoop标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以continue语句会影响到哪个循环体是没有歧义的。然而，continue语句使用gameLoop标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的break gameLoop，能够使游戏的逻辑更加清晰和易于理解。</p>
<p>提前退出<br>像if语句一样，guard的执行取决于一个表达式的布尔值。我们可以使用guard语句来要求条件必须为真时，以执行guard语句后的代码。不同于if语句，一个guard语句总是有一个else从句，如果条件不为真则执行else从句中的代码。</p>
<p>func greet(person: [String: String]) {<br>    guard let name = person[“name”] else {<br>        return<br>    }<br>    print(“Hello (name)”)<br>    guard let location = person[“location”] else {<br>        print(“I hope the weather is nice near you.”)<br>        return<br>    }<br>    print(“I hope the weather is nice in (location).”)<br>}<br>greet([“name”: “John”])<br>// 输出 “Hello John!”<br>// 输出 “I hope the weather is nice near you.”<br>greet([“name”: “Jane”, “location”: “Cupertino”])<br>// 输出 “Hello Jane!”<br>// 输出 “I hope the weather is nice in Cupertino.”<br>如果guard语句的条件被满足，则继续执行guard语句大括号后的代码。将变量或者常量的可选绑定作为guard语句的条件，都可以保护guard语句后面的代码。</p>
<p>如果条件不被满足，在else分支上的代码就会被执行。这个分支必须转移控制以退出guard语句出现的代码段。它可以用控制转移语句如return,break,continue或者throw做这件事，或者调用一个不返回的方法或函数，例如fatalError()。</p>
<p>相比于可以实现同样功能的if语句，按需使用guard语句会提升我们代码的可读性。它可以使你的代码连贯的被执行而不需要将它包在else块中，它可以使你在紧邻条件判断的地方，处理违规的情况。</p>
<p>检测 API 可用性<br>Swift内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的API。</p>
<p>编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译时报错。</p>
<p>我们在if或guard语句中使用可用性条件（availability condition)去有条件的执行一段代码，来在运行时判断调用的API是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。</p>
<p>if #available(iOS 10, macOS 10.12, <em>) {<br>    // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API<br>} else {<br>    // 使用先前版本的 iOS 和 macOS 的 API<br>}<br>以上可用性条件指定，if语句的代码块仅仅在 iOS 10 或 macOS 10.12 及更高版本才运行。最后一个参数，</em>，是必须的，用于指定在所有其它平台中，如果版本号高于你的设备指定的最低版本，if语句的代码块将会运行。</p>
<p>在它一般的形式中，可用性条件使用了一个平台名字和版本的列表。平台名字可以是iOS，macOS，watchOS和tvOS——请访问声明属性来获取完整列表。除了指定像 iOS 8 或 macOS 10.10 的大版本号，也可以指定像 iOS 8.3 以及 macOS 10.10.3 的小版本号。</p>
<p>if #available(platform name version, …, *) {<br>    APIs 可用，语句将执行<br>} else {<br>    APIs 不可用，语句将不执行<br>}</p>
<p>函数是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候”调用”这个函数来完成它的任务。</p>
<p>Swift 统一的函数语法非常的灵活，可以用来表示任何函数，包括从最简单的没有参数名字的 C 风格函数，到复杂的带局部和外部参数名的 Objective-C 风格函数。参数可以提供默认值，以简化函数调用。参数也可以既当做传入参数，也当做传出参数，也就是说，一旦函数执行结束，传入的参数值将被修改。</p>
<p>在 Swift 中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型。你可以把函数类型当做任何其他普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>
<p>函数的定义与调用<br>当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入，称为参数，也可以定义某种类型的值作为函数执行结束时的输出，称为返回类型。</p>
<p>每个函数有个函数名，用来描述函数执行的任务。要使用一个函数时，用函数名来“调用”这个函数，并传给它匹配的输入值（称作 实参 ）。函数的实参必须与函数参数表里参数的顺序一致。</p>
<p>下面例子中的函数的名字是greet(person:)，之所以叫这个名字，是因为这个函数用一个人的名字当做输入，并返回向这个人问候的语句。为了完成这个任务，你需要定义一个输入参数——一个叫做 person 的 String 值，和一个包含给这个人问候语的 String 类型的返回值：</p>
<p>func greet(person: String) -&gt; String {<br>    let greeting = “Hello, “ + person + “!”<br>    return greeting<br>}<br>所有的这些信息汇总起来成为函数的定义，并以 func 作为前缀。指定函数返回类型时，用返回箭头 -&gt;（一个连字符后跟一个右尖括号）后跟返回类型的名称的方式来表示。</p>
<p>该定义描述了函数的功能，它期望接收什么作为参数和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用：</p>
<p>print(greet(person: “Anna”))<br>// 打印 “Hello, Anna!”<br>print(greet(person: “Brian”))<br>// 打印 “Hello, Brian!”<br>调用 greet(person:) 函数时，在圆括号中传给它一个 String 类型的实参，例如 greet(person: “Anna”)。正如上面所示，因为这个函数返回一个 String 类型的值，所以greet 可以被包含在 print(_:separator:terminator:) 的调用中，用来输出这个函数的返回值。</p>
<p>注意<br>print(_:separator:terminator:) 函数的第一个参数并没有设置一个标签，而其他的参数因为已经有了默认值，因此是可选的。关于这些函数语法上的变化详见下方关于 函数参数标签和参数名 以及 默认参数值。</p>
<p>在 greet(person:) 的函数体中，先定义了一个新的名为 greeting 的 String 常量，同时，把对 personName 的问候消息赋值给了 greeting 。然后用 return 关键字把这个问候返回出去。一旦 return greeting 被调用，该函数结束它的执行并返回 greeting 的当前值。</p>
<p>你可以用不同的输入值多次调用 greet(person:)。上面的例子展示的是用”Anna”和”Brian”调用的结果，该函数分别返回了不同的结果。</p>
<p>为了简化这个函数的定义，可以将问候消息的创建和返回写成一句：</p>
<p>func greetAgain(person: String) -&gt; String {<br>    return “Hello again, “ + person + “!”<br>}<br>print(greetAgain(person: “Anna”))<br>// 打印 “Hello again, Anna!”</p>
<p>函数参数与返回值<br>函数参数与返回值在 Swift 中非常的灵活。你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。</p>
<p>无参数函数<br>函数可以没有参数。下面这个函数就是一个无参数函数，当被调用时，它返回固定的 String 消息：</p>
<p>func sayHelloWorld() -&gt; String {<br>    return “hello, world”<br>}<br>print(sayHelloWorld())<br>// 打印 “hello, world”<br>尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。</p>
<p>多参数函数<br>函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。</p>
<p>下面这个函数用一个人名和是否已经打过招呼作为输入，并返回对这个人的适当问候语:</p>
<p>func greet(person: String, alreadyGreeted: Bool) -&gt; String {<br>    if alreadyGreeted {<br>        return greetAgain(person: person)<br>    } else {<br>        return greet(person: person)<br>    }<br>}<br>print(greet(person: “Tim”, alreadyGreeted: true))<br>// 打印 “Hello again, Tim!”<br>你可以通过在括号内使用逗号分隔来传递一个String参数值和一个标识为alreadyGreeted的Bool值，来调用greet(person:alreadyGreeted:)函数。注意这个函数和上面greet(person:)是不同的。虽然它们都有着同样的名字greet，但是greet(person:alreadyGreeted:)函数需要两个参数，而greet(person:)只需要一个参数。</p>
<p>无返回值函数<br>函数可以没有返回值。下面是 greet(person:) 函数的另一个版本，这个函数直接打印一个String值，而不是返回它：</p>
<p>func greet(person: String) {<br>    print(“Hello, (person)!”)<br>}<br>greet(person: “Dave”)<br>// 打印 “Hello, Dave!”<br>因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头（-&gt;）和返回类型。</p>
<p>注意<br>严格上来说，虽然没有返回值被定义，greet(person:) 函数依然返回了值。没有定义返回类型的函数会返回一个特殊的Void值。它其实是一个空的元组（tuple），没有任何元素，可以写成()。</p>
<p>被调用时，一个函数的返回值可以被忽略：</p>
<p>func printAndCount(string: String) -&gt; Int {<br>    print(string)<br>    return string.count<br>}<br>func printWithoutCounting(string: String) {<br>    let _ = printAndCount(string: string)<br>}<br>printAndCount(string: “hello, world”)<br>// 打印 “hello, world” 并且返回值 12<br>printWithoutCounting(string: “hello, world”)<br>// 打印 “hello, world” 但是没有返回任何值<br>第一个函数 printAndCount(string:)，输出一个字符串并返回 Int 类型的字符数。第二个函数 printWithoutCounting(string:)调用了第一个函数，但是忽略了它的返回值。当第二个函数被调用时，消息依然会由第一个函数输出，但是返回值不会被用到。</p>
<p>注意:<br>返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译时错误（compile-time error）。</p>
<p>多重返回值函数<br>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p>
<p>下例中定义了一个名为 minMax(array:) 的函数，作用是在一个 Int 类型的数组中找出最小值与最大值。</p>
<p>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {<br>    var currentMin = array[0]<br>    var currentMax = array[0]<br>    for value in array[1..&lt;array.count] {<br>        if value &lt; currentMin {<br>            currentMin = value<br>        } else if value &gt; currentMax {<br>            currentMax = value<br>        }<br>    }<br>    return (currentMin, currentMax)<br>}<br>minMax(array:) 函数返回一个包含两个 Int 值的元组，这些值被标记为 min 和 max ，以便查询函数的返回值时可以通过名字访问它们。</p>
<p>在 minMax(array:) 的函数体中，在开始的时候设置两个工作变量 currentMin 和 currentMax 的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比 currentMin 和 currentMax 更小或更大。最后数组中的最小值与最大值作为一个包含两个 Int 值的元组返回。</p>
<p>因为元组的成员值已被命名，因此可以通过 . 语法来检索找到的最小值与最大值：</p>
<p>let bounds = minMax(array: [8, -6, 2, 109, 3, 71])<br>print(“min is (bounds.min) and max is (bounds.max)”)<br>// 打印 “min is -6 and max is 109”<br>需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</p>
<p>可选元组返回类型<br>如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用可选的（ optional ） 元组返回类型反映整个元组可以是nil的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如 (Int, Int)? 或 (String, Int, Bool)?</p>
<p>注意 可选元组类型如 (Int, Int)? 与元组包含可选类型如 (Int?, Int?) 是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
<p>前面的 minMax(array:) 函数返回了一个包含两个 Int 值的元组。但是函数不会对传入的数组执行任何安全检查，如果 array 参数是一个空数组，如上定义的 minMax(array:) 在试图访问 array[0] 时会触发一个运行时错误(runtime error)。</p>
<p>为了安全地处理这个“空数组”问题，将 minMax(array:) 函数改写为使用可选元组返回类型，并且当数组为空时返回 nil：</p>
<p>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {<br>    if array.isEmpty { return nil }<br>    var currentMin = array[0]<br>    var currentMax = array[0]<br>    for value in array[1..&lt;array.count] {<br>        if value &lt; currentMin {<br>            currentMin = value<br>        } else if value &gt; currentMax {<br>            currentMax = value<br>        }<br>    }<br>    return (currentMin, currentMax)<br>}<br>你可以使用可选绑定来检查 minMax(array:) 函数返回的是一个存在的元组值还是 nil：</p>
<p>if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {<br>    print(“min is (bounds.min) and max is (bounds.max)”)<br>}<br>// 打印 “min is -6 and max is 109”</p>
<p>函数参数标签和参数名称<br>每个函数参数都有一个参数标签( argument label )以及一个参数名称( parameter name )。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情况下，函数参数使用参数名称来作为它们的参数标签。</p>
<p>func someFunction(firstParameterName: Int, secondParameterName: Int) {<br>    // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值<br>}<br>someFunction(firstParameterName: 1, secondParameterName: 2)<br>所有的参数都必须有一个独一无二的名字。虽然多个参数拥有同样的参数标签是可能的，但是一个唯一的函数标签能够使你的代码更具可读性。</p>
<p>指定参数标签<br>你可以在参数名称前指定它的参数标签，中间以空格分隔：</p>
<p>func someFunction(argumentLabel parameterName: Int) {<br>    // 在函数体内，parameterName 代表参数值<br>}<br>这个版本的 greet(person:) 函数，接收一个人的名字和他的家乡，并且返回一句问候：</p>
<p>func greet(person: String, from hometown: String) -&gt; String {<br>    return “Hello (person)!  Glad you could visit from (hometown).”<br>}<br>print(greet(person: “Bill”, from: “Cupertino”))<br>// 打印 “Hello Bill!  Glad you could visit from Cupertino.”<br>参数标签的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</p>
<p>忽略参数标签<br>如果你不希望为某个参数添加一个标签，可以使用一个下划线(_)来代替一个明确的参数标签。</p>
<p>func someFunction(_ firstParameterName: Int, secondParameterName: Int) {<br>     // 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值<br>}<br>someFunction(1, secondParameterName: 2)<br>如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。</p>
<p>默认参数值<br>你可以在函数体中通过给参数赋值来为任意一个参数定义默认值（Deafult Value）。当默认值被定义后，调用这个函数时可以忽略这个参数。</p>
<p>func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {<br>    // 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。<br>}<br>someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault = 6<br>someFunction(parameterWithoutDefault: 4) // parameterWithDefault = 12<br>将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。</p>
<p>可变参数<br>一个可变参数（variadic parameter）可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（…）的方式来定义可变参数。</p>
<p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 numbers 的 Double… 型可变参数，在函数体内可以当做一个叫 numbers 的 [Double] 型的数组常量。</p>
<p>下面的这个函数用来计算一组任意长度数字的 算术平均数（arithmetic mean)：</p>
<p>func arithmeticMean(_ numbers: Double…) -&gt; Double {<br>    var total: Double = 0<br>    for number in numbers {<br>        total += number<br>    }<br>    return total / Double(numbers.count)<br>}<br>arithmeticMean(1, 2, 3, 4, 5)<br>// 返回 3.0, 是这 5 个数的平均数。<br>arithmeticMean(3, 8.25, 18.75)<br>// 返回 10.0, 是这 3 个数的平均数。<br>注意：<br>一个函数最多只能拥有一个可变参数。</p>
<p>输入输出参数<br>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误(compile-time error)。这意味着你不能错误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。</p>
<p>定义一个输入输出参数时，在参数定义前加 inout 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看输入输出参数一节。</p>
<p>你只能传递变量给输入输出参数。你不能传入常量或者字面量，因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加 &amp; 符，表示这个值可以被函数修改。</p>
<p>注意 输入输出参数不能有默认值，而且可变参数不能用 inout 标记。</p>
<p>下例中，swapTwoInts(_:_:) 函数有两个分别叫做 a 和 b 的输入输出参数：</p>
<p>func swapTwoInts(_ a: inout Int, _ b: inout Int) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}<br>swapTwoInts(_:_:) 函数简单地交换 a 与 b 的值。该函数先将 a 的值存到一个临时常量 temporaryA 中，然后将 b 的值赋给 a，最后将 temporaryA 赋值给 b。</p>
<p>你可以用两个 Int 型的变量来调用 swapTwoInts(_:<em>:)。需要注意的是，someInt 和 anotherInt 在传入 swapTwoInts(</em>:_:) 函数前，都加了 &amp; 的前缀：</p>
<p>var someInt = 3<br>var anotherInt = 107<br>swapTwoInts(&amp;someInt, &amp;anotherInt)<br>print(“someInt is now (someInt), and anotherInt is now (anotherInt)”)<br>// 打印 “someInt is now 107, and anotherInt is now 3”<br>从上面这个例子中，我们可以看到 someInt 和 anotherInt 的原始值在 swapTwoInts(_:_:) 函数中被修改，尽管它们的定义在函数体外。</p>
<p>注意：<br>输入输出参数和返回值是不一样的。上面的 swapTwoInts 函数并没有定义任何返回值，但仍然修改了 someInt 和 anotherInt 的值。输入输出参数是函数对函数体外产生影响的另一种方式。</p>
<p>函数类型<br>每个函数都有种特定的函数类型，函数的类型由函数的参数类型和返回类型组成。</p>
<p>例如：</p>
<p>func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {<br>    return a + b<br>}<br>func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int {<br>    return a * b<br>}<br>这个例子中定义了两个简单的数学函数：addTwoInts 和 multiplyTwoInts。这两个函数都接受两个 Int 值， 返回一个 Int 值。</p>
<p>这两个函数的类型是 (Int, Int) -&gt; Int，可以解读为“这个函数类型有两个 Int 型的参数并返回一个 Int 型的值。”。</p>
<p>下面是另一个例子，一个没有参数，也没有返回值的函数：</p>
<p>func printHelloWorld() {<br>    print(“hello, world”)<br>}<br>这个函数的类型是：() -&gt; Void，或者叫“没有参数，并返回 Void 类型的函数”。</p>
<p>使用函数类型<br>在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</p>
<p>var mathFunction: (Int, Int) -&gt; Int = addTwoInts<br>这段代码可以被解读为：</p>
<p>”定义一个叫做 mathFunction 的变量，类型是‘一个有两个 Int 型的参数并返回一个 Int 型的值的函数’，并让这个新变量指向 addTwoInts 函数”。</p>
<p>addTwoInts 和 mathFunction 有同样的类型，所以这个赋值过程在 Swift 类型检查(type-check)中是允许的。</p>
<p>现在，你可以用 mathFunction 来调用被赋值的函数了：</p>
<p>print(“Result: (mathFunction(2, 3))”)<br>// Prints “Result: 5”<br>有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样：</p>
<p>mathFunction = multiplyTwoInts<br>print(“Result: (mathFunction(2, 3))”)<br>// Prints “Result: 6”<br>就像其他类型一样，当赋值一个函数给常量或变量时，你可以让 Swift 来推断其函数类型：</p>
<p>let anotherMathFunction = addTwoInts<br>// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</p>
<p>函数类型作为参数类型<br>你可以用 (Int, Int) -&gt; Int 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</p>
<p>下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果：</p>
<p>func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {<br>    print(“Result: (mathFunction(a, b))”)<br>}<br>printMathResult(addTwoInts, 3, 5)<br>// 打印 “Result: 8”<br>这个例子定义了 printMathResult(_:_:_:) 函数，它有三个参数：第一个参数叫 mathFunction，类型是 (Int, Int) -&gt; Int，你可以传入任何这种类型的函数；第二个和第三个参数叫 a 和 b，它们的类型都是 Int，这两个值作为已给出的函数的输入值。</p>
<p>当 printMathResult(_:_:_:) 被调用时，它被传入 addTwoInts 函数和整数 3 和 5。它用传入 3 和 5 调用 addTwoInts，并输出结果：8。</p>
<p>printMathResult(_:_:<em>:) 函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得 printMathResult(</em>:_:_:) 能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>
<p>函数类型作为返回类型<br>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。</p>
<p>下面的这个例子中定义了两个简单函数，分别是 stepForward(<em>:) 和 stepBackward(</em>:)。stepForward(<em>:)函数返回一个比输入值大 1 的值。stepBackward(</em>:) 函数返回一个比输入值小 1 的值。这两个函数的类型都是 (Int) -&gt; Int：</p>
<p>func stepForward(_ input: Int) -&gt; Int {<br>    return input + 1<br>}<br>func stepBackward(_ input: Int) -&gt; Int {<br>    return input - 1<br>}<br>如下名为 chooseStepFunction(backward:) 的函数，它的返回类型是 (Int) -&gt; Int 类型的函数。chooseStepFunction(backward:) 根据布尔值 backwards 来返回 stepForward(<em>:) 函数或 stepBackward(</em>:) 函数：</p>
<p>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {<br>    return backward ? stepBackward : stepForward<br>}<br>你现在可以用 chooseStepFunction(backward:) 来获得两个函数其中的一个：</p>
<p>var currentValue = 3<br>let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)<br>// moveNearerToZero 现在指向 stepBackward() 函数。<br>上面这个例子中计算出从 currentValue 逐渐接近到0是需要向正数走还是向负数走。currentValue 的初始值是 3，这意味着 currentValue &gt; 0 为真（true），这将使得 chooseStepFunction(<em>:) 返回 stepBackward(</em>:) 函数。一个指向返回的函数的引用保存在了 moveNearerToZero 常量中。</p>
<p>现在，moveNearerToZero指向了正确的函数，它可以被用来数到零：</p>
<p>print(“Counting to zero:”)<br>// Counting to zero:<br>while currentValue != 0 {<br>    print(“(currentValue)… “)<br>    currentValue = moveNearerToZero(currentValue)<br>}<br>print(“zero!”)<br>// 3…<br>// 2…<br>// 1…<br>// zero!</p>
<p>嵌套函数<br>到目前为止本章中你所见到的所有函数都叫全局函数（global functions），它们定义在全局域中。你也可以把函数定义在别的函数体中，称作 嵌套函数（nested functions）。</p>
<p>默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>
<p>你可以用返回嵌套函数的方式重写 chooseStepFunction(backward:) 函数：</p>
<p>func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int {<br>    func stepForward(input: Int) -&gt; Int { return input + 1 }<br>    func stepBackward(input: Int) -&gt; Int { return input - 1 }<br>    return backward ? stepBackward : stepForward<br>}<br>var currentValue = -4<br>let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)<br>// moveNearerToZero now refers to the nested stepForward() function<br>while currentValue != 0 {<br>    print(“(currentValue)… “)<br>    currentValue = moveNearerToZero(currentValue)<br>}<br>print(“zero!”)<br>// -4…<br>// -3…<br>// -2…<br>// -1…<br>// zero!</p>
<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数比较相似。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 Swift 会为你管理在捕获过程中涉及到的所有内存操作。</p>
<p>注意 如果你不熟悉捕获（capturing）这个概念也不用担心，你可以在值捕获章节对其进行详细了解。</p>
<p>在函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>
<p>全局函数是一个有名字但不会捕获任何值的闭包<br>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包<br>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包<br>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<p>利用上下文推断参数和返回值类型<br>隐式返回单表达式闭包，即单表达式闭包可以省略 return 关键字<br>参数名称缩写<br>尾随闭包语法</p>
<p>闭包表达式<br>嵌套函数是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。当然，有时候编写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在你处理一些函数并需要将另外一些函数作为该函数的参数时。</p>
<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sorted(by:) 方法定义和语法优化的方式。每一次迭代都用更简洁的方式描述了相同的功能。</p>
<p>sorted 方法<br>Swift 标准库提供了名为 sorted(by:) 的方法，它会根据你所提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，sorted(by:) 方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被 sorted(by:) 方法修改。</p>
<p>下面的闭包表达式示例使用 sorted(by:) 方法对一个 String 类型的数组进行字母逆序排序。以下是初始数组：</p>
<p>let names = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]<br>sorted(by:) 方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回true，反之返回false。</p>
<p>该例子对一个 String 类型的数组进行排序，因此排序闭包函数类型需为 (String, String) -&gt; Bool。</p>
<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 sorted(by:) 方法的参数传入：</p>
<p>func backward(_ s1: String, _ s2: String) -&gt; Bool {<br>    return s1 &gt; s2<br>}<br>var reversedNames = names.sorted(by: backward)<br>// reversedNames 为 [“Ewa”, “Daniella”, “Chris”, “Barry”, “Alex”]<br>如果第一个字符串（s1）大于第二个字符串（s2），backward(_:_:) 函数会返回 true，表示在新的数组中 s1 应该出现在 s2 前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母 “B” 大于字母 “A” ，字符串 “Tom” 大于字符串 “Tim”。该闭包将进行字母逆序排序，”Barry” 将会排在 “Alex” 之前。</p>
<p>然而，以这种方式来编写一个实际上很简单的表达式（a &gt; b)，确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。</p>
<p>闭包表达式语法<br>闭包表达式语法有如下的一般形式：</p>
<p>{ (parameters) -&gt; returnType in<br>    statements<br>}<br>闭包表达式参数 可以是 in-out 参数，但不能设定默认值。也可以使用具名的可变参数（译者注：但是如果可变参数不放在参数列表的最后一位的话，调用闭包的时时编译器将报错。可参考这里）。元组也可以作为参数和返回值。</p>
<p>下面的例子展示了之前 backward(_:_:) 函数对应的闭包表达式版本的代码：</p>
<p>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in<br>    return s1 &gt; s2<br>})<br>需要注意的是内联闭包参数和返回值类型声明与 backward(_:_:) 函数类型声明相同。在这两种方式中，都写成了 (s1: String, s2: String) -&gt; Bool。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>
<p>闭包的函数体部分由关键字in引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p>
<p>reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )<br>该例中 sorted(by:) 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p>
<p>根据上下文推断类型<br>因为排序闭包函数是作为 sorted(by:) 方法的参数传入的，Swift 可以推断其参数和返回值的类型。sorted(by:) 方法被一个字符串数组调用，因此其参数必须是 (String, String) -&gt; Bool 类型的函数。这意味着 (String, String) 和 Bool 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（-&gt;）和围绕在参数周围的括号也可以被省略：</p>
<p>reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )<br>实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。</p>
<p>尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 sorted(by:) 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>
<p>单表达式闭包隐式返回<br>单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>
<p>reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )<br>在这个例子中，sorted(by:) 方法的参数类型明确了闭包必须返回一个 Bool 类型值。因为闭包函数体只包含了一个单一表达式（s1 &gt; s2），该表达式返回 Bool 类型值，因此这里没有歧义，return 关键字可以省略。</p>
<p>参数名称缩写<br>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 $0，$1，$2 来顺序调用闭包的参数，以此类推。</p>
<p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<p>reversedNames = names.sorted(by: { $0 &gt; $1 } )<br>在这个例子中，$0和$1表示闭包中第一个和第二个 String 类型的参数。</p>
<p>运算符方法<br>实际上还有一种更简短的方式来编写上面例子中的闭包表达式。Swift 的 String 类型定义了关于大于号（&gt;）的字符串实现，其作为一个函数接受两个 String 类型的参数并返回 Bool 类型的值。而这正好与 sorted(by:) 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断出你想使用大于号的字符串函数实现：</p>
<p>reversedNames = names.sorted(by: &gt;)<br>更多关于运算符方法的内容请查看运算符方法。</p>
<p>尾随闭包<br>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p>
<p>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {<br>    // 函数体部分<br>}</p>
<p>// 以下是不使用尾随闭包进行函数调用<br>someFunctionThatTakesAClosure(closure: {<br>    // 闭包主体部分<br>})</p>
<p>// 以下是使用尾随闭包进行函数调用<br>someFunctionThatTakesAClosure() {<br>    // 闭包主体部分<br>}<br>在闭包表达式语法一节中作为 sorted(by:) 方法参数的字符串排序闭包可以改写为：</p>
<p>reversedNames = names.sorted() { $0 &gt; $1 }<br>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 () 省略掉：</p>
<p>reversedNames = names.sorted { $0 &gt; $1 }<br>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的 Array 类型有一个 map(_:) 方法，这个方法获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p>
<p>当提供给数组的闭包应用于每个数组元素后，map(_:) 方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p>
<p>下例介绍了如何在 map(_:) 方法中使用尾随闭包将 Int 类型数组 [16, 58, 510] 转换为包含对应 String 类型的值的数组[“OneSix”, “FiveEight”, “FiveOneZero”]：</p>
<p>let digitNames = [<br>    0: “Zero”, 1: “One”, 2: “Two”,   3: “Three”, 4: “Four”,<br>    5: “Five”, 6: “Six”, 7: “Seven”, 8: “Eight”, 9: “Nine”<br>]<br>let numbers = [16, 58, 510]<br>如上代码创建了一个整型数位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。</p>
<p>你现在可以通过传递一个尾随闭包给 numbers 数组的 map(_:) 方法来创建对应的字符串版本数组：</p>
<p>let strings = numbers.map {<br>    (number) -&gt; String in<br>    var number = number<br>    var output = “”<br>    repeat {<br>        output = digitNames[number % 10]! + output<br>        number /= 10<br>    } while number &gt; 0<br>    return output<br>}<br>// strings 常量被推断为字符串类型数组，即 [String]<br>// 其值为 [“OneSix”, “FiveEight”, “FiveOneZero”]<br>map(_:) 为数组中每一个元素调用了一次闭包表达式。你不需要指定闭包的输入参数 number 的类型，因为可以通过要映射的数组类型进行推断。</p>
<p>在该例中，局部变量 number 的值由闭包中的 number 参数获得，因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是常量)，闭包表达式指定了返回类型为 String，以表明存储映射值的新数组类型为 String。</p>
<p>闭包表达式在每次被调用的时候创建了一个叫做 output 的字符串并返回。其使用求余运算符（number % 10）计算最后一位数字并利用 digitNames 字典获取所映射的字符串。这个闭包能够用于创建任意正整数的字符串表示。</p>
<p>注意：<br>字典 digitNames 下标后跟着一个叹号（!），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定 number % 10 总是 digitNames 字典的有效下标，因此叹号可以用于强制解包 (force-unwrap) 存储在下标的可选类型的返回值中的String类型的值。</p>
<p>从 digitNames 字典中获取的字符串被添加到 output 的前部，逆序建立了一个字符串版本的数字。（在表达式 number % 10 中，如果 number 为 16，则返回 6，58 返回 8，510 返回 0。）</p>
<p>number 变量之后除以 10。因为其是整数，在计算过程中未除尽部分被忽略。因此 16 变成了 1，58 变成了 5，510 变成了 51。</p>
<p>整个过程重复进行，直到 number /= 10 为 0，这时闭包会将字符串 output 返回，而 map(_:) 方法则会将字符串添加到映射数组中。</p>
<p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在 map(_:) 方法的括号内。</p>
<p>值捕获<br>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有一个叫做 makeIncrementer 的函数，其包含了一个叫做 incrementer 的嵌套函数。嵌套函数 incrementer() 从上下文中捕获了两个值，runningTotal 和 amount。捕获这些值之后，makeIncrementer 将 incrementer 作为闭包返回。每次调用 incrementer 时，其会以 amount 作为增量增加 runningTotal 的值。</p>
<p>func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {<br>    var runningTotal = 0<br>    func incrementer() -&gt; Int {<br>        runningTotal += amount<br>        return runningTotal<br>    }<br>    return incrementer<br>}<br>makeIncrementer 返回类型为 () -&gt; Int。这意味着其返回的是一个函数，而非一个简单类型的值。该函数在每次调用时不接受参数，只返回一个 Int 类型的值。关于函数返回其他函数的内容，请查看函数类型作为返回类型。</p>
<p>makeIncrementer(forIncrement:) 函数定义了一个初始值为 0 的整型变量 runningTotal，用来存储当前总计数值。该值为 incrementer 的返回值。</p>
<p>makeIncrementer(forIncrement:) 有一个 Int 类型的参数，其外部参数名为 forIncrement，内部参数名为 amount，该参数表示每次 incrementer 被调用时 runningTotal 将要增加的量。makeIncrementer 函数还定义了一个嵌套函数 incrementer，用来执行实际的增加操作。该函数简单地使 runningTotal 增加 amount，并将其返回。</p>
<p>如果我们单独考虑嵌套函数 incrementer()，会发现它有些不同寻常：</p>
<p>func incrementer() -&gt; Int {<br>    runningTotal += amount<br>    return runningTotal<br>}<br>incrementer() 函数并没有任何参数，但是在函数体内访问了 runningTotal 和 amount 变量。这是因为它从外围函数捕获了 runningTotal 和 amount 变量的引用。捕获引用保证了 runningTotal 和 amount 变量在调用完 makeIncrementer 后不会消失，并且保证了在下一次执行 incrementer 函数时，runningTotal 依旧存在。</p>
<p>注意 为了优化，如果一个值不会被闭包改变，或者在闭包创建后不会改变，Swift 可能会改为捕获并保存一份对值的拷贝。 Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
<p>下面是一个使用 makeIncrementer 的例子：</p>
<p>let incrementByTen = makeIncrementer(forIncrement: 10)<br>该例子定义了一个叫做 incrementByTen 的常量，该常量指向一个每次调用会将其 runningTotal 变量增加 10 的 incrementer 函数。调用这个函数多次可以得到以下结果：</p>
<p>incrementByTen()<br>// 返回的值为10<br>incrementByTen()<br>// 返回的值为20<br>incrementByTen()<br>// 返回的值为30<br>如果你创建了另一个 incrementer，它会有属于自己的引用，指向一个全新、独立的 runningTotal 变量：</p>
<p>let incrementBySeven = makeIncrementer(forIncrement: 7)<br>incrementBySeven()<br>// 返回的值为7<br>再次调用原来的 incrementByTen 会继续增加它自己的 runningTotal 变量，该变量和 incrementBySeven 中捕获的变量没有任何联系：</p>
<p>incrementByTen()<br>// 返回的值为40<br>注意：<br>如果你将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，你将在闭包和该实例间创建一个循环强引用。Swift 使用捕获列表来打破这种循环强引用。更多信息，请参考闭包引起的循环强引用。</p>
<p>闭包是引用类型<br>上面的例子中，incrementBySeven 和 incrementByTen 都是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。</p>
<p>无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用 incrementByTen 是一个常量，而并非闭包内容本身。</p>
<p>这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
<p>let alsoIncrementByTen = incrementByTen<br>alsoIncrementByTen()<br>// 返回的值为50</p>
<p>逃逸闭包<br>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<p>var completionHandlers: [() -&gt; Void] = []<br>func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {<br>    completionHandlers.append(completionHandler)<br>}<br>someFunctionWithEscapingClosure(_:) 函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你不将这个参数标记为 @escaping，就会得到一个编译错误。</p>
<p>将一个闭包标记为 @escaping 意味着你必须在闭包中显式地引用 self。比如说，在下面的代码中，传递到 someFunctionWithEscapingClosure(<em>:) 中的闭包是一个逃逸闭包，这意味着它需要显式地引用 self。相对的，传递到 someFunctionWithNonescapingClosure(</em>:) 中的闭包是一个非逃逸闭包，这意味着它可以隐式引用 self。</p>
<p>func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {<br>    closure()<br>}</p>
<p>class SomeClass {<br>    var x = 10<br>    func doSomething() {<br>        someFunctionWithEscapingClosure { self.x = 100 }<br>        someFunctionWithNonescapingClosure { x = 200 }<br>    }<br>}</p>
<p>let instance = SomeClass()<br>instance.doSomething()<br>print(instance.x)<br>// 打印出 “200”</p>
<p>completionHandlers.first?()<br>print(instance.x)<br>// 打印出 “100”</p>
<p>自动闭包<br>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。</p>
<p>我们经常会调用采用自动闭包的函数，但是很少去实现这样的函数。举个例子来说，assert(condition:message:file:line:) 函数接受自动闭包作为它的 condition 参数和 message 参数；它的 condition 参数仅会在 debug 模式下被求值，它的 message 参数仅当 condition 参数为 false 时被计算求值。</p>
<p>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。下面的代码展示了闭包如何延时求值。</p>
<p>var customersInLine = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]<br>print(customersInLine.count)<br>// 打印出 “5”</p>
<p>let customerProvider = { customersInLine.remove(at: 0) }<br>print(customersInLine.count)<br>// 打印出 “5”</p>
<p>print(“Now serving (customerProvider())!”)<br>// Prints “Now serving Chris!”<br>print(customersInLine.count)<br>// 打印出 “4”<br>尽管在闭包的代码中，customersInLine 的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，customerProvider 的类型不是 String，而是 () -&gt; String，一个没有参数且返回值为 String 的函数。</p>
<p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。</p>
<p>// customersInLine is [“Alex”, “Ewa”, “Barry”, “Daniella”]<br>func serve(customer customerProvider: () -&gt; String) {<br>    print(“Now serving (customerProvider())!”)<br>}<br>serve(customer: { customersInLine.remove(at: 0) } )<br>// 打印出 “Now serving Alex!”<br>上面的 serve(customer:) 函数接受一个返回顾客名字的显式的闭包。下面这个版本的 serve(customer:) 完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 @autoclosure 来接收一个自动闭包。现在你可以将该函数当作接受 String 类型参数（而非闭包）的函数来调用。customerProvider 参数将自动转化为一个闭包，因为该参数被标记了 @autoclosure 特性。</p>
<p>// customersInLine is [“Ewa”, “Barry”, “Daniella”]<br>func serve(customer customerProvider: @autoclosure () -&gt; String) {<br>    print(“Now serving (customerProvider())!”)<br>}<br>serve(customer: customersInLine.remove(at: 0))<br>// 打印 “Now serving Ewa!”<br>注意 过度使用 autoclosures 会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
<p>如果你想让一个自动闭包可以“逃逸”，则应该同时使用 @autoclosure 和 @escaping 属性。@escaping 属性的讲解见上面的逃逸闭包。</p>
<p>// customersInLine i= [“Barry”, “Daniella”]<br>var customerProviders: [() -&gt; String] = []<br>func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) {<br>    customerProviders.append(customerProvider)<br>}<br>collectCustomerProviders(customersInLine.remove(at: 0))<br>collectCustomerProviders(customersInLine.remove(at: 0))</p>
<p>print(“Collected (customerProviders.count) closures.”)<br>// 打印 “Collected 2 closures.”<br>for customerProvider in customerProviders {<br>    print(“Now serving (customerProvider())!”)<br>}<br>// 打印 “Now serving Barry!”<br>// 打印 “Now serving Daniella!”<br>在上面的代码中，collectCustomerProviders(_:) 函数并没有调用传入的 customerProvider 闭包，而是将闭包追加到了 customerProviders 数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包能够在函数返回之后被调用。因此，customerProvider 参数必须允许“逃逸”出函数作用域。</p>
<p>枚举为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。</p>
<p>如果你熟悉 C 语言，你会知道在 C 语言中，枚举会为一组整型值分配相关联的名称。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p>
<p>此外，枚举成员可以指定任意类型的关联值存储到枚举成员中，就像其他语言中的联合体（unions）和变体（variants）。你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。</p>
<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多在传统上只被类（class）所支持的特性，例如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p>
<p>想了解更多相关信息，请参见属性，方法，构造过程，扩展和协议。</p>
<p>枚举语法<br>使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p>
<p>enum SomeEnumeration {<br>    // 枚举定义放在这里<br>}<br>下面是用枚举表示指南针四个方向的例子：</p>
<p>enum CompassPoint {<br>    case north<br>    case south<br>    case east<br>    case west<br>}<br>枚举中定义的值（如 north，south，east和west）是这个枚举的成员值（或成员）。你可以使用case关键字来定义一个新的枚举成员值。</p>
<p>注意<br>与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。</p>
<p>多个成员值可以出现在同一行上，用逗号隔开：</p>
<p>enum Planet {<br>    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune<br>}<br>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>
<p>var directionToHead = CompassPoint.west<br>directionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值：</p>
<p>directionToHead = .east<br>当directionToHead的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种写法让代码具有更好的可读性。</p>
<p>使用 Switch 语句匹配枚举值<br>你可以使用switch语句匹配单个枚举值：</p>
<p>directionToHead = .south<br>switch directionToHead {<br>    case .north:<br>        print(“Lots of planets have a north”)<br>    case .south:<br>        print(“Watch out for penguins”)<br>    case .east:<br>        print(“Where the sun rises”)<br>    case .west:<br>        print(“Where the skies are blue”)<br>}<br>// 打印 “Watch out for penguins”<br>你可以这样理解这段代码：</p>
<p>“判断directionToHead的值。当它等于.north，打印“Lots of planets have a north”。当它等于.south，打印“Watch out for penguins”。”</p>
<p>……以此类推。</p>
<p>正如在控制流中介绍的那样，在判断一个枚举类型的值时，switch语句必须穷举所有情况。如果忽略了.west这种情况，上面那段代码将无法通过编译，因为它没有考虑到CompassPoint的全部成员。强制穷举确保了枚举成员不会被意外遗漏。</p>
<p>当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：</p>
<p>let somePlanet = Planet.earth<br>switch somePlanet {<br>case .earth:<br>    print(“Mostly harmless”)<br>default:<br>    print(“Not a safe place for humans”)<br>}<br>// 打印 “Mostly harmless”</p>
<p>关联值<br>上一小节的例子演示了如何定义和分类枚举的成员。你可以为Planet.earth设置一个常量或者变量，并在赋值之后查看这个值。然而，有时候能够把其他类型的关联值和成员值一起存储起来会很有用。这能让你连同成员值一起存储额外的自定义信息，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值。</p>
<p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。</p>
<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用0到9的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：</p>
<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：</p>
<p>这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。</p>
<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：</p>
<p>enum Barcode {<br>    case upc(Int, Int, Int, Int)<br>    case qrCode(String)<br>}<br>以上代码可以这么理解：</p>
<p>“定义一个名为Barcode的枚举类型，它的一个成员值是具有(Int，Int，Int，Int)类型关联值的upc，另一个成员值是具有String类型关联值的qrCode。”</p>
<p>这个定义不提供任何Int或String类型的关联值，它只是定义了，当Barcode常量和变量等于Barcode.upc或Barcode.qrCode时，可以存储的关联值的类型。</p>
<p>然后可以使用任意一种条形码类型创建新的条形码，例如：</p>
<p>var productBarcode = Barcode.upc(8, 85909, 51226, 3)<br>上面的例子创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)。</p>
<p>同一个商品可以被分配一个不同类型的条形码，例如：</p>
<p>productBarcode = .qrCode(“ABCDEFGHIJKLMNOP”)<br>这时，原始的Barcode.upc和其整数关联值被新的Barcode.qrCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.upc或者一个.qrCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。</p>
<p>像先前那样，可以使用一个 switch 语句来检查不同的条形码类型。然而，这一次，关联值可以被提取出来作为 switch 语句的一部分。你可以在switch的 case 分支代码中提取每个关联值作为一个常量（用let前缀）或者作为一个变量（用var前缀）来使用：</p>
<p>switch productBarcode {<br>case .upc(let numberSystem, let manufacturer, let product, let check):<br>    print(“UPC: (numberSystem), (manufacturer), (product), (check).”)<br>case .qrCode(let productCode):<br>    print(“QR code: (productCode).”)<br>}<br>// 打印 “QR code: ABCDEFGHIJKLMNOP.”<br>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</p>
<p>switch productBarcode {<br>case let .upc(numberSystem, manufacturer, product, check):<br>    print(“UPC: (numberSystem), (manufacturer), (product), (check).”)<br>case let .qrCode(productCode):<br>    print(“QR code: (productCode).”)<br>}<br>// 输出 “QR code: ABCDEFGHIJKLMNOP.”</p>
<p>原始值<br>在关联值小节的条形码例子中，演示了如何声明存储不同类型关联值的枚举成员。作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。</p>
<p>这是一个使用 ASCII 码作为原始值的枚举：</p>
<p>enum ASCIIControlCharacter: Character {<br>    case tab = “\t”<br>    case lineFeed = “\n”<br>    case carriageReturn = “\r”<br>}<br>枚举类型ASCIIControlCharacter的原始值类型被定义为Character，并设置了一些比较常见的 ASCII 控制字符。Character的描述详见字符串和字符部分。</p>
<p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p>
<p>注意<br>原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p>
<p>原始值的隐式赋值<br>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p>
<p>例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。</p>
<p>下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：</p>
<p>enum Planet: Int {<br>    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune<br>}<br>在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。</p>
<p>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p>
<p>下面的例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称：</p>
<p>enum CompassPoint: String {<br>    case north, south, east, west<br>}<br>上面例子中，CompassPoint.south拥有隐式原始值south，依次类推。</p>
<p>使用枚举成员的rawValue属性可以访问该枚举成员的原始值：</p>
<p>let earthsOrder = Planet.earth.rawValue<br>// earthsOrder 值为 3</p>
<p>let sunsetDirection = CompassPoint.west.rawValue<br>// sunsetDirection 值为 “west”</p>
<p>使用原始值初始化枚举实例<br>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。</p>
<p>这个例子利用原始值7创建了枚举成员uranus：</p>
<p>let possiblePlanet = Planet(rawValue: 7)<br>// possiblePlanet 类型为 Planet? 值为 Planet.uranus<br>然而，并非所有Int值都可以找到一个匹配的行星。因此，原始值构造器总是返回一个可选的枚举成员。在上面的例子中，possiblePlanet是Planet?类型，或者说“可选的Planet”。</p>
<p>注意<br>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。更多信息请参见可失败构造器</p>
<p>如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：</p>
<p>let positionToFind = 11<br>if let somePlanet = Planet(rawValue: positionToFind) {<br>    switch somePlanet {<br>    case .earth:<br>        print(“Mostly harmless”)<br>    default:<br>        print(“Not a safe place for humans”)<br>    }<br>} else {<br>    print(“There isn’t a planet at position (positionToFind)”)<br>}<br>// 输出 “There isn’t a planet at position 11<br>这个例子使用了可选绑定（optional binding），试图通过原始值11来访问一个行星。if let somePlanet = Planet(rawValue: 11)语句创建了一个可选Planet，如果可选Planet的值存在，就会赋值给somePlanet。在这个例子中，无法检索到位置为11的行星，所以else分支被执行。</p>
<p>递归枚举<br>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。</p>
<p>例如，下面的例子中，枚举类型存储了简单的算术表达式：</p>
<p>enum ArithmeticExpression {<br>    case number(Int)<br>    indirect case addition(ArithmeticExpression, ArithmeticExpression)<br>    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)<br>}<br>你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：</p>
<p>indirect enum ArithmeticExpression {<br>    case number(Int)<br>    case addition(ArithmeticExpression, ArithmeticExpression)<br>    case multiplication(ArithmeticExpression, ArithmeticExpression)<br>}<br>上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) <em> 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) </em> 2</p>
<p>let five = ArithmeticExpression.number(5)<br>let four = ArithmeticExpression.number(4)<br>let sum = ArithmeticExpression.addition(five, four)<br>let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))<br>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>
<p>func evaluate(_ expression: ArithmeticExpression) -&gt; Int {<br>    switch expression {<br>    case let .number(value):<br>        return value<br>    case let .addition(left, right):<br>        return evaluate(left) + evaluate(right)<br>    case let .multiplication(left, right):<br>        return evaluate(left) * evaluate(right)<br>    }<br>}</p>
<p>print(evaluate(product))<br>// 打印 “18”<br>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>
<p>类和结构体是人们构建代码所用的一种通用且灵活的构造体。我们可以使用完全相同的语法规则来为类和结构体定义属性（常量、变量）和添加方法，从而扩展类和结构体的功能。</p>
<p>与其他编程语言所不同的是，Swift 并不要求你为自定义类和结构去创建独立的接口和实现文件。你所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。</p>
<p>注意<br>通常一个类的实例被称为对象。然而在 Swift 中，类和结构体的关系要比在其他语言中更加的密切，本章中所讨论的大部分功能都可以用在类和结构体上。因此，我们会主要使用实例。</p>
<p>类和结构体对比<br>Swift 中类和结构体有很多共同点。共同处在于：</p>
<p>定义属性用于存储值<br>定义方法用于提供功能<br>定义下标操作使得可以通过下标语法来访问实例所包含的值<br>定义构造器用于生成初始化值<br>通过扩展以增加默认实现的功能<br>实现协议以提供某种标准功能<br>更多信息请参见属性，方法，下标，构造过程，扩展，和协议。</p>
<p>与结构体相比，类还有如下的附加功能：</p>
<p>继承允许一个类继承另一个类的特征<br>类型转换允许在运行时检查和解释一个类实例的类型<br>析构器允许一个类实例释放任何其所被分配的资源<br>引用计数允许对一个类的多次引用<br>更多信息请参见继承，类型转换，析构过程，和自动引用计数。</p>
<p>注意<br>结构体总是通过被复制的方式在代码中传递，不使用引用计数。</p>
<p>定义语法<br>类和结构体有着类似的定义方式。我们通过关键字class和struct来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p>
<p>class SomeClass {<br>    // 在这里定义类<br>}<br>struct SomeStructure {<br>    // 在这里定义结构体<br>}<br>注意<br>在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。因此请使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准 Swift 类型的大写命名风格（如String，Int和Bool）。相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。</p>
<p>以下是定义结构体和定义类的示例：</p>
<p>struct Resolution {<br>    var width = 0<br>    var height = 0<br>}<br>class VideoMode {<br>    var resolution = Resolution()<br>    var interlaced = false<br>    var frameRate = 0.0<br>    var name: String?<br>}<br>在上面的示例中我们定义了一个名为Resolution的结构体，用来描述一个显示器的像素分辨率。这个结构体包含了两个名为width和height的存储属性。存储属性是被捆绑和存储在类或结构体中的常量或变量。当这两个属性被初始化为整数0的时候，它们会被推断为Int类型。</p>
<p>在上面的示例中我们还定义了一个名为VideoMode的类，用来描述一个视频显示器的特定模式。这个类包含了四个变量存储属性。第一个是分辨率，它被初始化为一个新的Resolution结构体的实例，属性类型被推断为Resolution。新VideoMode实例同时还会初始化其它三个属性，它们分别是，初始值为false的interlaced，初始值为0.0的frameRate，以及值为可选String的name。name属性会被自动赋予一个默认值nil，意为“没有name值”，因为它是一个可选类型。</p>
<p>类和结构体实例<br>Resolution结构体和VideoMode类的定义仅描述了什么是Resolution和VideoMode。它们并没有描述一个特定的分辨率（resolution）或者视频模式（video mode）。为了描述一个特定的分辨率或者视频模式，我们需要生成一个它们的实例。</p>
<p>生成结构体和类实例的语法非常相似：</p>
<p>let someResolution = Resolution()<br>let someVideoMode = VideoMode()<br>结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。构造过程章节会对类和结构体的初始化进行更详细的讨论。</p>
<p>属性访问<br>通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接：</p>
<p>print(“The width of someResolution is (someResolution.width)”)<br>// 打印 “The width of someResolution is 0”<br>在上面的例子中，someResolution.width引用someResolution的width属性，返回width的初始值0。</p>
<p>你也可以访问子属性，如VideoMode中Resolution属性的width属性：</p>
<p>print(“The width of someVideoMode is (someVideoMode.resolution.width)”)<br>// 打印 “The width of someVideoMode is 0”<br>你也可以使用点语法为变量属性赋值：</p>
<p>someVideoMode.resolution.width = 1280<br>print(“The width of someVideoMode is now (someVideoMode.resolution.width)”)<br>// 打印 “The width of someVideoMode is now 1280”<br>注意<br>与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了someVideoMode中resolution属性的width这个子属性，以上操作并不需要重新为整个resolution属性设置新值。</p>
<p>结构体类型的成员逐一构造器<br>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>
<p>let vga = Resolution(width:640, height: 480)<br>与结构体不同，类实例没有默认的成员逐一构造器。构造过程章节会对构造器进行更详细的讨论。</p>
<p>结构体和枚举是值类型<br>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。</p>
<p>在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p>
<p>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。</p>
<p>请看下面这个示例，其使用了前一个示例中的Resolution结构体：</p>
<p>let hd = Resolution(width: 1920, height: 1080)<br>var cinema = hd<br>在以上示例中，声明了一个名为hd的常量，其值为一个初始化为全高清视频分辨率（1920 像素宽，1080 像素高）的Resolution实例。</p>
<p>然后示例中又声明了一个名为cinema的变量，并将hd赋值给它。因为Resolution是一个结构体，所以cinema的值其实是hd的一个拷贝副本，而不是hd本身。尽管hd和cinema有着相同的宽（width）和高（height），但是在幕后它们是两个完全不同的实例。</p>
<p>下面，为了符合数码影院放映的需求（2048 像素宽，1080 像素高），cinema的width属性需要作如下修改：</p>
<p>cinema.width = 2048<br>这里，将会显示cinema的width属性确已改为了2048：</p>
<p>print(“cinema is now  (cinema.width) pixels wide”)<br>// 打印 “cinema is now 2048 pixels wide”<br>然而，初始的hd实例中width属性还是1920：</p>
<p>print(“hd is still (hd.width) pixels wide”)<br>// 打印 “hd is still 1920 pixels wide”<br>在将hd赋予给cinema的时候，实际上是将hd中所存储的值进行拷贝，然后将拷贝的数据存储到新的cinema实例中。结果就是两个完全独立的实例碰巧包含有相同的数值。由于两者相互独立，因此将cinema的width修改为2048并不会影响hd中的width的值。</p>
<p>枚举也遵循相同的行为准则：</p>
<p>enum CompassPoint {<br>    case North, South, East, West<br>}<br>var currentDirection = CompassPoint.West<br>let rememberedDirection = currentDirection<br>currentDirection = .East<br>if rememberedDirection == .West {<br>    print(“The remembered direction is still .West”)<br>}<br>// 打印 “The remembered direction is still .West”<br>上例中rememberedDirection被赋予了currentDirection的值，实际上它被赋予的是值的一个拷贝。赋值过程结束后再修改currentDirection的值并不影响rememberedDirection所储存的原始值的拷贝。</p>
<p>类是引用类型<br>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p>
<p>请看下面这个示例，其使用了之前定义的VideoMode类：</p>
<p>let tenEighty = VideoMode()<br>tenEighty.resolution = hd<br>tenEighty.interlaced = true<br>tenEighty.name = “1080i”<br>tenEighty.frameRate = 25.0<br>以上示例中，声明了一个名为tenEighty的常量，其引用了一个VideoMode类的新实例。在之前的示例中，这个视频模式（video mode）被赋予了HD分辨率（1920*1080）的一个拷贝（即hd实例）。同时设置为interlaced，命名为“1080i”。最后，其帧率是25.0帧每秒。</p>
<p>然后，tenEighty被赋予名为alsoTenEighty的新常量，同时对alsoTenEighty的帧率进行修改：</p>
<p>let alsoTenEighty = tenEighty<br>alsoTenEighty.frameRate = 30.0<br>因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。</p>
<p>下面，通过查看tenEighty的frameRate属性，我们会发现它正确的显示了所引用的VideoMode实例的新帧率，其值为30.0：</p>
<p>print(“The frameRate property of tenEighty is now (tenEighty.frameRate)”)<br>// 打印 “The frameRate property of theEighty is now 30.0”<br>需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。</p>
<p>恒等运算符<br>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>
<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>
<p>等价于（===）<br>不等价于（!==）<br>运用这两个运算符检测两个常量或者变量是否引用同一个实例：</p>
<p>if tenEighty === alsoTenEighty {<br>    print(“tenEighty and alsoTenEighty refer to the same Resolution instance.”)<br>}<br>//打印 “tenEighty and alsoTenEighty refer to the same Resolution instance.”<br>请注意，“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同：</p>
<p>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。<br>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。<br>当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准。在章节等价操作符中将会详细介绍实现自定义“等于”和“不等于”运算符的流程。</p>
<p>指针<br>如果你有 C，C++ 或者 Objective-C 语言的经验，那么你也许会知道这些语言使用指针来引用内存中的地址。一个引用某个引用类型实例的 Swift 常量或者变量，与 C 语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p>
<p>类和结构体的选择<br>在你的代码中，你可以使用类和结构体来定义你的自定义数据类型。</p>
<p>然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p>
<p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p>
<p>该数据结构的主要目的是用来封装少量相关简单数据值。<br>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。<br>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。<br>该数据结构不需要去继承另一个既有类型的属性或者行为。<br>举例来说，以下情境中适合使用结构体：</p>
<p>几何形状的大小，封装一个width属性和height属性，两者均为Double类型。<br>一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。<br>三维坐标系内一点，封装x，y和z属性，三者均为Double类型。<br>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p>
<p>字符串、数组、和字典类型的赋值与复制行为<br>Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>
<p>Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>
<p>注意<br>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p>
<p>属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>
<p>存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接作用于类型本身，这种属性称为类型属性。</p>
<p>另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>
<p>存储属性<br>简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字 var 定义），也可以是常量存储属性（用关键字 let 定义）。</p>
<p>可以在定义存储属性的时候指定默认值，请参考默认构造器一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考构造过程中常量属性的修改一节。</p>
<p>下面的例子定义了一个名为 FixedLengthRange 的结构体，该结构体用于描述整数的范围，且这个范围值在被创建后不能被修改.</p>
<p>struct FixedLengthRange {<br>    var firstValue: Int<br>    let length: Int<br>}<br>var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)<br>// 该区间表示整数0，1，2<br>rangeOfThreeItems.firstValue = 6<br>// 该区间现在表示整数6，7，8<br>FixedLengthRange 的实例包含一个名为 firstValue 的变量存储属性和一个名为 length 的常量存储属性。在上面的例子中，length 在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值。</p>
<p>常量结构体的存储属性<br>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：</p>
<p>let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)<br>// 该区间表示整数0，1，2，3<br>rangeOfFourItems.firstValue = 6<br>// 尽管 firstValue 是个变量属性，这里还是会报错<br>因为 rangeOfFourItems 被声明成了常量（用 let 关键字），即使 firstValue 是一个变量属性，也无法再修改它了。</p>
<p>这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>
<p>属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。</p>
<p>延迟存储属性<br>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标示一个延迟存储属性。</p>
<p>注意<br>必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>
<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。</p>
<p>下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码：</p>
<p>class DataImporter {<br>    /<em><br>    DataImporter 是一个负责将外部文件中的数据导入的类。<br>    这个类的初始化会消耗不少时间。
    </em>/<br>    var fileName = “data.txt”<br>    // 这里会提供数据导入功能<br>}</p>
<p>class DataManager {<br>    lazy var importer = DataImporter()<br>    var data = <a href="">String</a><br>    // 这里会提供数据管理功能<br>}</p>
<p>let manager = DataManager()<br>manager.data.append(“Some data”)<br>manager.data.append(“Some more data”)<br>// DataImporter 实例的 importer 属性还没有被创建<br>DataManager 类包含一个名为 data 的存储属性，初始值是一个空的字符串（String）数组。这里没有给出全部代码，只需知道 DataManager 类的目的是管理和提供对这个字符串数组的访问即可。</p>
<p>DataManager 的一个功能是从文件导入数据。该功能由 DataImporter 类提供，DataImporter 完成初始化需要消耗不少时间：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。</p>
<p>DataManager 管理数据时也可能不从文件中导入数据。所以当 DataManager 的实例被创建时，没必要创建一个 DataImporter 的实例，更明智的做法是第一次用到 DataImporter 的时候才去创建它。</p>
<p>由于使用了 lazy ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时：</p>
<p>print(manager.importer.fileName)<br>// DataImporter 实例的 importer 属性现在被创建了<br>// 输出 “data.txt”<br>注意<br>如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p>
<p>存储属性和实例变量<br>如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量作为属性值的后端存储。</p>
<p>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>
<p>计算属性<br>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<p>struct Point {<br>    var x = 0.0, y = 0.0<br>}<br>struct Size {<br>    var width = 0.0, height = 0.0<br>}<br>struct Rect {<br>    var origin = Point()<br>    var size = Size()<br>    var center: Point {<br>        get {<br>            let centerX = origin.x + (size.width / 2)<br>            let centerY = origin.y + (size.height / 2)<br>            return Point(x: centerX, y: centerY)<br>        }<br>        set(newCenter) {<br>            origin.x = newCenter.x - (size.width / 2)<br>            origin.y = newCenter.y - (size.height / 2)<br>        }<br>    }<br>}<br>var square = Rect(origin: Point(x: 0.0, y: 0.0),<br>    size: Size(width: 10.0, height: 10.0))<br>let initialSquareCenter = square.center<br>square.center = Point(x: 15.0, y: 15.0)<br>print(“square.origin is now at ((square.origin.x), (square.origin.y))”)<br>// 打印 “square.origin is now at (10.0, 10.0)”<br>这个例子定义了 3 个结构体来描述几何形状：</p>
<p>Point 封装了一个 (x, y) 的坐标<br>Size 封装了一个 width 和一个 height<br>Rect 表示一个有原点和尺寸的矩形<br>Rect也提供了一个名为center 的计算属性。一个矩形的中心点可以从原点（origin）和大小（size）算出，所以不需要将它以显式声明的 Point 来保存。Rect 的计算属性 center 提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>
<p>上述例子中创建了一个名为 square 的 Rect 实例，初始值原点是 (0, 0)，宽度高度都是 10。如下图中蓝色正方形所示。</p>
<p>square 的 center 属性可以通过点运算符（square.center）来访问，这会调用该属性的 getter 来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的 Point 来表示 square 的中心点。如代码所示，它正确返回了中心点 (5, 5)。</p>
<p>center 属性之后被设置了一个新的值 (15, 15)，表示向右上方移动正方形到如下图橙色正方形所示的位置。设置属性center的值会调用它的 setter 来修改属性 origin 的 x 和 y 的值，从而实现移动正方形到新的位置。</p>
<p>Computed Properties sample</p>
<p>简化 setter 声明<br>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue。下面是使用了简化 setter 声明的 Rect 结构体代码：</p>
<p>struct AlternativeRect {<br>    var origin = Point()<br>    var size = Size()<br>    var center: Point {<br>        get {<br>            let centerX = origin.x + (size.width / 2)<br>            let centerY = origin.y + (size.height / 2)<br>            return Point(x: centerX, y: centerY)<br>        }<br>        set {<br>            origin.x = newValue.x - (size.width / 2)<br>            origin.y = newValue.y - (size.height / 2)<br>        }<br>    }<br>}</p>
<p>只读计算属性<br>只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>
<p>注意<br>必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
<p>只读计算属性的声明可以去掉 get 关键字和花括号：</p>
<p>struct Cuboid {<br>    var width = 0.0, height = 0.0, depth = 0.0<br>    var volume: Double {<br>        return width <em> height </em> depth<br>    }<br>}<br>let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)<br>print(“the volume of fourByFiveByTwo is (fourByFiveByTwo.volume)”)<br>// 打印 “the volume of fourByFiveByTwo is 40.0”<br>这个例子定义了一个名为 Cuboid 的结构体，表示三维空间的立方体，包含 width、height 和 depth 属性。结构体还有一个名为 volume 的只读计算属性用来返回立方体的体积。为 volume 提供 setter 毫无意义，因为无法确定如何修改 width、height 和 depth 三者的值来匹配新的 volume。然而，Cuboid 提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>
<p>属性观察器<br>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>
<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。 属性重写请参考重写。</p>
<p>可以为属性添加如下的一个或全部观察器：</p>
<p>willSet 在新的值被设置之前调用<br>didSet 在新的值被设置之后立即调用<br>willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。</p>
<p>同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>
<p>注意<br>父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。 有关构造器代理的更多信息，请参考值类型的构造器代理和类的构造器代理规则。</p>
<p>下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 StepCounter 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>
<p>class StepCounter {<br>    var totalSteps: Int = 0 {<br>        willSet(newTotalSteps) {<br>            print(“About to set totalSteps to (newTotalSteps)”)<br>        }<br>        didSet {<br>            if totalSteps &gt; oldValue  {<br>                print(“Added (totalSteps - oldValue) steps”)<br>            }<br>        }<br>    }<br>}<br>let stepCounter = StepCounter()<br>stepCounter.totalSteps = 200<br>// About to set totalSteps to 200<br>// Added 200 steps<br>stepCounter.totalSteps = 360<br>// About to set totalSteps to 360<br>// Added 160 steps<br>stepCounter.totalSteps = 896<br>// About to set totalSteps to 896<br>// Added 536 steps<br>StepCounter 类定义了一个 Int 类型的属性 totalSteps，它是一个存储属性，包含 willSet 和 didSet 观察器。</p>
<p>当 totalSteps 被设置新值的时候，它的 willSet 和 didSet 观察器都会被调用，即使新值和当前值完全相同时也会被调用。</p>
<p>例子中的 willSet 观察器将表示新值的参数自定义为 newTotalSteps，这个观察器只是简单的将新的值输出。</p>
<p>didSet 观察器在 totalSteps 的值改变后被调用，它把新值和旧值进行对比，如果总步数增加了，就输出一个消息表示增加了多少步。didSet 没有为旧值提供自定义名称，所以默认值 oldValue 表示旧值的参数名。</p>
<p>注意</p>
<p>如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。关于 in-out 参数详细的介绍，请参考输入输出参数</p>
<p>全局变量和局部变量<br>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>
<p>前面章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</p>
<p>另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</p>
<p>注意<br>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。<br>局部范围的常量或变量从不延迟计算。</p>
<p>类型属性<br>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p>
<p>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。</p>
<p>类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>
<p>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</p>
<p>注意<br>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。</p>
<p>类型属性语法<br>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>
<p>使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</p>
<p>struct SomeStructure {<br>    static var storedTypeProperty = “Some value.”<br>    static var computedTypeProperty: Int {<br>        return 1<br>    }<br>}<br>enum SomeEnumeration {<br>    static var storedTypeProperty = “Some value.”<br>    static var computedTypeProperty: Int {<br>        return 6<br>    }<br>}<br>class SomeClass {<br>    static var storedTypeProperty = “Some value.”<br>    static var computedTypeProperty: Int {<br>        return 27<br>    }<br>    class var overrideableComputedTypeProperty: Int {<br>        return 107<br>    }<br>}<br>注意<br>例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。</p>
<p>获取和设置类型属性的值<br>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>
<p>print(SomeStructure.storedTypeProperty)<br>// 打印 “Some value.”<br>SomeStructure.storedTypeProperty = “Another value.”<br>print(SomeStructure.storedTypeProperty)<br>// 打印 “Another value.”<br>print(SomeEnumeration.computedTypeProperty)<br>// 打印 “6”<br>print(SomeClass.computedTypeProperty)<br>// 打印 “27”<br>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有 0 到 10 之间的整数音量。</p>
<p>下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是 0，没有一个灯会亮；当声道的音量是 10，所有灯点亮。本图中，左声道的音量是 9，右声道的音量是 7：</p>
<p>Static Properties VUMeter<br>上面所描述的声道模型使用 AudioChannel 结构体的实例来表示：</p>
<p>struct AudioChannel {<br>    static let thresholdLevel = 10<br>    static var maxInputLevelForAllChannels = 0<br>    var currentLevel: Int = 0 {<br>        didSet {<br>            if currentLevel &gt; AudioChannel.thresholdLevel {<br>                // 将当前音量限制在阈值之内<br>                currentLevel = AudioChannel.thresholdLevel<br>            }<br>            if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {<br>                // 存储当前音量作为新的最大输入音量<br>                AudioChannel.maxInputLevelForAllChannels = currentLevel<br>            }<br>        }<br>    }<br>}<br>结构 AudioChannel 定义了 2 个存储型类型属性来实现上述功能。第一个是 thresholdLevel，表示音量的最大上限阈值，它是一个值为 10 的常量，对所有实例都可见，如果音量高于 10，则取最大上限值 10（见后面描述）。</p>
<p>第二个类型属性是变量存储型属性 maxInputLevelForAllChannels，它用来表示所有 AudioChannel 实例的最大音量，初始值是0。</p>
<p>AudioChannel 也定义了一个名为 currentLevel 的存储型实例属性，表示当前声道现在的音量，取值为 0 到 10。</p>
<p>属性 currentLevel 包含 didSet 属性观察器来检查每次设置后的属性值，它做如下两个检查：</p>
<p>如果 currentLevel 的新值大于允许的阈值 thresholdLevel，属性观察器将 currentLevel 的值限定为阈值 thresholdLevel。<br>如果修正后的 currentLevel 值大于静态类型属性 maxInputLevelForAllChannels 的值，属性观察器就将新值保存在 maxInputLevelForAllChannels 中。<br>注意<br>在第一个检查过程中，didSet 属性观察器将 currentLevel 设置成了不同的值，但这不会造成属性观察器被再次调用。</p>
<p>可以使用结构体 AudioChannel 创建两个声道 leftChannel 和 rightChannel，用以表示立体声系统的音量：</p>
<p>var leftChannel = AudioChannel()<br>var rightChannel = AudioChannel()<br>如果将左声道的 currentLevel 设置成 7，类型属性 maxInputLevelForAllChannels 也会更新成 7：</p>
<p>leftChannel.currentLevel = 7<br>print(leftChannel.currentLevel)<br>// 输出 “7”<br>print(AudioChannel.maxInputLevelForAllChannels)<br>// 输出 “7”<br>如果试图将右声道的 currentLevel 设置成 11，它会被修正到最大值 10，同时 maxInputLevelForAllChannels 的值也会更新到 10：</p>
<p>rightChannel.currentLevel = 11<br>print(rightChannel.currentLevel)<br>// 输出 “10”<br>print(AudioChannel.maxInputLevelForAllChannels)<br>// 输出 “10”</p>
<p>本页包含内容：</p>
<p>实例方法<br>类型方法<br>方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</p>
<p>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。</p>
<p>实例方法 (Instance Methods)<br>实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致，详情参见函数。</p>
<p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p>
<p>下面的例子，定义一个很简单的Counter类，Counter能被用来对一个动作发生的次数进行计数：</p>
<p>class Counter {<br>    var count = 0<br>    func increment() {<br>        count += 1<br>    }<br>    func increment(by amount: Int) {<br>        count += amount<br>    }<br>    func reset() {<br>        count = 0<br>    }<br>}<br>Counter类定义了三个实例方法：</p>
<p>increment让计数器按一递增；<br>increment(by: Int)让计数器按一个指定的整数值递增；<br>reset将计数器重置为0。<br>Counter这个类还声明了一个可变属性count，用它来保持对当前计数器值的追踪。</p>
<p>和调用属性一样，用点语法（dot syntax）调用实例方法：</p>
<p>let counter = Counter()<br>// 初始计数值是0<br>counter.increment()<br>// 计数值现在是1<br>counter.increment(by: 5)<br>// 计数值现在是6<br>counter.reset()<br>// 计数值现在是0<br>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用），详情参见指定外部参数名。方法参数也一样，因为方法就是函数，只是这个函数与某个类型相关联了。</p>
<p>self 属性<br>类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。</p>
<p>上面例子中的increment方法还可以这样写：</p>
<p>func increment() {<br>    self.count += 1<br>}<br>实际上，你不必在你的代码里面经常写self。不论何时，只要在一个方法中使用一个已知的属性或者方法名称，如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。这种假定在上面的Counter中已经示范了：Counter中的三个实例方法中都使用的是count（而不是self.count）。</p>
<p>使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。</p>
<p>下面的例子中，self消除方法参数x和实例属性x之间的歧义：</p>
<p>struct Point {<br>    var x = 0.0, y = 0.0<br>    func isToTheRightOfX(x: Double) -&gt; Bool {<br>        return self.x &gt; x<br>    }<br>}<br>let somePoint = Point(x: 4.0, y: 5.0)<br>if somePoint.isToTheRightOfX(1.0) {<br>    print(“This point is to the right of the line where x == 1.0”)<br>}<br>// 打印 “This point is to the right of the line where x == 1.0”<br>如果不使用self前缀，Swift 就认为两次使用的x都指的是名称为x的函数参数。</p>
<p>在实例方法中修改值类型<br>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。</p>
<p>要使用可变方法，将关键字mutating 放到方法的func关键字之前就可以了：</p>
<p>struct Point {<br>    var x = 0.0, y = 0.0<br>    mutating func moveByX(deltaX: Double, y deltaY: Double) {<br>        x += deltaX<br>        y += deltaY<br>    }<br>}<br>var somePoint = Point(x: 1.0, y: 1.0)<br>somePoint.moveByX(2.0, y: 3.0)<br>print(“The point is now at ((somePoint.x), (somePoint.y))”)<br>// 打印 “The point is now at (3.0, 4.0)”<br>上面的Point结构体定义了一个可变方法 moveByX(_:y:) 来移动Point实例到给定的位置。该方法被调用时修改了这个点，而不是返回一个新的点。方法定义时加上了mutating关键字，从而允许修改属性。</p>
<p>注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性，详情参见常量结构体的存储属性：</p>
<p>let fixedPoint = Point(x: 3.0, y: 3.0)<br>fixedPoint.moveByX(2.0, y: 3.0)<br>// 这里将会报告一个错误</p>
<p>在可变方法中给 self 赋值<br>可变方法能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写：</p>
<p>struct Point {<br>    var x = 0.0, y = 0.0<br>    mutating func moveBy(x deltaX: Double, y deltaY: Double) {<br>        self = Point(x: x + deltaX, y: y + deltaY)<br>    }<br>}<br>新版的可变方法moveBy(x:y:)创建了一个新的结构体实例，它的 x 和 y 的值都被设定为目标值。调用这个版本的方法和调用上个版本的最终结果是一样的。</p>
<p>枚举的可变方法可以把self设置为同一枚举类型中不同的成员：</p>
<p>enum TriStateSwitch {<br>    case Off, Low, High<br>    mutating func next() {<br>        switch self {<br>        case .Off:<br>            self = .Low<br>        case .Low:<br>            self = .High<br>        case .High:<br>            self = .Off<br>        }<br>    }<br>}<br>var ovenLight = TriStateSwitch.Low<br>ovenLight.next()<br>// ovenLight 现在等于 .High<br>ovenLight.next()<br>// ovenLight 现在等于 .Off<br>上面的例子中定义了一个三态开关的枚举。每次调用next()方法时，开关在不同的电源状态（Off，Low，High）之间循环切换。</p>
<p>类型方法<br>实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字static，来指定类型方法。类还可以用关键字class来允许子类重写父类的方法实现。</p>
<p>注意<br>在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>
<p>类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。下面是如何在SomeClass类上调用类型方法的例子：</p>
<p>class SomeClass {<br>    class func someTypeMethod() {<br>        // 在这里实现类型方法<br>    }<br>}<br>SomeClass.someTypeMethod()<br>在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>
<p>一般来说，在类型方法的方法体中，任何未限定的方法和属性名称，可以被本类中其他的类型方法和类型属性引用。一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称。类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p>
<p>下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>
<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>
<p>struct LevelTracker {<br>    static var highestUnlockedLevel = 1<br>    var currentLevel = 1</p>
<pre><code>static func unlock(_ level: Int) {
    if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
}

static func isUnlocked(_ level: Int) -&gt; Bool {
    return level &lt;= highestUnlockedLevel
}

@discardableResult
mutating func advance(to level: Int) -&gt; Bool {
    if LevelTracker.isUnlocked(level) {
        currentLevel = level
        return true
    } else {
        return false
    }
}
</code></pre><p>}<br>LevelTracker监测玩家已解锁的最高等级。这个值被存储在类型属性highestUnlockedLevel中。</p>
<p>LevelTracker还定义了两个类型方法与highestUnlockedLevel配合工作。第一个类型方法是unlock(<em>:)，一旦新等级被解锁，它会更新highestUnlockedLevel的值。第二个类型方法是isUnlocked(</em>:)，如果某个给定的等级已经被解锁，它将返回true。（注意，尽管我们没有使用类似LevelTracker.highestUnlockedLevel的写法，这个类型方法还是能够访问类型属性highestUnlockedLevel）</p>
<p>除了类型属性和类型方法，LevelTracker还监测每个玩家的进度。它用实例属性currentLevel来监测每个玩家当前的等级。</p>
<p>为了便于管理currentLevel属性，LevelTracker定义了实例方法advance(to:)。这个方法会在更新currentLevel之前检查所请求的新等级是否已经解锁。advance(to:)方法返回布尔值以指示是否能够设置currentLevel。因为允许在调用advance(to:)时候忽略返回值，不会产生编译警告，所以函数被标注为@ discardableResult属性，更多关于属性信息，请参考属性章节。</p>
<p>下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：</p>
<p>class Player {<br>    var tracker = LevelTracker()<br>    let playerName: String<br>    func complete(level: Int) {<br>        LevelTracker.unlock(level + 1)<br>        tracker.advance(to: level + 1)<br>    }<br>    init(name: String) {<br>        playerName = name<br>    }<br>}<br>Player类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了advance(to:)返回的布尔值，因为之前调用LevelTracker.unlock(_:)时就知道了这个等级已经被解锁了）。</p>
<p>你还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：</p>
<p>var player = Player(name: “Argyrios”)<br>player.complete(level: 1)<br>print(“highest unlocked level is now (LevelTracker.highestUnlockedLevel)”)<br>// 打印 “highest unlocked level is now 2”<br>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>
<p>player = Player(name: “Beto”)<br>if player.tracker.advance(to: 6) {<br>    print(“player is now on level 6”)<br>} else {<br>    print(“level 6 has not yet been unlocked”)<br>}<br>// 打印 “level 6 has not yet been unlocked”</p>
<p>下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个Array实例中的元素可以写作someArray[index]，访问Dictionary实例中的元素可以写作someDictionary[key]。</p>
<p>一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求。</p>
<p>下标语法<br>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标使用subscript关键字，指定一个或多个输入参数和返回类型；与实例方法不同的是，下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>
<p>subscript(index: Int) -&gt; Int {<br>    get {<br>      // 返回一个适当的 Int 类型的值<br>    }</p>
<pre><code>set(newValue) {
  // 执行适当的赋值操作
}
</code></pre><p>}<br>newValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。</p>
<p>如同只读计算型属性，可以省略只读下标的get关键字：</p>
<p>subscript(index: Int) -&gt; Int {<br>    // 返回一个适当的 Int 类型的值<br>}<br>下面代码演示了只读下标的实现，这里定义了一个TimesTable结构体，用来表示传入整数的乘法表：</p>
<p>struct TimesTable {<br>    let multiplier: Int<br>    subscript(index: Int) -&gt; Int {<br>        return multiplier * index<br>    }<br>}<br>let threeTimesTable = TimesTable(multiplier: 3)<br>print(“six times three is (threeTimesTable[6])”)<br>// 打印 “six times three is 18”<br>在上例中，创建了一个TimesTable实例，用来表示整数3的乘法表。数值3被传递给结构体的构造函数，作为实例成员multiplier的值。</p>
<p>你可以通过下标访问threeTimesTable实例，例如上面演示的threeTimesTable[6]。这条语句查询了3的乘法表中的第六个元素，返回3的6倍即18。</p>
<p>注意<br>TimesTable例子基于一个固定的数学公式，对threeTimesTable[someIndex]进行赋值操作并不合适，因此下标定义为只读的。</p>
<p>下标用法<br>下标的确切含义取决于使用场景。下标通常作为访问集合，列表或序列中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标。</p>
<p>例如，Swift 的Dictionary类型实现下标用于对其实例中储存的值进行存取操作。为字典设值时，在下标中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标：</p>
<p>var numberOfLegs = [“spider”: 8, “ant”: 6, “cat”: 4]<br>numberOfLegs[“bird”] = 2<br>上例定义一个名为numberOfLegs的变量，并用一个包含三对键值的字典字面量初始化它。numberOfLegs字典的类型被推断为[String: Int]。字典创建完成后，该例子通过下标将String类型的键bird和Int类型的值2添加到字典中。</p>
<p>更多关于Dictionary下标的信息请参考读取和修改字典</p>
<p>注意<br>Swift 的Dictionary类型的下标接受并返回可选类型的值。上例中的numberOfLegs字典通过下标返回的是一个Int?或者说“可选的int”。Dictionary类型之所以如此实现下标，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。</p>
<p>下标选项<br>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。</p>
<p>一个类或结构体可以根据自身需要提供多个下标实现，使用下标时将通过入参的数量和类型进行区分，自动匹配合适的下标，这就是下标的重载。</p>
<p>虽然接受单一入参的下标是最常见的，但也可以根据情况定义接受多个入参的下标。例如下例定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵。Matrix结构体的下标接受两个整型参数：</p>
<p>struct Matrix {<br>    let rows: Int, columns: Int<br>    var grid: [Double]<br>    init(rows: Int, columns: Int) {<br>        self.rows = rows<br>        self.columns = columns<br>        grid = Array(count: rows <em> columns, repeatedValue: 0.0)<br>    }<br>    func indexIsValid(row: Int, column: Int) -&gt; Bool {<br>        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns<br>    }<br>    subscript(row: Int, column: Int) -&gt; Double {<br>        get {<br>            assert(indexIsValid(row: row, column: column), “Index out of range”)<br>            return grid[(row </em> columns) + column]<br>        }<br>        set {<br>            assert(indexIsValid(row: row, column: column), “Index out of range”)<br>            grid[(row <em> columns) + column] = newValue<br>        }<br>    }<br>}<br>Matrix提供了一个接受两个入参的构造方法，入参分别是rows和columns，创建了一个足够容纳rows </em> columns个Double类型的值的数组。通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0。关于数组的这种构造方法请参考创建一个空数组。</p>
<p>你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：</p>
<p>var matrix = Matrix(rows: 2, columns: 2)<br>上例中创建了一个Matrix实例来表示两行两列的矩阵。该Matrix实例的grid数组按照从左上到右下的阅读顺序将矩阵扁平化存储：</p>
<p>将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p>
<p>matrix[0, 1] = 1.5<br>matrix[1, 0] = 3.2<br>上面两条语句分别调用下标的 setter 将矩阵右上角位置（即row为0、column为1的位置）的值设置为1.5，将矩阵左下角位置（即row为1、column为0的位置）的值设置为3.2：</p>
<p>Matrix下标的 getter 和 setter 中都含有断言，用来检查下标入参row和column的值是否有效。为了方便进行断言，Matrix包含了一个名为indexIsValid(row:column:)的便利方法，用来检查入参row和column的值是否在矩阵范围内：</p>
<p>func indexIsValid(row: Int, column: Int) -&gt; Bool {<br>    return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns<br>}<br>断言在下标越界时触发：</p>
<p>let someValue = matrix[2, 2]<br>// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</p>
<p>一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>
<p>在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>
<p>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>
<p>定义一个基类<br>不继承于其它类的类，称之为基类。</p>
<p>注意<br>Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>
<p>下面的例子定义了一个叫Vehicle的基类。这个基类声明了一个名为currentSpeed，默认值是0.0的存储属性（属性类型推断为Double）。currentSpeed属性的值被一个String类型的只读计算型属性description使用，用来创建车辆的描述。</p>
<p>Vehicle基类也定义了一个名为makeNoise的方法。这个方法实际上不为Vehicle实例做任何事，但之后将会被Vehicle的子类定制：</p>
<p>class Vehicle {<br>    var currentSpeed = 0.0<br>    var description: String {<br>        return “traveling at (currentSpeed) miles per hour”<br>    }<br>    func makeNoise() {<br>        // 什么也不做-因为车辆不一定会有噪音<br>    }<br>}<br>您可以用初始化语法创建一个Vehicle的新实例，即类名后面跟一个空括号：</p>
<p>let someVehicle = Vehicle()<br>现在已经创建了一个Vehicle的新实例，你可以访问它的description属性来打印车辆的当前速度：</p>
<p>print(“Vehicle: (someVehicle.description)”)<br>// 打印 “Vehicle: traveling at 0.0 miles per hour”<br>Vehicle类定义了一个通用特性的车辆类，实际上没什么用处。为了让它变得更加有用，需要完善它从而能够描述一个更加具体类型的车辆。</p>
<p>子类生成<br>子类生成指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>
<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>
<p>class SomeClass: SomeSuperclass {<br>    // 这里是子类的定义<br>}<br>下一个例子，定义一个叫Bicycle的子类，继承成父类Vehicle：</p>
<p>class Bicycle: Vehicle {<br>    var hasBasket = false<br>}<br>新的Bicycle类自动获得Vehicle类的所有特性，比如currentSpeed和description属性，还有它的makeNoise()方法。</p>
<p>除了它所继承的特性，Bicycle类还定义了一个默认值为false的存储型属性hasBasket（属性推断为Bool）。</p>
<p>默认情况下，你创建任何新的Bicycle实例将不会有一个篮子（即hasBasket属性默认为false），创建该实例之后，你可以为特定的Bicycle实例设置hasBasket属性为ture：</p>
<p>let bicycle = Bicycle()<br>bicycle.hasBasket = true<br>你还可以修改Bicycle实例所继承的currentSpeed属性，和查询实例所继承的description属性：</p>
<p>bicycle.currentSpeed = 15.0<br>print(“Bicycle: (bicycle.description)”)<br>// 打印 “Bicycle: traveling at 15.0 miles per hour”<br>子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：</p>
<p>class Tandem: Bicycle {<br>    var currentNumberOfPassengers = 0<br>}<br>Tandem从Bicycle继承了所有的属性与方法，这又使它同时继承了Vehicle的所有属性与方法。Tandem也增加了一个新的叫做currentNumberOfPassengers的存储型属性，默认值为0。</p>
<p>如果你创建了一个Tandem的实例，你可以使用它所有的新属性和继承的属性，还能查询从Vehicle继承来的只读属性description：</p>
<p>let tandem = Tandem()<br>tandem.hasBasket = true<br>tandem.currentNumberOfPassengers = 2<br>tandem.currentSpeed = 22.0<br>print(“Tandem: (tandem.description)”)<br>// 打印：”Tandem: traveling at 22.0 miles per hour”</p>
<p>重写<br>子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。我们把这种行为叫重写。</p>
<p>如果要重写某个特性，你需要在重写定义的前面加上override关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少override关键字的重写都会在编译时被诊断为错误。</p>
<p>override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>
<p>访问超类的方法，属性及下标<br>当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>
<p>在合适的地方，你可以通过使用super前缀来访问超类版本的方法，属性或下标：</p>
<p>在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。<br>在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。<br>在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。<br>重写方法<br>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>
<p>下面的例子定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法：</p>
<p>class Train: Vehicle {<br>    override func makeNoise() {<br>        print(“Choo Choo”)<br>    }<br>}<br>如果你创建一个Train的新实例，并调用了它的makeNoise()方法，你就会发现Train版本的方法被调用：</p>
<p>let train = Train()<br>train.makeNoise()<br>// 打印 “Choo Choo”<br>重写属性<br>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>
<p>重写属性的 Getters 和 Setters<br>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>
<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>
<p>注意<br>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。</p>
<p>以下的例子定义了一个新类，叫Car，它是Vehicle的子类。这个类引入了一个新的存储型属性叫做gear，默认值为整数1。Car类重写了继承自Vehicle的description属性，提供包含当前档位的自定义描述：</p>
<p>class Car: Vehicle {<br>    var gear = 1<br>    override var description: String {<br>        return super.description + “ in gear (gear)”<br>    }<br>}<br>重写的description属性首先要调用super.description返回Vehicle类的description属性。之后，Car类版本的description在末尾增加了一些额外的文本来提供关于当前档位的信息。</p>
<p>如果你创建了Car的实例并且设置了它的gear和currentSpeed属性，你可以看到它的description返回了Car中的自定义描述：</p>
<p>let car = Car()<br>car.currentSpeed = 25.0<br>car.gear = 3<br>print(“Car: (car.description)”)<br>// 打印 “Car: traveling at 25.0 miles per hour in gear 3”</p>
<p>重写属性观察器<br>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。关于属性观察器的更多内容，请看属性观察器。</p>
<p>注意<br>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。<br>此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
<p>下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</p>
<p>class AutomaticCar: Car {<br>    override var currentSpeed: Double {<br>        didSet {<br>            gear = Int(currentSpeed / 10.0) + 1<br>        }<br>    }<br>}<br>当你设置AutomaticCar的currentSpeed属性，属性的didSet观察器就会自动地设置gear属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以10，然后向下取得最接近的整数值，最后加1来得到档位gear的值。例如，速度为35.0时，挡位为4：</p>
<p>let automatic = AutomaticCar()<br>automatic.currentSpeed = 35.0<br>print(“AutomaticCar: (automatic.description)”)<br>// 打印 “AutomaticCar: traveling at 35.0 miles per hour in gear 4”</p>
<p>防止重写<br>你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可（例如：final var，final func，final class func，以及final subscript）。</p>
<p>如果你重写了带有final标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final 的。</p>
<p>你可以通过在关键字class前添加final修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>
<p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。</p>
<p>通过定义构造器来实现构造过程，就像用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>
<p>类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作。想了解更多关于析构器的内容，请参考析构过程。</p>
<p>存储属性的初始赋值<br>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>
<p>你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。以下小节将详细介绍这两种方法。</p>
<p>注意<br>当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。</p>
<p>构造器<br>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字 init 命名：</p>
<p>init() {<br>    // 在此处执行构造过程<br>}<br>下面例子中定义了一个用来保存华氏温度的结构体 Fahrenheit，它拥有一个 Double 类型的存储型属性 temperature：</p>
<p>struct Fahrenheit {<br>    var temperature: Double<br>    init() {<br>        temperature = 32.0<br>    }<br>}<br>var f = Fahrenheit()<br>print(“The default temperature is (f.temperature)° Fahrenheit”)<br>// 打印 “The default temperature is 32.0° Fahrenheit”<br>这个结构体定义了一个不带参数的构造器 init，并在里面将存储型属性 temperature 的值初始化为 32.0（华氏温度下水的冰点）。</p>
<p>默认属性值<br>如前所述，你可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值。</p>
<p>注意<br>如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性，后续章节将讲到。</p>
<p>你可以使用更简单的方式在定义结构体 Fahrenheit 时为属性 temperature 设置默认值：</p>
<p>struct Fahrenheit {<br>    var temperature = 32.0<br>}</p>
<p>自定义构造过程<br>你可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中给常量属性赋初值。这些都将在后面章节中提到。</p>
<p>构造参数<br>自定义构造过程时，可以在定义中提供构造参数，指定参数值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。</p>
<p>下面例子中定义了一个包含摄氏度温度的结构体 Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：</p>
<p>struct Celsius {<br>    var temperatureInCelsius: Double<br>    init(fromFahrenheit fahrenheit: Double) {<br>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8<br>    }<br>    init(fromKelvin kelvin: Double) {<br>        temperatureInCelsius = kelvin - 273.15<br>    }<br>}</p>
<p>let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)<br>// boilingPointOfWater.temperatureInCelsius 是 100.0<br>let freezingPointOfWater = Celsius(fromKelvin: 273.15)<br>// freezingPointOfWater.temperatureInCelsius 是 0.0<br>第一个构造器拥有一个构造参数，其外部名字为fromFahrenheit，内部名字为fahrenheit；第二个构造器也拥有一个构造参数，其外部名字为fromKelvin，内部名字为kelvin。这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性 temperatureInCelsius 中。</p>
<p>参数的内部名称和外部名称<br>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>
<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。</p>
<p>以下例子中定义了一个结构体 Color，它包含了三个常量：red、green 和 blue。这些属性可以存储 0.0 到 1.0 之间的值，用来指示颜色中红、绿、蓝成分的含量。</p>
<p>Color 提供了一个构造器，其中包含三个Double类型的构造参数。Color 也提供了第二个构造器，它只包含名为white 的 Double 类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>
<p>struct Color {<br>    let red, green, blue: Double<br>    init(red: Double, green: Double, blue: Double) {<br>        self.red   = red<br>        self.green = green<br>        self.blue  = blue<br>    }<br>    init(white: Double) {<br>        red   = white<br>        green = white<br>        blue  = white<br>    }<br>}<br>两种构造器都能通过提供的初始参数值来创建一个新的Color实例：</p>
<p>let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)<br>let halfGray = Color(white: 0.5)<br>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>
<p>let veryGreen = Color(0.0, 1.0, 0.0)<br>// 报编译时错误，需要外部名称</p>
<p>不带外部名的构造器参数<br>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为。</p>
<p>下面是之前 Celsius 例子的扩展，跟之前相比添加了一个带有 Double 类型参数的构造器，其外部名用 _ 代替：</p>
<p>struct Celsius {<br>    var temperatureInCelsius: Double<br>    init(fromFahrenheit fahrenheit: Double) {<br>        temperatureInCelsius = (fahrenheit - 32.0) / 1.8<br>    }<br>    init(fromKelvin kelvin: Double) {<br>        temperatureInCelsius = kelvin - 273.15<br>    }<br>    init(_ celsius: Double){<br>        temperatureInCelsius = celsius<br>    }<br>}</p>
<p>let bodyTemperature = Celsius(37.0)<br>// bodyTemperature.temperatureInCelsius 为 37.0<br>调用 Celsius(37.0) 意图明确，不需要外部参数名称。因此适合使用 init(_ celsius: Double) 这样的构造器，从而可以通过提供 Double 类型的参数值调用构造器，而不需要加上外部名。</p>
<p>可选属性类型<br>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为可选类型。可选类型的属性将自动初始化为 nil，表示这个属性是有意在初始化时设置为空的。</p>
<p>下面例子中定义了类 SurveyQuestion，它包含一个可选字符串属性 response：</p>
<p>class SurveyQuestion {<br>    var text: String<br>    var response: String?<br>    init(text: String) {<br>        self.text = text<br>    }<br>    func ask() {<br>        print(text)<br>    }<br>}</p>
<p>let cheeseQuestion = SurveyQuestion(text: “Do you like cheese?”)<br>cheeseQuestion.ask()<br>// 打印 “Do you like cheese?”<br>cheeseQuestion.response = “Yes, I do like cheese.”<br>调查问题的答案在回答前是无法确定的，因此我们将属性 response 声明为 String? 类型，或者说是可选字符串类型。当 SurveyQuestion 实例化时，它将自动赋值为nil，表明此字符串暂时还没有值。</p>
<p>构造过程中常量属性的赋值<br>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>
<p>注意<br>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
<p>你可以修改上面的 SurveyQuestion 示例，用常量属性替代变量属性 text，表示问题内容 text 在SurveyQuestion的实例被创建之后不会再被修改。尽管 text 属性现在是常量，我们仍然可以在类的构造器中设置它的值：</p>
<p>class SurveyQuestion {<br>    let text: String<br>    var response: String?<br>    init(text: String) {<br>        self.text = text<br>    }<br>    func ask() {<br>        print(text)<br>    }<br>}<br>let beetsQuestion = SurveyQuestion(text: “How about beets?”)<br>beetsQuestion.ask()<br>// 打印 “How about beets?”<br>beetsQuestion.response = “I also like beets. (But not with cheese.)”</p>
<p>默认构造器<br>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>
<p>下面例子中创建了一个类 ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：</p>
<p>class ShoppingListItem {<br>    var name: String?<br>    var quantity = 1<br>    var purchased = false<br>}<br>var item = ShoppingListItem()<br>由于 ShoppingListItem 类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为name属性设置默认值，但由于name是可选字符串类型，它将默认设置为nil）。上面例子中使用默认构造器创造了一个 ShoppingListItem 类的实例（使用 ShoppingListItem() 形式的构造器语法），并将其赋值给变量 item。</p>
<p>结构体的逐一成员构造器<br>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>
<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>
<p>下面例子中定义了一个结构体 Size，它包含两个属性 width 和 height。Swift 可以根据这两个属性的初始赋值0.0 自动推导出它们的类型为 Double。</p>
<p>结构体 Size 自动获得了一个逐一成员构造器 init(width:height:)。你可以用它来创建新的 Size 实例：</p>
<p>struct Size {<br>    var width = 0.0, height = 0.0<br>}<br>let twoByTwo = Size(width: 2.0, height: 2.0)</p>
<p>值类型的构造器代理<br>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能避免多个构造器间的代码重复。</p>
<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类（请参考继承），这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。这些责任将在后续章节类的继承和构造过程中介绍。</p>
<p>对于值类型，你可以使用 self.init 在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用 self.init。</p>
<p>请注意，如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用自动生成的构造器</p>
<p>注意<br>假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。想查看更多内容，请查看扩展章节。</p>
<p>下面例子将定义一个结构体 Rect，用来代表几何矩形。这个例子需要两个辅助的结构体 Size 和 Point，它们各自为其所有的属性提供了默认初始值 0.0。</p>
<p>struct Size {<br>    var width = 0.0, height = 0.0<br>}</p>
<p>struct Point {<br>    var x = 0.0, y = 0.0<br>}<br>你可以通过以下三种方式为 Rect 创建实例——使用含有默认值的 origin 和 size 属性来初始化；提供指定的origin 和 size 实例来初始化；提供指定的 center 和 size 来初始化。在下面 Rect 结构体定义中，我们为这三种方式提供了三个自定义的构造器：</p>
<p>struct Rect {<br>    var origin = Point()<br>    var size = Size()<br>    init() {}</p>
<pre><code>init(origin: Point, size: Size) {
    self.origin = origin
    self.size = size
}

init(center: Point, size: Size) {
    let originX = center.x - (size.width / 2)
    let originY = center.y - (size.height / 2)
    self.init(origin: Point(x: originX, y: originY), size: size)
}
</code></pre><p>}<br>第一个 Rect 构造器 init()，在功能上跟没有自定义构造器时自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号 {} 来表示。调用这个构造器将返回一个 Rect 实例，它的 origin 和 size 属性都使用定义时的默认值 Point(x: 0.0, y: 0.0) 和 Size(width: 0.0, height: 0.0)：</p>
<p>let basicRect = Rect()<br>// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)<br>第二个 Rect 构造器 init(origin:size:)，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单地将 origin 和 size 的参数值赋给对应的存储型属性：</p>
<p>let originRect = Rect(origin: Point(x: 2.0, y: 2.0),<br>    size: Size(width: 5.0, height: 5.0))<br>// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)<br>第三个 Rect 构造器 init(center:size:) 稍微复杂一点。它先通过 center 和 size 的值计算出 origin 的坐标，然后再调用（或者说代理给）init(origin:size:) 构造器来将新的 origin 和 size 值赋值到对应的属性中：</p>
<p>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),<br>    size: Size(width: 3.0, height: 3.0))<br>// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)<br>构造器 init(center:size:) 可以直接将 origin 和 size 的新值赋值到对应的属性中。然而，构造器 init(center:size:) 通过使用提供了相关功能的现有构造器将会更加便捷。</p>
<p>注意<br>如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，请参考扩展。</p>
<p>类的继承和构造过程<br>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</p>
<p>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>
<p>指定构造器和便利构造器<br>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类合适的构造器来实现父类的初始化。</p>
<p>类倾向于拥有少量指定构造器，普遍的是一个类拥有一个指定构造器。指定构造器在初始化的地方通过 “管道” 将初始化过程持续到父类链。</p>
<p>每一个类都必须至少拥有一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节构造器的自动继承。</p>
<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>
<p>你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>
<p>指定构造器和便利构造器的语法<br>类的指定构造器的写法跟值类型简单构造器一样：</p>
<p>init(parameters) {<br>    statements<br>}<br>便利构造器也采用相同样式的写法，但需要在 init 关键字之前放置 convenience 关键字，并使用空格将它们俩分开：</p>
<p>convenience init(parameters) {<br>    statements<br>}</p>
<p>类的构造器代理规则<br>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>
<p>规则 1<br>指定构造器必须调用其直接父类的的指定构造器。</p>
<p>规则 2<br>便利构造器必须调用同类中定义的其它构造器。</p>
<p>规则 3<br>便利构造器最后必须调用指定构造器。</p>
<p>一个更方便记忆的方法是：</p>
<p>指定构造器必须总是向上代理<br>便利构造器必须总是横向代理<br>这些规则可以通过下面图例来说明：</p>
<p>构造器代理图</p>
<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到的规则 2 和 3。这个父类没有自己的父类，所以规则 1 没有用到。</p>
<p>子类中包含两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的任意一个，因为它只能调用同一个类里的其他构造器。这满足了上面提到的规则 2 和 3。而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则 1。</p>
<p>注意<br>这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类的构造器如何实现。</p>
<p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。</p>
<p>复杂构造器代理图</p>
<p>两段式构造过程<br>Swift 中类的构造过程包含两个阶段。第一个阶段，类中的每个存储型属性赋一个初始值。当每个存储型属性的初始值被赋值后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</p>
<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>
<p>注意<br>Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值 0 或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以 0 或 nil 作为合法默认值的情况。</p>
<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程不出错地完成：</p>
<p>安全检查 1<br>指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</p>
<p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类的属性在它往上代理之前先完成初始化。</p>
<p>安全检查 2<br>指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器，如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>
<p>安全检查 3<br>便利构造器必须为任意属性（包括同类中定义的）赋新值之前代理调用同一类中的其它构造器，如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</p>
<p>安全检查 4<br>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</p>
<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。</p>
<p>以下是两段式构造过程中基于上述安全检查的构造流程展示：</p>
<p>阶段 1<br>某个指定构造器或便利构造器被调用。<br>完成新实例内存的分配，但此时内存还没有被初始化。<br>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。<br>指定构造器将调用父类的构造器，完成父类属性的初始化。<br>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。<br>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。<br>阶段 2<br>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问 self、修改它的属性并调用实例方法等等。<br>最终，任意构造器链中的便利构造器可以有机会定制实例和使用 self。<br>下图展示了在假定的子类和父类之间的构造阶段 1：</p>
<p>构建过程阶段1</p>
<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>
<p>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。</p>
<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>
<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。</p>
<p>以下展示了相同构造过程的阶段 2：</p>
<p>构建过程阶段2</p>
<p>父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。</p>
<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。</p>
<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>
<p>构造器的继承和重写<br>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。</p>
<p>注意<br>父类的构造器仅会在安全和适当的情况下被继承。具体内容请参考后续章节构造器的自动继承。</p>
<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 override 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上 override 修饰符，具体内容请参考默认构造器。</p>
<p>正如重写属性，方法或者是下标，override 修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>
<p>注意<br>当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使是为了实现子类的便利构造器。</p>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述），因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加 override 修饰符。</p>
<p>在下面的例子中定义了一个叫 Vehicle 的基类。基类中声明了一个存储型属性 numberOfWheels，它是默认值为 0 的 Int 类型的存储型属性。numberOfWheels 属性用于创建名为 descrpiption 的 String 类型的计算型属性：</p>
<p>class Vehicle {<br>    var numberOfWheels = 0<br>    var description: String {<br>        return “(numberOfWheels) wheel(s)”<br>    }<br>}<br>Vehicle 类只为存储型属性提供默认值，也没有提供自定义构造器。因此，它会自动获得一个默认构造器，具体内容请参考默认构造器。自动获得的默认构造器总是类中的指定构造器，它可以用于创建numberOfWheels 为 0 的 Vehicle 实例：</p>
<p>let vehicle = Vehicle()<br>print(“Vehicle: (vehicle.description)”)<br>// Vehicle: 0 wheel(s)<br>下面例子中定义了一个 Vehicle 的子类 Bicycle：</p>
<p>class Bicycle: Vehicle {<br>    override init() {<br>        super.init()<br>        numberOfWheels = 2<br>    }<br>}<br>子类 Bicycle 定义了一个自定义指定构造器 init()。这个指定构造器和父类的指定构造器相匹配，所以 Bicycle 中的指定构造器需要带上 override 修饰符。</p>
<p>Bicycle 的构造器 init() 以调用 super.init() 方法开始，这个方法的作用是调用 Bicycle 的父类Vehicle 的默认构造器。这样可以确保 Bicycle 在修改属性之前，它所继承的属性 numberOfWheels 能被 Vehicle 类初始化。在调用 super.init() 之后，属性 numberOfWheels 的原值被新值 2 替换。</p>
<p>如果你创建一个 Bicycle 实例，你可以调用继承的 description 计算型属性去查看属性 numberOfWheels 是否有改变：</p>
<p>let bicycle = Bicycle()<br>print(“Bicycle: (bicycle.description)”)<br>// 打印 “Bicycle: 2 wheel(s)”<br>注意<br>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</p>
<p>构造器的自动继承<br>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。事实上，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：</p>
<p>规则 1<br>如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</p>
<p>规则 2<br>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承父类所有的便利构造器。</p>
<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<p>注意<br>对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>
<p>指定构造器和便利构造器实践<br>接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类 Food、RecipeIngredient 以及 ShoppingListItem 的类层次结构，并将演示它们的构造器是如何相互作用的。</p>
<p>类层次中的基类是 Food，它是一个简单的用来封装食物名字的类。Food 类引入了一个叫做 name 的 String 类型的属性，并且提供了两个构造器来创建Food实例：</p>
<p>class Food {<br>    var name: String<br>    init(name: String) {<br>        self.name = name<br>    }</p>
<pre><code>convenience init() {
    self.init(name: &quot;[Unnamed]&quot;)
}
</code></pre><p>}<br>下图中展示了 Food 的构造器链：</p>
<p>Food构造器链</p>
<p>类类型没有默认的逐一成员构造器，所以 Food 类提供了一个接受单一参数 name 的指定构造器。这个构造器可以使用一个特定的名字来创建新的 Food 实例：</p>
<p>let namedMeat = Food(name: “Bacon”)<br>// namedMeat 的名字是 “Bacon”<br>Food 类中的构造器 init(name: String) 被定义为一个指定构造器，因为它能确保 Food 实例的所有存储型属性都被初始化。Food 类没有父类，所以 init(name: String) 构造器不需要调用 super.init() 来完成构造过程。</p>
<p>Food 类同样提供了一个没有参数的便利构造器 init()。这个 init() 构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器 init(name: String) 并给参数 name 赋值为 [Unnamed] 来实现：</p>
<p>let mysteryMeat = Food()<br>// mysteryMeat 的名字是 [Unnamed]<br>类层级中的第二个类是 Food 的子类 RecipeIngredient。RecipeIngredient 类用来表示食谱中的一项原料。它引入了 Int 类型的属性 quantity（以及从 Food 继承过来的 name 属性），并且定义了两个构造器来创建RecipeIngredient 实例：</p>
<p>class RecipeIngredient: Food {<br>    var quantity: Int<br>    init(name: String, quantity: Int) {<br>        self.quantity = quantity<br>        super.init(name: name)<br>    }<br>    override convenience init(name: String) {<br>        self.init(name: name, quantity: 1)<br>    }<br>}<br>下图中展示了 RecipeIngredient 类的构造器链：</p>
<p>RecipeIngredient构造器</p>
<p>RecipeIngredient 类拥有一个指定构造器 init(name: String, quantity: Int)，它可以用来填充RecipeIngredient 实例的所有属性值。这个构造器一开始先将传入的 quantity 参数赋值给 quantity 属性，这个属性也是唯一在 RecipeIngredient 中新引入的属性。随后，构造器向上代理到父类 Food 的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。</p>
<p>RecipeIngredient 也定义了一个便利构造器 init(name: String)，它只通过 name 来创建 RecipeIngredient 的实例。这个便利构造器假设任意 RecipeIngredient 实例的 quantity 为 1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity 为 1 的 RecipeIngredient 实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为 quantity 参数传递 1。</p>
<p>注意，RecipeIngredient 的便利构造器 init(name: String) 使用了跟 Food 中指定构造器 init(name: String) 相同的参数。由于这个便利构造器重写了父类的指定构造器 init(name: String)，因此必须在前面使用 override 修饰符（参见构造器的继承和重写）。</p>
<p>尽管 RecipeIngredient 将父类的指定构造器重写为了便利构造器，但是它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient 会自动继承父类的所有便利构造器。</p>
<p>在这个例子中，RecipeIngredient 的父类是 Food，它有一个便利构造器 init()。这个便利构造器会被RecipeIngredient 继承。这个继承版本的 init() 在功能上跟 Food 提供的版本是一样的，只是它会代理到RecipeIngredient 版本的 init(name: String) 而不是 Food 提供的版本。</p>
<p>所有的这三种构造器都可以用来创建新的 RecipeIngredient实例：</p>
<p>let oneMysteryItem = RecipeIngredient()<br>let oneBacon = RecipeIngredient(name: “Bacon”)<br>let sixEggs = RecipeIngredient(name: “Eggs”, quantity: 6)<br>类层级中第三个也是最后一个类是 RecipeIngredient 的子类，叫做 ShoppingListItem。这个类构建了购物单中出现的某一种食谱原料。</p>
<p>购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem 引入了一个 Boolean（布尔类型） 的属性 purchased，它的默认值是 false。ShoppingListItem 还添加了一个计算型属性 description，它提供了关于 ShoppingListItem 实例的一些文字描述：</p>
<p>class ShoppingListItem: RecipeIngredient {<br>    var purchased = false<br>    var description: String {<br>        var output = “(quantity) x (name)”<br>        output += purchased ? “ ✔” : “ ✘”<br>        return output<br>    }<br>}<br>注意<br>ShoppingListItem 没有定义构造器来为 purchased 提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p>
<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem 将自动继承所有父类中的指定构造器和便利构造器。</p>
<p>下图展示了这三个类的构造器链：</p>
<p>三类构造器图</p>
<p>你可以使用三个继承来的构造器来创建 ShoppingListItem 的新实例：</p>
<p>var breakfastList = [<br>    ShoppingListItem(),<br>    ShoppingListItem(name: “Bacon”),<br>    ShoppingListItem(name: “Eggs”, quantity: 6),<br>]<br>breakfastList[0].name = “Orange juice”<br>breakfastList[0].purchased = true<br>for item in breakfastList {<br>    print(item.description)<br>}<br>// 1 x orange juice ✔<br>// 1 x bacon ✘<br>// 6 x eggs ✘<br>如上所述，例子中通过字面量方式创建了一个数组 breakfastList，它包含了三个 ShoppingListItem 实例，因此数组的类型也能被自动推导为 [ShoppingListItem]。在数组创建完之后，数组中第一个 ShoppingListItem 实例的名字从 [Unnamed] 更改为 Orange juice，并标记状态为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>
<p>可失败构造器<br>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器是很有用的。这里所指的“失败” 指的是，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 init 关键字后面添加问号 (init?)。</p>
<p>注意<br>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过 return nil 语句来表明可失败构造器在何种情况下应该 “失败”。</p>
<p>注意<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。</p>
<p>例如，实现针对数字类型转换的可失败构造器。确保数字类型之间的转换能保持精确的值，使用这个 init(exactly:) 构造器。如果类型转换不能保持值不变，则这个构造器构造失败。</p>
<p>let wholeNumber: Double = 12345.0<br>let pi = 3.14159</p>
<p>if let valueMaintained = Int(exactly: wholeNumber) {<br>    print(“(wholeNumber) conversion to Int maintains value of (valueMaintained)”)<br>}<br>// 打印 “12345.0 conversion to Int maintains value of 12345”</p>
<p>let valueChanged = Int(exactly: pi)<br>// valueChanged 是 Int? 类型, 不是 Int 类型</p>
<p>if valueChanged == nil {<br>    print(“(pi) conversion to Int does not maintain value”)<br>}<br>// 打印 “3.14159 conversion to Int does not maintain value”<br>下例中，定义了一个名为 Animal 的结构体，其中有一个名为 species 的 String 类型的常量属性。同时该结构体还定义了一个接受一个名为 species 的 String 类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。</p>
<p>struct Animal {<br>    let species: String<br>    init?(species: String) {<br>        if species.isEmpty {<br>            return nil }<br>        self.species = species<br>    }<br>}<br>你可以通过该可失败构造器来尝试构建一个 Animal 的实例，并检查构造过程是否成功：</p>
<p>let someCreature = Animal(species: “Giraffe”)<br>// someCreature 的类型是 Animal? 而不是 Animal</p>
<p>if let giraffe = someCreature {<br>    print(“An animal was initialized with a species of (giraffe.species)”)<br>}<br>// 打印 “An animal was initialized with a species of Giraffe”<br>如果你给该可失败构造器传入一个空字符串作为其参数，则会导致构造失败：</p>
<p>let anonymousCreature = Animal(species: “”)<br>// anonymousCreature 的类型是 Animal?, 而不是 Animal</p>
<p>if anonymousCreature == nil {<br>    print(“The anonymous creature could not be initialized”)<br>}<br>// 打印 “The anonymous creature could not be initialized”<br>注意<br>空字符串（如 “”，而不是 “Giraffe” ）和一个值为 nil 的可选类型的字符串是两个完全不同的概念。上例中的空字符串（””）其实是一个有效的，非可选类型的字符串。这里我们之所以让 Animal 的可失败构造器构造失败，只是因为对于 Animal 这个类的 species 属性来说，它更适合有一个具体的值，而不是空字符串。</p>
<p>枚举类型的可失败构造器<br>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>
<p>下例中，定义了一个名为 TemperatureUnit 的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据 Character 值找出所对应的枚举成员的可失败构造器：</p>
<p>enum TemperatureUnit {<br>    case Kelvin, Celsius, Fahrenheit<br>    init?(symbol: Character) {<br>        switch symbol {<br>        case “K”:<br>            self = .Kelvin<br>        case “C”:<br>            self = .Celsius<br>        case “F”:<br>            self = .Fahrenheit<br>        default:<br>            return nil<br>        }<br>    }<br>}<br>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：</p>
<p>let fahrenheitUnit = TemperatureUnit(symbol: “F”)<br>if fahrenheitUnit != nil {<br>    print(“This is a defined temperature unit, so initialization succeeded.”)<br>}<br>// 打印 “This is a defined temperature unit, so initialization succeeded.”</p>
<p>let unknownUnit = TemperatureUnit(symbol: “X”)<br>if unknownUnit == nil {<br>    print(“This is not a defined temperature unit, so initialization failed.”)<br>}<br>// 打印 “This is not a defined temperature unit, so initialization failed.”</p>
<p>带原始值的枚举类型的可失败构造器<br>带原始值的枚举类型会自带一个可失败构造器 init?(rawValue:)，该可失败构造器有一个名为 rawValue 的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<p>因此上面的 TemperatureUnit 的例子可以重写为：</p>
<p>enum TemperatureUnit: Character {<br>    case Kelvin = “K”, Celsius = “C”, Fahrenheit = “F”<br>}</p>
<p>let fahrenheitUnit = TemperatureUnit(rawValue: “F”)<br>if fahrenheitUnit != nil {<br>    print(“This is a defined temperature unit, so initialization succeeded.”)<br>}<br>// 打印 “This is a defined temperature unit, so initialization succeeded.”</p>
<p>let unknownUnit = TemperatureUnit(rawValue: “X”)<br>if unknownUnit == nil {<br>    print(“This is not a defined temperature unit, so initialization failed.”)<br>}<br>// 打印 “This is not a defined temperature unit, so initialization failed.”</p>
<p>构造失败的传递<br>类，结构体，枚举的可失败构造器可以横向代理到同类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<p>注意<br>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>
<p>下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1：</p>
<p>class Product {<br>    let name: String<br>    init?(name: String) {<br>        if name.isEmpty { return nil }<br>        self.name = name<br>    }<br>}</p>
<p>class CartItem: Product {<br>    let quantity: Int<br>    init?(name: String, quantity: Int) {<br>        if quantity &lt; 1 { return nil }<br>        self.quantity = quantity<br>        super.init(name: name)<br>    }<br>}<br>CartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。</p>
<p>如果你通过传入一个非空字符串 name 以及一个值大于等于 1 的 quantity 来创建一个 CartItem 实例，那么构造方法能够成功被执行：</p>
<p>if let twoSocks = CartItem(name: “sock”, quantity: 2) {<br>    print(“Item: (twoSocks.name), quantity: (twoSocks.quantity)”)<br>}<br>// 打印 “Item: sock, quantity: 2”<br>倘若你以一个值为 0 的 quantity 来创建一个 CartItem 实例，那么将导致 CartItem 构造器失败：</p>
<p>if let zeroShirts = CartItem(name: “shirt”, quantity: 0) {<br>    print(“Item: (zeroShirts.name), quantity: (zeroShirts.quantity)”)<br>} else {<br>    print(“Unable to initialize zero shirts”)<br>}<br>// 打印 “Unable to initialize zero shirts”<br>同样地，如果你尝试传入一个值为空字符串的 name 来创建一个 CartItem 实例，那么将导致父类 Product 的构造过程失败：</p>
<p>if let oneUnnamed = CartItem(name: “”, quantity: 1) {<br>    print(“Item: (oneUnnamed.name), quantity: (oneUnnamed.quantity)”)<br>} else {<br>    print(“Unable to initialize one unnamed product”)<br>}<br>// 打印 “Unable to initialize one unnamed product”</p>
<p>重写一个可失败构造器<br>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p>
<p>注意<br>你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>
<p>下例定义了一个名为 Document 的类，name 属性的值必须为一个非空字符串或 nil，但不能是一个空字符串：</p>
<p>class Document {<br>    var name: String?<br>    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例<br>    init() {}<br>    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例<br>    init?(name: String) {<br>        self.name = name<br>        if name.isEmpty { return nil }<br>    }<br>}<br>下面这个例子，定义了一个 Document 类的子类 AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用 init() 构造器，还是使用 init(name:) 构造器并为参数传递空字符串，生成的实例中的 name 属性总有初始”[Untitled]”：</p>
<p>class AutomaticallyNamedDocument: Document {<br>    override init() {<br>        super.init()<br>        self.name = “[Untitled]”<br>    }<br>    override init(name: String) {<br>        super.init()<br>        if name.isEmpty {<br>            self.name = “[Untitled]”<br>        } else {<br>            self.name = name<br>        }<br>    }<br>}<br>AutomaticallyNamedDocument 用一个非可失败构造器 init(name:) 重写了父类的可失败构造器 init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>
<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的 UntitledDocument 子类的 name 属性的值总是 “[Untitled]”，它在构造过程中使用了父类的可失败构造器 init?(name:)：</p>
<p>class UntitledDocument: Document {<br>    override init() {<br>        super.init(name: “[Untitled]”)!<br>    }<br>}<br>在这个例子中，如果在调用父类的可失败构造器 init?(name:) 时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误。</p>
<p>可失败构造器 init!<br>通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>
<p>你可以在 init? 中代理到 init!，反之亦然。你也可以用 init? 重写 init!，反之亦然。你还可以用init 代理到 init!，不过，一旦 init! 构造失败，则会触发一个断言。</p>
<p>必要构造器<br>在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器：</p>
<p>class SomeClass {<br>    required init() {<br>        // 构造器的实现代码<br>    }<br>}<br>在子类重写父类的必要构造器时，必须在子类的构造器前也添加 required 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 override 修饰符：</p>
<p>class SomeSubclass: SomeClass {<br>    required init() {<br>        // 构造器的实现代码<br>    }<br>}<br>注意<br>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。</p>
<p>通过闭包或函数设置属性的默认值<br>如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>
<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>
<p>下面模板介绍了如何用闭包为属性提供默认值：</p>
<p>class SomeClass {<br>    let someProperty: SomeType = {<br>        // 在这个闭包中给 someProperty 创建一个默认值<br>        // someValue 必须和 SomeType 类型相同<br>        return someValue<br>    }()<br>}<br>注意闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<p>注意<br>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 self 属性，或者调用任何实例方法。</p>
<p>下面例子中定义了一个结构体 Chessboard，它构建了西洋跳棋游戏的棋盘，西洋跳棋游戏在一副黑白格交替的 8 x 8 的棋盘中进行的：</p>
<p>西洋跳棋棋盘</p>
<p>为了呈现这副游戏棋盘，Chessboard结构体定义了一个属性 boardColors，它是一个包含 64 个 Bool值的数组。在数组中，值为 true 的元素表示一个黑格，值为 false 的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>
<p>boardColors 数组是通过一个闭包来初始化并设置颜色值的：</p>
<p>struct Chessboard {<br>    let boardColors: [Bool] = {<br>        var temporaryBoard = <a href="">Bool</a><br>        var isBlack = false<br>        for i in 1…8 {<br>            for j in 1…8 {<br>                temporaryBoard.append(isBlack)<br>                isBlack = !isBlack<br>            }<br>            isBlack = !isBlack<br>        }<br>        return temporaryBoard<br>    }()</p>
<pre><code>func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
    return boardColors[(row * 8) + column]
}
</code></pre><p>}<br>每当一个新的 Chessboard 实例被创建时，赋值闭包则会被执行，boardColors 的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组 temporaryBoard 中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到 boardColors 中，并可以通过工具函数squareIsBlackAtRow来查询：</p>
<p>let board = Chessboard()<br>print(board.squareIsBlackAtRow(0, column: 1))<br>// 打印 “true”<br>print(board.squareIsBlackAtRow(7, column: 7))<br>// 打印 “false”</p>
<p>本页包含内容：</p>
<p>析构过程原理<br>析构器实践<br>析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示，类似于构造器要用init来标示。</p>
<p>析构过程原理<br>Swift 会自动释放不再需要的实例以释放资源。如自动引用计数章节中所讲述，Swift 通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>
<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：</p>
<p>deinit {<br>    // 执行析构过程<br>}<br>析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>
<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>
<p>析构器实践<br>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。</p>
<p>class Bank {<br>    static var coinsInBank = 10_000<br>    static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int {<br>        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)<br>        coinsInBank -= numberOfCoinsToVend<br>        return numberOfCoinsToVend<br>    }<br>    static func receive(coins: Int) {<br>        coinsInBank += coins<br>    }<br>}<br>Bank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，distribute(coins:)和receive(coins:)，分别用来处理硬币的分发和收集。</p>
<p>distribute(coins:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。此方法返回一个整型值，表示提供的硬币的实际数量。</p>
<p>receive(coins:)方法只是将Bank实例接收到的硬币数目加回硬币存储中。</p>
<p>Player类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示：</p>
<p>class Player {<br>    var coinsInPurse: Int<br>    init(coins: Int) {<br>        coinsInPurse = Bank.distribute(coins: coins)<br>    }<br>    func win(coins: Int) {<br>        coinsInPurse += Bank.distribute(coins: coins)<br>    }<br>    deinit {<br>        Bank.receive(coins: coinsInPurse)<br>    }<br>}<br>每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币.</p>
<p>Player类定义了一个win(coins:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象：</p>
<p>var playerOne: Player? = Player(coins: 100)<br>print(“A new player has joined the game with (playerOne!.coinsInPurse) coins”)<br>// 打印 “A new player has joined the game with 100 coins”<br>print(“There are now (Bank.coinsInBank) coins left in the bank”)<br>// 打印 “There are now 9900 coins left in the bank”<br>创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。</p>
<p>因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）强制解包：</p>
<p>playerOne!.win(coins: 2_000)<br>print(“PlayerOne won 2000 coins &amp; now has (playerOne!.coinsInPurse) coins”)<br>// 输出 “PlayerOne won 2000 coins &amp; now has 2100 coins”<br>print(“The bank now only has (Bank.coinsInBank) coins left”)<br>// 输出 “The bank now only has 7900 coins left”<br>这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。</p>
<p>playerOne = nil<br>print(“PlayerOne has left the game”)<br>// 打印 “PlayerOne has left the game”<br>print(“The bank now has (Bank.coinsInBank) coins”)<br>// 打印 “The bank now has 10000 coins”<br>玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>
<p>本页包含内容：</p>
<p>自动引用计数的工作机制<br>自动引用计数实践<br>类实例之间的循环强引用<br>解决实例之间的循环强引用<br>闭包引起的循环强引用<br>解决闭包引起的循环强引用<br>Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>
<p>然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。本章描述了这些情况，并且为你示范怎样才能使 ARC 来管理你的应用程序的所有内存。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似，具体请参考过渡到 ARC 的发布说明</p>
<p>注意<br>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
<p>自动引用计数的工作机制<br>当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。</p>
<p>此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>
<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>
<p>自动引用计数实践<br>下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：</p>
<p>class Person {<br>    let name: String<br>    init(name: String) {<br>        self.name = name<br>        print(“(name) is being initialized”)<br>    }<br>    deinit {<br>        print(“(name) is being deinitialized”)<br>    }<br>}<br>Person类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。</p>
<p>var reference1: Person?<br>var reference2: Person?<br>var reference3: Person?<br>现在你可以创建Person类的新实例，并且将它赋值给三个变量中的一个：</p>
<p>reference1 = Person(name: “John Appleseed”)<br>// 打印 “John Appleseed is being initialized”<br>应当注意到当你调用Person类的构造函数的时候，”John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。</p>
<p>由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。</p>
<p>如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>
<p>reference2 = reference1<br>reference3 = reference1<br>现在这一个Person实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：</p>
<p>reference1 = nil<br>reference2 = nil<br>在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>
<p>reference3 = nil<br>// 打印 “John Appleseed is being deinitialized”</p>
<p>类实例之间的循环强引用<br>在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。</p>
<p>然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在解决类实例之间的循环强引用中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民：</p>
<p>class Person {<br>    let name: String<br>    init(name: String) { self.name = name }<br>    var apartment: Apartment?<br>    deinit { print(“(name) is being deinitialized”) }<br>}</p>
<p>class Apartment {<br>    let unit: String<br>    init(unit: String) { self.unit = unit }<br>    var tenant: Person?<br>    deinit { print(“Apartment (unit) is being deinitialized”) }<br>}<br>每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个Apartment实例有一个叫unit，类型为String的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选类型的优点：</p>
<p>var john: Person?<br>var unit4A: Apartment?<br>现在你可以创建特定的Person和Apartment实例并将赋值给john和unit4A变量：</p>
<p>john = Person(name: “John Appleseed”)<br>unit4A = Apartment(unit: “4A”)<br>在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量unit4A有一个指向Apartment实例的强引用：</p>
<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值：</p>
<p>john!.apartment = unit4A<br>unit4A!.tenant = john<br>在将两个实例联系在一起之后，强引用的关系如图所示：</p>
<p>不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁：</p>
<p>john = nil<br>unit4A = nil<br>注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将john和unit4A赋值为nil后，强引用关系如下图：</p>
<p>Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。</p>
<p>解决实例之间的循环强引用<br>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。</p>
<p>弱引用<br>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上weak关键字表明这是一个弱引用。</p>
<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。</p>
<p>你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。</p>
<p>注意<br>当 ARC 设置弱引用为nil时，属性观察不会被触发。</p>
<p>下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：</p>
<p>class Person {<br>    let name: String<br>    init(name: String) { self.name = name }<br>    var apartment: Apartment?<br>    deinit { print(“(name) is being deinitialized”) }<br>}</p>
<p>class Apartment {<br>    let unit: String<br>    init(unit: String) { self.unit = unit }<br>    weak var tenant: Person?<br>    deinit { print(“Apartment (unit) is being deinitialized”) }<br>}<br>然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：</p>
<p>var john: Person?<br>var unit4A: Apartment?</p>
<p>john = Person(name: “John Appleseed”)<br>unit4A = Apartment(unit: “4A”)</p>
<p>john!.apartment = unit4A<br>unit4A!.tenant = john<br>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p>Person实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：</p>
<p>由于再也没有指向Person实例的强引用，该实例会被销毁：</p>
<p>john = nil<br>// 打印 “John Appleseed is being deinitialized”<br>唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：</p>
<p>由于再也没有指向Apartment实例的强引用，该实例也会被销毁：</p>
<p>unit4A = nil<br>// 打印 “Apartment 4A is being deinitialized”<br>上面的两段代码展示了变量john和unit4A在被赋值为nil后，Person实例和Apartment实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<p>注意<br>在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>
<p>无主引用<br>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。</p>
<p>无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。</p>
<p>重要<br>使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。</p>
<p>下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p>Customer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。</p>
<p>此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：</p>
<p>class Customer {<br>    let name: String<br>    var card: CreditCard?<br>    init(name: String) {<br>        self.name = name<br>    }<br>    deinit { print(“(name) is being deinitialized”) }<br>}<br>class CreditCard {<br>    let number: UInt64<br>    unowned let customer: Customer<br>    init(number: UInt64, customer: Customer) {<br>        self.number = number<br>        self.customer = customer<br>    }<br>    deinit { print(“Card #(number) is being deinitialized”) }<br>}<br>注意<br>CreditCard类的number属性被定义为UInt64类型而不是Int类型，以确保number属性的存储量在 32 位和 64 位系统上都能足够容纳 16 位的卡号。</p>
<p>下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil：</p>
<p>var john: Customer?<br>现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性：</p>
<p>john = Customer(name: “John Appleseed”)<br>john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)<br>在你关联两个实例后，它们的引用关系如下图所示：</p>
<p>Customer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。</p>
<p>由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：</p>
<p>由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：</p>
<p>john = nil<br>// 打印 “John Appleseed is being deinitialized”<br>// 打印 “Card #1234567890123456 is being deinitialized”<br>最后的代码展示了在john变量被设为nil后Customer实例和CreditCard实例的构造函数都打印出了“销毁”的信息。</p>
<p>注意<br>上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。</p>
<p>无主引用以及隐式解析可选属性<br>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p>Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p>Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：</p>
<p>class Country {<br>    let name: String<br>    var capitalCity: City!<br>    init(name: String, capitalName: String) {<br>        self.name = name<br>        self.capitalCity = City(name: capitalName, country: self)<br>    }<br>}</p>
<p>class City {<br>    let name: String<br>    unowned let country: Country<br>    init(name: String, country: Country) {<br>        self.name = name<br>        self.country = country<br>    }<br>}<br>为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。</p>
<p>Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。在两段式构造过程中有具体描述。</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。在隐式解析可选类型中有描述。</p>
<p>由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<p>var country = Country(name: “Canada”, capitalName: “Ottawa”)<br>print(“(country.name)’s capital city is called (country.capitalCity.name)”)<br>// 打印 “Canada’s capital city is called Ottawa”<br>在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>
<p>闭包引起的循环强引用<br>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>
<p>class HTMLElement {</p>
<pre><code>let name: String
let text: String?

lazy var asHTML: Void -&gt; String = {
    if let text = self.text {
        return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
    } else {
        return &quot;&lt;\(self.name) /&gt;&quot;
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    print(&quot;\(name) is being deinitialized&quot;)
}
</code></pre><p>}<br>HTMLElement类定义了一个name属性来表示这个元素的名称，例如代表头部元素的”h1”，代表段落的”p”，或者代表换行的”br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。</p>
<p>除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -&gt; String类型，或者可以理解为“一个没有参数，返回String的函数”。</p>
<p>默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是”some text”还是nil，闭包会返回”</p><p>some text</p>“或者”<p>“。</p>
<p>可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>
<p>例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>
<p>let heading = HTMLElement(name: “h1”)<br>let defaultText = “some default text”<br>heading.asHTML = {<br>    return “&lt;(heading.name)&gt;(heading.text ?? defaultText)&lt;/(heading.name)&gt;”<br>}<br>print(heading.asHTML())<br>// 打印 “</p><h1>some default text</h1>“<br>注意<br>asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。<p></p>
<p>HTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用HTMLElement类创建实例并打印消息：</p>
<p>var paragraph: HTMLElement? = HTMLElement(name: “p”, text: “hello, world”)<br>print(paragraph!.asHTML())<br>// 打印 “</p><p>hello, world</p>“<br>注意<br>上面的paragraph变量定义为可选类型的HTMLElement，因此我们可以赋值nil给它来演示循环强引用。<p></p>
<p>不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p>实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考值捕获）。</p>
<p>注意<br>虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。</p>
<p>如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
<p>paragraph = nil<br>注意，HTMLElement的析构函数中的消息并没有被打印，证明了HTMLElement实例并没有被销毁。</p>
<p>解决闭包引起的循环强引用<br>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<p>注意<br>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。</p>
<p>定义捕获列表<br>捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>
<p>lazy var someClosure: (Int, String) -&gt; String = {<br>    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in<br>    // 这里是闭包的函数体<br>}<br>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：</p>
<p>lazy var someClosure: Void -&gt; String = {<br>    [unowned self, weak delegate = self.delegate!] in<br>    // 这里是闭包的函数体<br>}</p>
<p>弱引用和无主引用<br>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
<p>相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。</p>
<p>注意<br>如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。</p>
<p>前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：</p>
<p>class HTMLElement {</p>
<pre><code>let name: String
let text: String?

lazy var asHTML: Void -&gt; String = {
    [unowned self] in
    if let text = self.text {
        return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
    } else {
        return &quot;&lt;\(self.name) /&gt;&quot;
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    print(&quot;\(name) is being deinitialized&quot;)
}
</code></pre><p>}<br>上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。</p>
<p>和之前一样，我们可以创建并打印HTMLElement实例：</p>
<p>var paragraph: HTMLElement? = HTMLElement(name: “p”, text: “hello, world”)<br>print(paragraph!.asHTML())<br>// 打印 “</p><p>hello, world</p>“<br>使用捕获列表后引用关系如下图所示：<p></p>
<p>这一次，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息：</p>
<p>paragraph = nil<br>// 打印 “p is being deinitialized”<br>你可以查看捕获列表章节，获取更多关于捕获列表的信息。</p>
<p>可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。</p>
<p>注意<br>Swift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>
<p>使用可选链式调用代替强制展开<br>通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>
<p>为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。</p>
<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。</p>
<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>
<p>首先定义两个类Person和Residence：</p>
<p>class Person {<br>    var residence: Residence?<br>}</p>
<p>class Residence {<br>    var numberOfRooms = 1<br>}<br>Residence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。</p>
<p>假如你创建了一个新的Person实例,它的residence属性由于是是可选型而将初始化为nil,在下面的代码中,john有一个值为nil的residence属性：</p>
<p>let john = Person()<br>如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值：</p>
<p>let roomCount = john.residence!.numberOfRooms<br>// 这会引发运行时错误<br>john.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。</p>
<p>可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）：</p>
<p>if let roomCount = john.residence?.numberOfRooms {<br>    print(“John’s residence has (roomCount) room(s).”)<br>} else {<br>    print(“Unable to retrieve the number of rooms.”)<br>}<br>// 打印 “Unable to retrieve the number of rooms.”<br>在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。</p>
<p>因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。</p>
<p>要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。</p>
<p>可以将一个Residence的实例赋给john.residence，这样它就不再是nil了：</p>
<p>john.residence = Residence()<br>john.residence现在包含一个实际的Residence实例，而不再是nil。如果你试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值：</p>
<p>if let roomCount = john.residence?.numberOfRooms {<br>    print(“John’s residence has (roomCount) room(s).”)<br>} else {<br>    print(“Unable to retrieve the number of rooms.”)<br>}<br>// 打印 “John’s residence has 1 room(s).”</p>
<p>为可选链式调用定义模型类<br>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。</p>
<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。</p>
<p>Person类的定义基本保持不变：</p>
<p>class Person {<br>    var residence: Residence?<br>}<br>Residence类比之前复杂些，增加了一个名为rooms的变量属性，该属性被初始化为[Room]类型的空数组：</p>
<p>class Residence {<br>    var rooms = <a href="">Room</a><br>    var numberOfRooms: Int {<br>        return rooms.count<br>    }<br>    subscript(i: Int) -&gt; Room {<br>        get {<br>            return rooms[i]<br>        }<br>        set {<br>            rooms[i] = newValue<br>        }<br>    }<br>    func printNumberOfRooms() {<br>        print(“The number of rooms is (numberOfRooms)”)<br>    }<br>    var address: Address?<br>}<br>现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。</p>
<p>Residence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。</p>
<p>此外，Residence还提供了printNumberOfRooms方法，这个方法的作用是打印numberOfRooms的值。</p>
<p>最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。</p>
<p>Room类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>
<p>class Room {<br>    let name: String<br>    init(name: String) { self.name = name }<br>}<br>最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称：</p>
<p>class Address {<br>    var buildingName: String?<br>    var buildingNumber: String?<br>    var street: String?<br>    func buildingIdentifier() -&gt; String? {<br>        if buildingName != nil {<br>            return buildingName<br>        } else if buildingNumber != nil &amp;&amp; street != nil {<br>            return “(buildingNumber) (street)”<br>        } else {<br>            return nil<br>        }<br>    }<br>}<br>Address类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。</p>
<p>通过可选链式调用访问属性<br>正如使用可选链式调用代替强制展开中所述，可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。</p>
<p>下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性：</p>
<p>let john = Person()<br>if let roomCount = john.residence?.numberOfRooms {<br>    print(“John’s residence has (roomCount) room(s).”)<br>} else {<br>    print(“Unable to retrieve the number of rooms.”)<br>}<br>// 打印 “Unable to retrieve the number of rooms.”<br>因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。</p>
<p>还可以通过可选链式调用来设置属性值：</p>
<p>let someAddress = Address()<br>someAddress.buildingNumber = “29”<br>someAddress.street = “Acacia Road”<br>john.residence?.address = someAddress<br>在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。</p>
<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>
<p>func createAddress() -&gt; Address {<br>    print(“Function was called.”)</p>
<pre><code>let someAddress = Address()
someAddress.buildingNumber = &quot;29&quot;
someAddress.street = &quot;Acacia Road&quot;

return someAddress
</code></pre><p>}<br>john.residence?.address = createAddress()<br>没有任何打印消息，可以看出createAddress()函数并未被执行。</p>
<p>通过可选链式调用调用方法<br>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。</p>
<p>Residence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示：</p>
<p>func printNumberOfRooms() {<br>    print(“The number of rooms is (numberOfRooms)”)<br>}<br>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void，如无返回值函数中所述。这意味着没有返回值的方法也会返回()，或者说空的元组。</p>
<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功：</p>
<p>if john.residence?.printNumberOfRooms() != nil {<br>    print(“It was possible to print the number of rooms.”)<br>} else {<br>    print(“It was not possible to print the number of rooms.”)<br>}<br>// 打印 “It was not possible to print the number of rooms.”<br>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功：</p>
<p>if (john.residence?.address = someAddress) != nil {<br>    print(“It was possible to set the address.”)<br>} else {<br>    print(“It was not possible to set the address.”)<br>}<br>// 打印 “It was not possible to set the address.”</p>
<p>通过可选链式调用访问下标<br>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>
<p>注意<br>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>
<p>下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了：</p>
<p>if let firstRoomName = john.residence?[0].name {<br>    print(“The first room name is (firstRoomName).”)<br>} else {<br>    print(“Unable to retrieve the first room name.”)<br>}<br>// 打印 “Unable to retrieve the first room name.”<br>在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。</p>
<p>类似的，可以通过下标，用可选链式调用来赋值：</p>
<p>john.residence?[0] = Room(name: “Bathroom”)<br>这次赋值同样会失败，因为residence目前是nil。</p>
<p>如果你创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素：</p>
<p>let johnsHouse = Residence()<br>johnsHouse.rooms.append(Room(name: “Living Room”))<br>johnsHouse.rooms.append(Room(name: “Kitchen”))<br>john.residence = johnsHouse</p>
<p>if let firstRoomName = john.residence?[0].name {<br>    print(“The first room name is (firstRoomName).”)<br>} else {<br>    print(“Unable to retrieve the first room name.”)<br>}<br>// 打印 “The first room name is Living Room.”</p>
<p>访问可选类型的下标<br>如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>
<p>var testScores = [“Dave”: [86, 82, 84], “Bev”: [79, 94, 81]]<br>testScores[“Dave”]?[0] = 91<br>testScores[“Bev”]?[0] += 1<br>testScores[“Brian”]?[0] = 72<br>// “Dave” 数组现在是 [91, 82, 84]，”Bev” 数组现在是 [80, 94, 81]<br>上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把”Dave”数组中第一个元素设为91，把”Bev”数组的第一个元素+1，然后尝试把”Brian”数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含”Dave”和”Bev”这两个键。但是testScores字典中没有”Brian”这个键，所以第三个调用失败。</p>
<p>连接多层可选链式调用<br>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>
<p>也就是说：</p>
<p>如果你访问的值不是可选的，可选链式调用将会返回可选值。<br>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。<br>因此：</p>
<p>通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。<br>类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。<br>下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值：</p>
<p>if let johnsStreet = john.residence?.address?.street {<br>    print(“John’s street name is (johnsStreet).”)<br>} else {<br>    print(“Unable to retrieve the address.”)<br>}<br>// 打印 “Unable to retrieve the address.”<br>john.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。</p>
<p>需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。</p>
<p>如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性：</p>
<p>let johnsAddress = Address()<br>johnsAddress.buildingName = “The Larches”<br>johnsAddress.street = “Laurel Street”<br>john.residence?.address = johnsAddress</p>
<p>if let johnsStreet = john.residence?.address?.street {<br>    print(“John’s street name is (johnsStreet).”)<br>} else {<br>    print(“Unable to retrieve the address.”)<br>}<br>// 打印 “John’s street name is Laurel Street.”<br>在上面的例子中，因为john.residence包含一个有效的Address实例，所以对john.residence的address属性赋值将会成功。</p>
<p>在方法的可选返回值上进行可选链式调用<br>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>
<p>在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型：</p>
<p>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {<br>    print(“John’s building identifier is (buildingIdentifier).”)<br>}<br>// 打印 “John’s building identifier is The Larches.”<br>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>
<p>if let beginsWithThe =<br>    john.residence?.address?.buildingIdentifier()?.hasPrefix(“The”) {<br>        if beginsWithThe {<br>            print(“John’s building identifier begins with \”The\”.”)<br>        } else {<br>            print(“John’s building identifier does not begin with \”The\”.”)<br>        }<br>}<br>// 打印 “John’s building identifier begins with “The”.”<br>注意<br>在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。</p>
<p>错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。</p>
<p>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。</p>
<p>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。</p>
<p>注意<br>Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的NSError。关于这个类的更多信息请参见 Using Swift with Cocoa and Objective-C (Swift 4) 中的错误处理。</p>
<p>表示并抛出错误<br>在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。</p>
<p>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>
<p>enum VendingMachineError: Error {<br>    case invalidSelection                    //选择无效<br>    case insufficientFunds(coinsNeeded: Int) //金额不足<br>    case outOfStock                          //缺货<br>}<br>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throw关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币：</p>
<p>throw VendingMachineError. insufficientFunds(coinsNeeded: 5)</p>
<p>处理错误<br>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。</p>
<p>Swift 中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。每种方式在下面的小节中都有描述。</p>
<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上try关键字，或者try?或try!这种变体。这些关键字在下面的小节中有具体讲解。</p>
<p>注意<br>Swift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。</p>
<p>用 throwing 函数传递错误<br>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有throws关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（-&gt;）的前面。</p>
<p>func canThrowErrors() throws -&gt; String<br>func cannotThrowErrors() -&gt; String<br>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p>
<p>注意<br>只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>
<p>下面的例子中，VendingMachine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者投入金额小于物品价格，该方法就会抛出一个相应的VendingMachineError：</p>
<p>struct Item {<br>    var price: Int<br>    var count: Int<br>}</p>
<p>class VendingMachine {<br>    var inventory = [<br>        “Candy Bar”: Item(price: 12, count: 7),<br>        “Chips”: Item(price: 10, count: 4),<br>        “Pretzels”: Item(price: 7, count: 11)<br>    ]<br>    var coinsDeposited = 0<br>    func dispenseSnack(snack: String) {<br>        print(“Dispensing (snack)”)<br>    }</p>
<pre><code>func vend(itemNamed name: String) throws {
    guard let item = inventory[name] else {
        throw VendingMachineError.invalidSelection
    }

    guard item.count &gt; 0 else {
        throw VendingMachineError.outOfStock
    }

    guard item.price &lt;= coinsDeposited else {
        throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
    }

    coinsDeposited -= item.price

    var newItem = item
    newItem.count -= 1
    inventory[name] = newItem

    print(&quot;Dispensing \(name)&quot;)
}
</code></pre><p>}<br>在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>
<p>因为vend(itemNamed:)方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(person:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(person:vendingMachine:)函数被调用的地方。</p>
<p>let favoriteSnacks = [<br>    “Alice”: “Chips”,<br>    “Bob”: “Licorice”,<br>    “Eve”: “Pretzels”,<br>]<br>func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {<br>    let snackName = favoriteSnacks[person] ?? “Candy Bar”<br>    try vendingMachine.vend(itemNamed: snackName)<br>}<br>上例中，buyFavoriteSnack(person:vendingMachine:)函数会查找某人最喜欢的零食，并通过调用vend(itemNamed:)方法来尝试为他们购买。因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。</p>
<p>throwing构造器能像throwing函数一样传递错误。例如下面代码中的PurchasedSnack构造器在构造过程中调用了throwing函数，并且通过传递到它的调用者来处理这些错误。</p>
<p>struct PurchasedSnack {<br>    let name: String<br>    init(name: String, vendingMachine: VendingMachine) throws {<br>        try vendingMachine.vend(itemNamed: name)<br>        self.name = name<br>    }<br>}<br>用 Do-Catch 处理错误<br>可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。</p>
<p>下面是do-catch语句的一般形式：</p>
<p>do {<br>    try expression<br>    statements<br>} catch pattern 1 {<br>    statements<br>} catch pattern 2 where condition {<br>    statements<br>}<br>在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量。关于模式匹配的更多信息请参考 模式。</p>
<p>catch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>
<p>var vendingMachine = VendingMachine()<br>vendingMachine.coinsDeposited = 8<br>do {<br>    try buyFavoriteSnack(person: “Alice”, vendingMachine: vendingMachine)<br>} catch VendingMachineError.invalidSelection {<br>    print(“Invalid Selection.”)<br>} catch VendingMachineError.outOfStock {<br>    print(“Out of Stock.”)<br>} catch VendingMachineError.insufficientFunds(let coinsNeeded) {<br>    print(“Insufficient funds. Please insert an additional (coinsNeeded) coins.”)<br>}<br>// 打印 “Insufficient funds. Please insert an additional 2 coins.”<br>上面的例子中，buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。</p>
<p>将错误转换成可选值<br>可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如，在下面的代码中，x和y有着相同的数值和等价的含义：</p>
<p>func someThrowingFunction() throws -&gt; Int {<br>    // …<br>}</p>
<p>let x = try? someThrowingFunction()</p>
<p>let y: Int?<br>do {<br>    y = try someThrowingFunction()<br>} catch {<br>    y = nil<br>}<br>如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。</p>
<p>如果你想对所有的错误都采用同样的方式来处理，用try?就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil。</p>
<p>func fetchData() -&gt; Data? {<br>    if let data = try? fetchDataFromDisk() { return data }<br>    if let data = try? fetchDataFromServer() { return data }<br>    return nil<br>}<br>禁用错误传递<br>有时你知道某个throwing函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写try!来禁用错误传递，这会把调用包装在一个不会有错误抛出的运行时断言中。如果真的抛出了错误，你会得到一个运行时错误。</p>
<p>例如，下面的代码使用了loadImage(atPath:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递。</p>
<p>let photo = try! loadImage(atPath: “./Resources/John Appleseed.jpg”)</p>
<p>指定清理操作<br>可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，或是由于诸如return、break的语句。例如，你可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>
<p>defer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break、return语句，或是抛出一个错误。延迟执行的操作会按照它们声明的顺序从后往前执行——也就是说，第一条defer语句中的代码最后才执行，第二条defer语句中的代码倒数第二个执行，以此类推。最后一条语句会第一个执行</p>
<p>func processFile(filename: String) throws {<br>    if exists(filename) {<br>        let file = open(filename)<br>        defer {<br>            close(file)<br>        }<br>        while let line = try file.readline() {<br>            // 处理文件。<br>        }<br>        // close(file) 会在这里被调用，即作用域的最后。<br>    }<br>}<br>上面的代码使用一条defer语句来确保open(<em>:)函数有一个相应的对close(</em>:)函数的调用。</p>
<p>注意<br>即使没有涉及到错误处理，你也可以使用defer语句。</p>
<p>类型转换 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。</p>
<p>类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>
<p>你也可以用它来检查一个类型是否实现了某个协议，就像在检验协议的一致性部分讲述的一样。</p>
<p>定义一个类层次作为例子<br>你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。</p>
<p>第一个代码片段定义了一个新的基类 MediaItem。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 String 类型的 name 属性，和一个 init(name:) 初始化器。（假定所有的媒体项都有个名称。）</p>
<p>class MediaItem {<br>    var name: String<br>    init(name: String) {<br>        self.name = name<br>    }<br>}<br>下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song，在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器：</p>
<p>class Movie: MediaItem {<br>    var director: String<br>    init(name: String, director: String) {<br>        self.director = director<br>        super.init(name: name)<br>    }<br>}</p>
<p>class Song: MediaItem {<br>    var artist: String<br>    init(name: String, artist: String) {<br>        self.artist = artist<br>        super.init(name: name)<br>    }<br>}<br>最后一个代码段创建了一个数组常量 library，包含两个 Movie 实例和三个 Song 实例。library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，所以它推断出 [MediaItem] 类作为 library 的类型：</p>
<p>let library = [<br>    Movie(name: “Casablanca”, director: “Michael Curtiz”),<br>    Song(name: “Blue Suede Shoes”, artist: “Elvis Presley”),<br>    Movie(name: “Citizen Kane”, director: “Orson Welles”),<br>    Song(name: “The One And Only”, artist: “Chesney Hawkes”),<br>    Song(name: “Never Gonna Give You Up”, artist: “Rick Astley”)<br>]<br>// 数组 library 的类型被推断为 [MediaItem]<br>在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是，若你迭代它，依次取出的实例会是 MediaItem 类型的，而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。</p>
<p>检查类型<br>用类型检查操作符（is）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true，否则返回 false。</p>
<p>下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量：</p>
<p>var movieCount = 0<br>var songCount = 0</p>
<p>for item in library {<br>    if item is Movie {<br>        movieCount += 1<br>    } else if item is Song {<br>        songCount += 1<br>    }<br>}</p>
<p>print(“Media library contains (movieCount) movies and (songCount) songs”)<br>// 打印 “Media library contains 2 movies and 3 songs”<br>示例迭代了数组 library 中的所有项。每一次，for-in 循环设置 item 为数组中的下一个 MediaItem。</p>
<p>若当前 MediaItem 是一个 Movie 类型的实例，item is Movie 返回 true，否则返回 false。同样的，item is Song 检查 item 是否为 Song 类型的实例。在循环结束后，movieCount 和 songCount 的值就是被找到的属于各自类型的实例的数量。</p>
<p>向下转型<br>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。</p>
<p>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。</p>
<p>当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。</p>
<p>只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>
<p>下面的例子，迭代了 library 里的每一个 MediaItem，并打印出适当的描述。要这样做，item 需要真正作为 Movie 或 Song 的类型来使用，而不仅仅是作为 MediaItem。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性，这是必要的。</p>
<p>在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转：</p>
<p>for item in library {<br>    if let movie = item as? Movie {<br>        print(“Movie: ‘(movie.name)’, dir. (movie.director)”)<br>    } else if let song = item as? Song {<br>        print(“Song: ‘(song.name)’, by (song.artist)”)<br>    }<br>}</p>
<p>// Movie: ‘Casablanca’, dir. Michael Curtiz<br>// Song: ‘Blue Suede Shoes’, by Elvis Presley<br>// Movie: ‘Citizen Kane’, dir. Orson Welles<br>// Song: ‘The One And Only’, by Chesney Hawkes<br>// Song: ‘Never Gonna Give You Up’, by Rick Astley<br>示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例，它可能是一个 Movie；同样，它也可能是一个 Song，或者仅仅是基类 MediaItem。因为不确定，as? 形式在试图下转时将返回一个可选值。item as? Movie 的返回值是 Movie? 或者说“可选 Movie”。</p>
<p>当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 Movie 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“if let movie = item as? Movie”，可以这样解读：</p>
<p>“尝试将 item 转为 Movie 类型。若成功，设置一个新的临时常量 movie 来存储返回的可选 Movie 中的值”</p>
<p>若向下转型成功，然后 movie 的属性将用于打印一个 Movie 实例的描述，包括它的导演的名字 director。相似的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述（包含 artist 的名字）。</p>
<p>注意<br>转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>
<p>Any 和 AnyObject 的类型转换<br>Swift 为不确定类型提供了两种特殊的类型别名：</p>
<p>Any 可以表示任何类型，包括函数类型。<br>AnyObject 可以表示任何类类型的实例。<br>只有当你确实需要它们的行为和功能时才使用 Any 和 AnyObject。在你的代码里使用你期望的明确类型总是更好的。</p>
<p>这里有个示例，使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things：</p>
<p>var things = <a href="">Any</a></p>
<p>things.append(0)<br>things.append(0.0)<br>things.append(42)<br>things.append(3.14159)<br>things.append(“hello”)<br>things.append((3.0, 5.0))<br>things.append(Movie(name: “Ghostbusters”, director: “Ivan Reitman”))<br>things.append({ (name: String) -&gt; String in “Hello, (name)” })<br>things 数组包含两个 Int 值，两个 Double 值，一个 String 值，一个元组 (Double, Double)，一个Movie实例“Ghostbusters”，以及一个接受 String 值并返回另一个 String 值的闭包表达式。</p>
<p>你可以在 switch 表达式的 case 中使用 is 和 as 操作符来找出只知道是 Any 或 AnyObject 类型的常量或变量的具体类型。下面的示例迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。有几个 switch 语句的 case 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p>
<p>for thing in things {<br>    switch thing {<br>    case 0 as Int:<br>        print(“zero as an Int”)<br>    case 0 as Double:<br>        print(“zero as a Double”)<br>    case let someInt as Int:<br>        print(“an integer value of (someInt)”)<br>    case let someDouble as Double where someDouble &gt; 0:<br>        print(“a positive double value of (someDouble)”)<br>    case is Double:<br>        print(“some other double value that I don’t want to print”)<br>    case let someString as String:<br>        print(“a string value of \”(someString)\””)<br>    case let (x, y) as (Double, Double):<br>        print(“an (x, y) point at (x), (y)”)<br>    case let movie as Movie:<br>        print(“a movie called ‘(movie.name)’, dir. (movie.director)”)<br>    case let stringConverter as String -&gt; String:<br>        print(stringConverter(“Michael”))<br>    default:<br>        print(“something else”)<br>    }<br>}</p>
<p>// zero as an Int<br>// zero as a Double<br>// an integer value of 42<br>// a positive double value of 3.14159<br>// a string value of “hello”<br>// an (x, y) point at 3.0, 5.0<br>// a movie called ‘Ghostbusters’, dir. Ivan Reitman<br>// Hello, Michael<br>注意<br>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显式转换为Any，如下所示：</p>
<p>let optionalNumber: Int? = 3<br>things.append(optionalNumber)        // 警告<br>things.append(optionalNumber as Any) // 没有警告</p>
<p>枚举常被用于为特定类或结构体实现某些功能。类似地，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。</p>
<p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的 {} 内，而且可以根据需要定义多级嵌套。</p>
<p>嵌套类型实践<br>下面这个例子定义了一个结构体 BlackjackCard（二十一点），用来模拟 BlackjackCard 中的扑克牌点数。BlackjackCard 结构体包含两个嵌套定义的枚举类型 Suit 和 Rank。</p>
<p>在 BlackjackCard 中，Ace 牌可以表示 1 或者 11 ，Ace 牌的这一特征通过一个嵌套在 Rank 枚举中的结构体 Values 来表示：</p>
<p>struct BlackjackCard {</p>
<pre><code>// 嵌套的 Suit 枚举
enum Suit: Character {
    case spades = &quot;♠&quot;, hearts = &quot;♡&quot;, diamonds = &quot;♢&quot;, clubs = &quot;♣&quot;
}

// 嵌套的 Rank 枚举
enum Rank: Int {
    case two = 2, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king, ace
    struct Values {
        let first: Int, second: Int?
    }
    var values: Values {
        switch self {
        case .ace:
            return Values(first: 1, second: 11)
        case .jack, .queen, .king:
            return Values(first: 10, second: nil)
        default:
            return Values(first: self.rawValue, second: nil)
        }
    }
}

// BlackjackCard 的属性和方法
let rank: Rank, suit: Suit
var description: String {
    var output = &quot;suit is \(suit.rawValue),&quot;
    output += &quot; value is \(rank.values.first)&quot;
    if let second = rank.values.second {
        output += &quot; or \(second)&quot;
    }
    return output
}
</code></pre><p>}<br>Suit 枚举用来描述扑克牌的四种花色，并用一个 Character 类型的原始值表示花色符号。</p>
<p>Rank 枚举用来描述扑克牌从 Ace~10，以及 J、Q、K，这 13 种牌，并用一个 Int 类型的原始值表示牌的面值。（这个 Int 类型的原始值未用于 Ace、J、Q、K 这 4 种牌。）</p>
<p>如上所述，Rank 枚举在内部定义了一个嵌套结构体 Values。结构体 Values 中定义了两个属性，用于反映只有 Ace 有两个数值，其余牌都只有一个数值：</p>
<p>first 的类型为 Int<br>second 的类型为 Int?，或者说“可选 Int”<br>Rank 还定义了一个计算型属性 values，它将会返回一个 Values 结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化 Values 实例。对于 J、Q、K、Ace 这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的 Int 类型的原始值。</p>
<p>BlackjackCard 结构体拥有两个属性—— rank 与 suit。它也同样定义了一个计算型属性 description，description 属性用 rank 和 suit 中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型 second 是否有值，若有值，则在原有的描述中增加对 second 的描述。</p>
<p>因为 BlackjackCard 是一个没有自定义构造器的结构体，在结构体的逐一成员构造器中可知，结构体有默认的成员构造器，所以你可以用默认的构造器去初始化新常量 theAceOfSpades：</p>
<p>let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)<br>print(“theAceOfSpades: (theAceOfSpades.description)”)<br>// 打印 “theAceOfSpades: suit is ♠, value is 1 or 11”<br>尽管 Rank 和 Suit 嵌套在 BlackjackCard 中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.ace 和 .spades）引用枚举实例。在上面的例子中，description 属性正确地反映了黑桃A牌具有 1 和 11 两个值。</p>
<p>引用嵌套类型<br>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>
<p>let heartsSymbol = BlackjackCard.Suit.hearts.rawValue<br>// 红心符号为 “♡”<br>对于上面这个例子，这样可以使 Suit、Rank 和 Values 的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>
<p>扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）</p>
<p>Swift 中的扩展可以：</p>
<p>添加计算型属性和计算型类型属性<br>定义实例方法和类型方法<br>提供新的构造器<br>定义下标<br>定义和使用新的嵌套类型<br>使一个已有类型符合某个协议<br>在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。你可以从协议扩展获取更多的细节。</p>
<p>注意<br>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>
<p>扩展语法<br>使用关键字 extension 来声明扩展：</p>
<p>extension SomeType {<br>    // 为 SomeType 添加的新功能写到这里<br>}<br>可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：</p>
<p>extension SomeType: SomeProtocol, AnotherProctocol {<br>    // 协议实现写到这里<br>}<br>通过这种方式添加协议一致性的详细描述请参阅利用扩展添加协议一致性。</p>
<p>注意<br>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</p>
<p>计算型属性<br>扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：</p>
<p>extension Double {<br>    var km: Double { return self * 1_000.0 }<br>    var m : Double { return self }<br>    var cm: Double { return self / 100.0 }<br>    var mm: Double { return self / 1_000.0 }<br>    var ft: Double { return self / 3.28084 }<br>}<br>let oneInch = 25.4.mm<br>print(“One inch is (oneInch) meters”)<br>// 打印 “One inch is 0.0254 meters”<br>let threeFeet = 3.ft<br>print(“Three feet is (threeFeet) meters”)<br>// 打印 “Three feet is 0.914399970739201 meters”<br>这些计算型属性表达的含义是把一个 Double 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。</p>
<p>在上述例子中，Double 值 1.0 用来表示“1米”。这就是为什么计算型属性 m 返回 self，即表达式 1.m 被认为是计算 Double 值 1.0。</p>
<p>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 km 要把值乘以 1_000.00 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 ft 要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。</p>
<p>这些属性是只读的计算型属性，为了更简洁，省略了 get 关键字。它们的返回值是 Double，而且可以用于所有接受 Double 值的数学计算中：</p>
<p>let aMarathon = 42.km + 195.m<br>print(“A marathon is (aMarathon) meters long”)<br>// 打印 “A marathon is 42195.0 meters long”<br>注意<br>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。</p>
<p>构造器<br>扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。</p>
<p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。</p>
<p>注意<br>如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。<br>正如在值类型的构造器代理中描述的，如果你把定制的构造器写在值类型的原始实现中，上述规则将不再适用。</p>
<p>下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值：</p>
<p>struct Size {<br>    var width = 0.0, height = 0.0<br>}<br>struct Point {<br>    var x = 0.0, y = 0.0<br>}<br>struct Rect {<br>    var origin = Point()<br>    var size = Size()<br>}<br>因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。详情请参阅默认构造器。这些构造器可以用于构造新的 Rect 实例：</p>
<p>let defaultRect = Rect()<br>let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),<br>    size: Size(width: 5.0, height: 5.0))<br>你可以提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体：</p>
<p>extension Rect {<br>    init(center: Point, size: Size) {<br>        let originX = center.x - (size.width / 2)<br>        let originY = center.y - (size.height / 2)<br>        self.init(origin: Point(x: originX, y: originY), size: size)<br>    }<br>}<br>这个新的构造器首先根据提供的 center 和 size 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中：</p>
<p>let centerRect = Rect(center: Point(x: 4.0, y: 4.0),<br>    size: Size(width: 3.0, height: 3.0))<br>// centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)<br>注意<br>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。</p>
<p>方法<br>扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法：</p>
<p>extension Int {<br>    func repetitions(task: () -&gt; Void) {<br>        for _ in 0..<self {="" task()="" }="" 这个="" repetitions(task:)="" 方法接受一个="" ()="" -=""> Void 类型的单参数，表示没有参数且没有返回值的函数。</self></p>
<p>定义该扩展之后，你就可以对任意整数调用 repetitions(task:) 方法，将闭包中的任务执行整数对应的次数：</p>
<p>3.repetitions({<br>    print(“Hello!”)<br>})<br>// Hello!<br>// Hello!<br>// Hello!<br>可以使用尾随闭包让调用更加简洁：</p>
<p>3.repetitions {<br>    print(“Goodbye!”)<br>}<br>// Goodbye!<br>// Goodbye!<br>// Goodbye!</p>
<p>可变实例方法<br>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 mutating，正如来自原始实现的可变方法一样。</p>
<p>下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值：</p>
<p>extension Int {<br>    mutating func square() {<br>        self = self * self<br>    }<br>}<br>var someInt = 3<br>someInt.square()<br>// someInt 的值现在是 9</p>
<p>下标<br>扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字：</p>
<p>123456789[0] 返回 9<br>123456789[1] 返回 8<br>……以此类推。</p>
<p>extension Int {<br>    subscript(digitIndex: Int) -&gt; Int {<br>        var decimalBase = 1<br>        for _ in 0..&lt;digitIndex {<br>            decimalBase *= 10<br>        }<br>        return (self / decimalBase) % 10<br>    }<br>}<br>746381295[0]<br>// 返回 5<br>746381295[1]<br>// 返回 9<br>746381295[2]<br>// 返回 2<br>746381295[8]<br>// 返回 7<br>如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0：</p>
<p>746381295[9]<br>// 返回 0，即等同于：<br>0746381295[9]</p>
<p>嵌套类型<br>扩展可以为已有的类、结构体和枚举添加新的嵌套类型：</p>
<p>extension Int {<br>    enum Kind {<br>        case Negative, Zero, Positive<br>    }<br>    var kind: Kind {<br>        switch self {<br>        case 0:<br>            return .Zero<br>        case let x where x &gt; 0:<br>            return .Positive<br>        default:<br>            return .Negative<br>        }<br>    }<br>}<br>该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。</p>
<p>这个例子还为 Int 添加了一个计算型实例属性，即 kind，用来根据整数返回适当的 Kind 枚举成员。</p>
<p>现在，这个嵌套枚举可以和任意 Int 值一起使用了：</p>
<p>func printIntegerKinds(_ numbers: [Int]) {<br>    for number in numbers {<br>        switch number.kind {<br>        case .Negative:<br>            print(“- “, terminator: “”)<br>        case .Zero:<br>            print(“0 “, terminator: “”)<br>        case .Positive:<br>            print(“+ “, terminator: “”)<br>        }<br>    }<br>    print(“”)<br>}<br>printIntegerKinds([3, 19, -27, 0, -6, 0, 7])<br>// 打印 “+ + - 0 - 0 + ”<br>函数 printIntegerKinds(_:) 接受一个 Int 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 kind 的值进行评估，并打印出适当的描述。</p>
<p>注意<br>由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。</p>
<p>协议 定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型遵循这个协议。</p>
<p>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</p>
<p>协议语法<br>协议的定义方式与类、结构体和枚举的定义非常相似：</p>
<p>protocol SomeProtocol {<br>    // 这里是协议的定义部分<br>}<br>要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔：</p>
<p>struct SomeStructure: FirstProtocol, AnotherProtocol {<br>    // 这里是结构体的定义部分<br>}<br>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>
<p>class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {<br>    // 这里是类的定义部分<br>}</p>
<p>属性要求<br>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。</p>
<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p>
<p>协议总是用 var 关键字来声明变量属性，在类型声明后加上 { set get } 来表示属性是可读可写的，可读属性则用 { get } 来表示：</p>
<p>protocol SomeProtocol {<br>    var mustBeSettable: Int { get set }<br>    var doesNotNeedToBeSettable: Int { get }<br>}<br>在协议中定义类型属性时，总是使用 static 关键字作为前缀。当类类型遵循协议时，除了 static 关键字，还可以使用 class 关键字来声明类型属性：</p>
<p>protocol AnotherProtocol {<br>    static var someTypeProperty: Int { get set }<br>}<br>如下所示，这是一个只含有一个实例属性要求的协议：</p>
<p>protocol FullyNamed {<br>    var fullName: String { get }<br>}<br>FullyNamed 协议除了要求遵循协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何遵循 FullyNamed 的类型，都必须有一个可读的 String 类型的实例属性 fullName。</p>
<p>下面是一个遵循 FullyNamed 协议的简单结构体：</p>
<p>struct Person: FullyNamed {<br>    var fullName: String<br>}<br>let john = Person(fullName: “John Appleseed”)<br>// john.fullName 为 “John Appleseed”<br>这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 FullyNamed 协议。</p>
<p>Person 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）</p>
<p>下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议：</p>
<p>class Starship: FullyNamed {<br>    var prefix: String?<br>    var name: String<br>    init(name: String, prefix: String? = nil) {<br>        self.name = name<br>        self.prefix = prefix<br>    }<br>    var fullName: String {<br>        return (prefix != nil ? prefix! + “ “ : “”) + name<br>    }<br>}<br>var ncc1701 = Starship(name: “Enterprise”, prefix: “USS”)<br>// ncc1701.fullName 是 “USS Enterprise”<br>Starship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。</p>
<p>方法要求<br>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。</p>
<p>正如属性要求中所述，在协议中定义类方法的时候，总是使用 static 关键字作为前缀。当类类型遵循协议时，除了 static 关键字，还可以使用 class 关键字作为前缀：</p>
<p>protocol SomeProtocol {<br>    static func someTypeMethod()<br>}<br>下面的例子定义了一个只含有一个实例方法的协议：</p>
<p>protocol RandomNumberGenerator {<br>    func random() -&gt; Double<br>}<br>RandomNumberGenerator 协议要求遵循协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。尽管这里并未指明，但是我们假设返回值在 [0.0,1.0) 区间内。</p>
<p>RandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p>
<p>如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。</p>
<p>class LinearCongruentialGenerator: RandomNumberGenerator {<br>    var lastRandom = 42.0<br>    let m = 139968.0<br>    let a = 3877.0<br>    let c = 29573.0<br>    func random() -&gt; Double {<br>        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))<br>        return lastRandom / m<br>    }<br>}<br>let generator = LinearCongruentialGenerator()<br>print(“Here’s a random number: (generator.random())”)<br>// 打印 “Here’s a random number: 0.37464991998171”<br>print(“And another one: (generator.random())”)<br>// 打印 “And another one: 0.729023776863283”</p>
<p>Mutating 方法要求<br>有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 func 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。这一过程在在实例方法中修改值类型章节中有详细描述。</p>
<p>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。</p>
<p>注意<br>实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</p>
<p>如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。</p>
<p>toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：</p>
<p>protocol Togglable {<br>    mutating func toggle()<br>}<br>当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。</p>
<p>下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：</p>
<p>enum OnOffSwitch: Togglable {<br>    case off, on<br>    mutating func toggle() {<br>        switch self {<br>        case .off:<br>            self = .on<br>        case .on:<br>            self = .off<br>        }<br>    }<br>}<br>var lightSwitch = OnOffSwitch.off<br>lightSwitch.toggle()<br>// lightSwitch 现在的值为 .On</p>
<p>构造器要求<br>协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>
<p>protocol SomeProtocol {<br>    init(someParameter: Int)<br>}<br>构造器要求在类中的实现<br>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 required 修饰符：</p>
<p>class SomeClass: SomeProtocol {<br>    required init(someParameter: Int) {<br>        // 这里是构造器的实现部分<br>    }<br>}<br>使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。</p>
<p>关于 required 构造器的更多内容，请参考必要构造器。</p>
<p>注意<br>如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。关于 final 修饰符的更多内容，请参见防止重写。</p>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符：</p>
<p>protocol SomeProtocol {<br>    init()<br>}</p>
<p>class SomeSuperClass {<br>    init() {<br>        // 这里是构造器的实现部分<br>    }<br>}</p>
<p>class SomeSubClass: SomeSuperClass, SomeProtocol {<br>    // 因为遵循协议，需要加上 required<br>    // 因为继承自父类，需要加上 override<br>    required override init() {<br>        // 这里是构造器的实现部分<br>    }<br>}<br>可失败构造器要求<br>协议还可以为遵循协议的类型定义可失败构造器要求，详见可失败构造器。</p>
<p>遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。</p>
<p>协议作为类型<br>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<p>作为函数、方法或构造器中的参数类型或返回值类型<br>作为常量、变量或属性的类型<br>作为数组、字典或其他容器中的元素类型<br>注意<br>协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。</p>
<p>下面是将协议作为类型使用的例子：</p>
<p>class Dice {<br>    let sides: Int<br>    let generator: RandomNumberGenerator<br>    init(sides: Int, generator: RandomNumberGenerator) {<br>        self.sides = sides<br>        self.generator = generator<br>    }<br>    func roll() -&gt; Int {<br>        return Int(generator.random() * Double(sides)) + 1<br>    }<br>}<br>例子中定义了一个 Dice 类，用来代表桌游中拥有 N 个面的骰子。Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。</p>
<p>generator 属性的类型为 RandomNumberGenerator，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给 generator，除此之外并无其他要求。</p>
<p>Dice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。</p>
<p>Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。</p>
<p>下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器来创建一个六面骰子：</p>
<p>var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())<br>for _ in 1…5 {<br>    print(“Random dice roll is (d6.roll())”)<br>}<br>// Random dice roll is 3<br>// Random dice roll is 5<br>// Random dice roll is 4<br>// Random dice roll is 5<br>// Random dice roll is 4</p>
<p>委托（代理）模式<br>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<p>下面的例子定义了两个基于骰子游戏的协议：</p>
<p>protocol DiceGame {<br>    var dice: Dice { get }<br>    func play()<br>}<br>protocol DiceGameDelegate {<br>    func gameDidStart(_ game: DiceGame)<br>    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)<br>    func gameDidEnd(_ game: DiceGame)<br>}<br>DiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。</p>
<p>如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程：</p>
<p>class SnakesAndLadders: DiceGame {<br>    let finalSquare = 25<br>    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())<br>    var square = 0<br>    var board: [Int]<br>    init() {<br>        board = <a href="count: finalSquare + 1, repeatedValue: 0" target="_blank" rel="noopener">Int</a><br>        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>    }<br>    var delegate: DiceGameDelegate?<br>    func play() {<br>        square = 0<br>        delegate?.gameDidStart(self)<br>        gameLoop: while square != finalSquare {<br>            let diceRoll = dice.roll()<br>            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)<br>            switch square + diceRoll {<br>            case finalSquare:<br>                break gameLoop<br>            case let newSquare where newSquare &gt; finalSquare:<br>                continue gameLoop<br>            default:<br>                square += diceRoll<br>                square += board[square]<br>            }<br>        }<br>        delegate?.gameDidEnd(self)<br>    }<br>}<br>关于这个蛇梯棋游戏的详细描述请参阅 控制流 章节中的 Break 部分。</p>
<p>这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）</p>
<p>游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。</p>
<p>注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。</p>
<p>DicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>
<p>因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。</p>
<p>如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议：</p>
<p>class DiceGameTracker: DiceGameDelegate {<br>    var numberOfTurns = 0<br>    func gameDidStart(_ game: DiceGame) {<br>        numberOfTurns = 0<br>        if game is SnakesAndLadders {<br>            print(“Started a new game of Snakes and Ladders”)<br>        }<br>        print(“The game is using a (game.dice.sides)-sided dice”)<br>    }<br>    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {<br>        numberOfTurns += 1<br>        print(“Rolled a (diceRoll)”)<br>    }<br>    func gameDidEnd(_ game: DiceGame) {<br>        print(“The game lasted for (numberOfTurns) turns”)<br>    }<br>}<br>DiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。</p>
<p>gameDidStart(<em>:) 方法从 game 参数获取游戏信息并打印。game 参数是 DiceGame 类型而不是 SnakeAndLadders 类型，所以在gameDidStart(</em>:) 方法中只能访问 DiceGame 协议中的内容。当然了，SnakeAndLadders 的方法也可以在类型转换之后调用。在上例代码中，通过 is 操作符检查 game 是否为 SnakesAndLadders 类型的实例，如果是，则打印出相应的消息。</p>
<p>无论当前进行的是何种游戏，由于 game 符合 DiceGame 协议，可以确保 game 含有 dice 属性。因此在 gameDidStart(_:) 方法中可以通过传入的 game 参数来访问 dice 属性，进而打印出 dice 的 sides 属性的值。</p>
<p>DiceGameTracker 的运行情况如下所示：</p>
<p>let tracker = DiceGameTracker()<br>let game = SnakesAndLadders()<br>game.delegate = tracker<br>game.play()<br>// Started a new game of Snakes and Ladders<br>// The game is using a 6-sided dice<br>// Rolled a 3<br>// Rolled a 5<br>// Rolled a 4<br>// Rolled a 5<br>// The game lasted for 4 turns</p>
<p>通过扩展添加协议一致性<br>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。详情请在扩展章节中查看。</p>
<p>注意<br>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>
<p>例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p>
<p>protocol TextRepresentable {<br>    var textualDescription: String { get }<br>}<br>可以通过扩展，令先前提到的 Dice 类遵循并符合 TextRepresentable 协议：</p>
<p>extension Dice: TextRepresentable {<br>    var textualDescription: String {<br>        return “A (sides)-sided dice”<br>    }<br>}<br>通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p>
<p>现在所有 Dice 的实例都可以看做 TextRepresentable 类型：</p>
<p>let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())<br>print(d12.textualDescription)<br>// 打印 “A 12-sided dice”<br>同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议：</p>
<p>extension SnakesAndLadders: TextRepresentable {<br>    var textualDescription: String {<br>        return “A game of Snakes and Ladders with (finalSquare) squares”<br>    }<br>}<br>print(game.textualDescription)<br>// 打印 “A game of Snakes and Ladders with 25 squares”</p>
<p>通过扩展遵循协议<br>当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议：</p>
<p>struct Hamster {<br>    var name: String<br>    var textualDescription: String {<br>        return “A hamster named (name)”<br>    }<br>}<br>extension Hamster: TextRepresentable {}<br>从现在起，Hamster 的实例可以作为 TextRepresentable 类型使用：</p>
<p>let simonTheHamster = Hamster(name: “Simon”)<br>let somethingTextRepresentable: TextRepresentable = simonTheHamster<br>print(somethingTextRepresentable.textualDescription)<br>// 打印 “A hamster named Simon”<br>注意<br>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p>
<p>协议类型的集合<br>协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：</p>
<p>let things: [TextRepresentable] = [game, d12, simonTheHamster]<br>如下所示，可以遍历 things 数组，并打印每个元素的文本表示：</p>
<p>for thing in things {<br>    print(thing.textualDescription)<br>}<br>// A game of Snakes and Ladders with 25 squares<br>// A 12-sided dice<br>// A hamster named Simon<br>thing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。</p>
<p>协议的继承<br>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p>
<p>protocol InheritingProtocol: SomeProtocol, AnotherProtocol {<br>    // 这里是协议的定义部分<br>}<br>如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：</p>
<p>protocol PrettyTextRepresentable: TextRepresentable {<br>    var prettyTextualDescription: String { get }<br>}<br>例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。在这个例子中，PrettyTextRepresentable 协议额外要求遵循协议的类型提供一个返回值为 String 类型的 prettyTextualDescription 属性。</p>
<p>如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议：</p>
<p>extension SnakesAndLadders: PrettyTextRepresentable {<br>    var prettyTextualDescription: String {<br>        var output = textualDescription + “:\n”<br>        for index in 1…finalSquare {<br>            switch board[index] {<br>            case let ladder where ladder &gt; 0:<br>                output += “▲ “<br>            case let snake where snake &lt; 0:<br>                output += “▼ “<br>            default:<br>                output += “○ “<br>            }<br>        }<br>        return output<br>    }<br>}<br>上述扩展令 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并提供了协议要求的 prettyTextualDescription 属性。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。然后，拼接上了冒号和换行符。接着，遍历数组中的元素，拼接一个几何图形来表示每个棋盘方格的内容：</p>
<p>当从数组中取出的元素的值大于 0 时，用 ▲ 表示。<br>当从数组中取出的元素的值小于 0 时，用 ▼ 表示。<br>当从数组中取出的元素的值等于 0 时，用 ○ 表示。<br>任意 SankesAndLadders 的实例都可以使用 prettyTextualDescription 属性来打印一个漂亮的文本描述：</p>
<p>print(game.prettyTextualDescription)<br>// A game of Snakes and Ladders with 25 squares:<br>// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</p>
<p>类类型专属协议<br>你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：</p>
<p>protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {<br>    // 这里是类类型专属协议的定义部分<br>}<br>在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。</p>
<p>注意<br>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。关于引用语义和值语义的更多内容，请查看结构体和枚举是值类型和类是引用类型。</p>
<p>协议合成<br>有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。</p>
<p>下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>
<p>protocol Named {<br>    var name: String { get }<br>}<br>protocol Aged {<br>    var age: Int { get }<br>}<br>struct Person: Named, Aged {<br>    var name: String<br>    var age: Int<br>}<br>func wishHappyBirthday(to celebrator: Named &amp; Aged) {<br>    print(“Happy birthday, (celebrator.name), you’re (celebrator.age)!”)<br>}<br>let birthdayPerson = Person(name: “Malcolm”, age: 21)<br>wishHappyBirthday(to: birthdayPerson)<br>// 打印 “Happy birthday Malcolm - you’re 21!”<br>Named 协议包含 String 类型的 name 属性。Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。</p>
<p>wishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named &amp; Aged。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。</p>
<p>上面的例子创建了一个名为 birthdayPerson 的 Person 的实例，作为参数传递给了 wishHappyBirthday(to:) 函数。因为 Person 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。</p>
<p>这里有一个例子：将Location类和前面的Named协议进行组合：</p>
<p>class Location {<br>    var latitude: Double<br>    var longitude: Double<br>    init(latitude: Double, longitude: Double) {<br>        self.latitude = latitude<br>        self.longitude = longitude<br>    }<br>}<br>class City: Location, Named {<br>    var name: String<br>    init(name: String, latitude: Double, longitude: Double) {<br>        self.name = name<br>        super.init(latitude: latitude, longitude: longitude)<br>    }<br>}<br>func beginConcert(in location: Location &amp; Named) {<br>    print(“Hello, (location.name)!”)<br>}</p>
<p>let seattle = City(name: “Seattle”, latitude: 47.6, longitude: -122.3)<br>beginConcert(in: seattle)<br>// Prints “Hello, Seattle!”<br>beginConcert(in:)方法接受一个类型为 Location &amp; Named 的参数，这意味着”任何Location的子类，并且遵循Named协议”。例如，City就满足这样的条件。</p>
<p>将 birthdayPerson 传入beginConcert(in:)函数是不合法的，因为 Person不是一个Location的子类。就像，如果你新建一个类继承与Location，但是没有遵循Named协议，你用这个类的实例去调用beginConcert(in:)函数也是不合法的。</p>
<p>检查协议一致性<br>你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>
<p>is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。<br>as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。<br>as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。<br>下面的例子定义了一个 HasArea 协议，该协议定义了一个 Double 类型的可读属性 area：</p>
<p>protocol HasArea {<br>    var area: Double { get }<br>}<br>如下所示，Circle 类和 Country 类都遵循了 HasArea 协议：</p>
<p>class Circle: HasArea {<br>    let pi = 3.1415927<br>    var radius: Double<br>    var area: Double { return pi <em> radius </em> radius }<br>    init(radius: Double) { self.radius = radius }<br>}<br>class Country: HasArea {<br>    var area: Double<br>    init(area: Double) { self.area = area }<br>}<br>Circle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。</p>
<p>如下所示，Animal 是一个未遵循 HasArea 协议的类：</p>
<p>class Animal {<br>    var legs: Int<br>    init(legs: Int) { self.legs = legs }<br>}<br>Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：</p>
<p>let objects: [AnyObject] = [<br>    Circle(radius: 2.0),<br>    Country(area: 243_610),<br>    Animal(legs: 4)<br>]<br>objects 数组使用字面量初始化，数组包含一个 radius 为 2 的 Circle 的实例，一个保存了英国国土面积的 Country 实例和一个 legs 为 4 的 Animal 实例。</p>
<p>如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议：</p>
<p>for object in objects {<br>    if let objectWithArea = object as? HasArea {<br>        print(“Area is (objectWithArea.area)”)<br>    } else {<br>        print(“Something that doesn’t have an area”)<br>    }<br>}<br>// Area is 12.5663708<br>// Area is 243610.0<br>// Something that doesn’t have an area<br>当迭代出的元素符合 HasArea 协议时，将 as? 操作符返回的可选值通过可选绑定，绑定到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性可以被访问和打印。</p>
<p>objects 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 Circle，Country，Animal 类型。然而，当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。</p>
<p>可选的协议要求<br>协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p>
<p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String 的方法会变成 ((Int) -&gt; String)?。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>
<p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。详细内容可在可选链式调用章节中查看。</p>
<p>下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：</p>
<p>@objc protocol CounterDataSource {<br>    @objc optional func incrementForCount(count: Int) -&gt; Int<br>    @objc optional var fixedIncrement: Int { get }<br>}<br>CounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。</p>
<p>注意<br>严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。</p>
<p>Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：</p>
<p>class Counter {<br>    var count = 0<br>    var dataSource: CounterDataSource?<br>    func increment() {<br>        if let amount = dataSource?.incrementForCount?(count) {<br>            count += amount<br>        } else if let amount = dataSource?.fixedIncrement {<br>            count += amount<br>        }<br>    }<br>}<br>Counter 类使用变量属性 count 来存储当前值。该类还定义了一个 increment 方法，每次调用该方法的时候，将会增加 count 的值。</p>
<p>increment() 方法首先试图使用 increment(forCount:) 方法来得到每次的增量。increment() 方法使用可选链式调用来尝试调用 increment(forCount:)，并将当前的 count 值作为参数传入。</p>
<p>这里使用了两层可选链式调用。首先，由于 dataSource 可能为 nil，因此在 dataSource 后边加上了 ?，以此表明只在 dataSource 非空时才去调用 increment(forCount:) 方法。其次，即使 dataSource 存在，也无法保证其是否实现了 increment(forCount:) 方法，因为这个方法是可选的。因此，increment(forCount:) 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 increment(forCount:) 方法后边也加上了 ?。</p>
<p>调用 increment(forCount:) 方法在上述两种情形下都有可能失败，所以返回值为 Int? 类型。虽然在 CounterDataSource 协议中，increment(forCount:) 的返回值类型是非可选 Int。另外，即使这里使用了两层可选链式调用，最后的返回结果依旧是单层的可选类型。关于这一点的更多信息，请查阅连接多层可选链式调用</p>
<p>在调用 increment(forCount:) 方法后，Int? 型的返回值通过可选绑定解包并赋值给常量 amount。如果可选值确实包含一个数值，也就是说，数据源和方法都存在，数据源方法返回了一个有效值。之后便将解包后的 amount 加到 count 上，增量操作完成。</p>
<p>如果没有从 increment(forCount:) 方法获取到值，可能由于 dataSource 为 nil，或者它并没有实现 increment(forCount:) 方法，那么 increment() 方法将试图从数据源的 fixedIncrement 属性中获取增量。fixedIncrement 是一个可选属性，因此属性值是一个 Int? 值，即使该属性在 CounterDataSource 协议中的类型是非可选的 Int。</p>
<p>下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：</p>
<p>class ThreeSource: NSObject, CounterDataSource {<br>    let fixedIncrement = 3<br>}<br>可以使用 ThreeSource 的实例作为 Counter 实例的数据源：</p>
<p>var counter = Counter()<br>counter.dataSource = ThreeSource()<br>for _ in 1…4 {<br>    counter.increment()<br>    print(counter.count)<br>}<br>// 3<br>// 6<br>// 9<br>// 12<br>上述代码新建了一个 Counter 实例，并将它的数据源设置为一个 ThreeSource 的实例，然后调用 increment() 方法四次。和预期一样，每次调用都会将 count 的值增加 3.</p>
<p>下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：</p>
<p>@objc class TowardsZeroSource: NSObject, CounterDataSource {<br>    func increment(forCount count: Int) -&gt; Int {<br>        if count == 0 {<br>            return 0<br>        } else if count &lt; 0 {<br>            return 1<br>        } else {<br>            return -1<br>        }<br>    }<br>}<br>TowardsZeroSource 实现了 CounterDataSource 协议中的 increment(forCount:) 方法，以 count 参数为依据，计算出每次的增量。如果 count 已经为 0，此方法返回 0，以此表明之后不应再有增量操作发生。</p>
<p>你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动：</p>
<p>counter.count = -4<br>counter.dataSource = TowardsZeroSource()<br>for _ in 1…5 {<br>    counter.increment()<br>    print(counter.count)<br>}<br>// -3<br>// -2<br>// -1<br>// 0<br>// 0</p>
<p>协议扩展<br>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<p>例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：</p>
<p>extension RandomNumberGenerator {<br>    func randomBool() -&gt; Bool {<br>        return random() &gt; 0.5<br>    }<br>}<br>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：</p>
<p>let generator = LinearCongruentialGenerator()<br>print(“Here’s a random number: (generator.random())”)<br>// 打印 “Here’s a random number: 0.37464991998171”<br>print(“And here’s a random Boolean: (generator.randomBool())”)<br>// 打印 “And here’s a random Boolean: true”</p>
<p>提供默认实现<br>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<p>注意<br>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
<p>例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：</p>
<p>extension PrettyTextRepresentable  {<br>    var prettyTextualDescription: String {<br>        return textualDescription<br>    }<br>}</p>
<p>为协议扩展添加限制条件<br>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述，正如Where子句中所描述的。</p>
<p>例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况：</p>
<p>extension Collection where Iterator.Element: TextRepresentable {<br>    var textualDescription: String {<br>        let itemsAsText = self.map { $0.textualDescription }<br>        return “[“ + itemsAsText.joined(separator: “, “) + “]”<br>    }<br>}<br>textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。</p>
<p>现在我们来看看先前的 Hamster 结构体，它符合 TextRepresentable 协议，同时这里还有个装有 Hamster 的实例的数组：</p>
<p>let murrayTheHamster = Hamster(name: “Murray”)<br>let morganTheHamster = Hamster(name: “Morgan”)<br>let mauriceTheHamster = Hamster(name: “Maurice”)<br>let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]<br>因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示：</p>
<p>print(hamsters.textualDescription)<br>// 打印 “[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]”<br>注意<br>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</p>
<p>泛型代码让你能够根据自定义的需求，编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 最强大的特性之一，许多 Swift 标准库是通过泛型代码构建的。事实上，泛型的使用贯穿了整本语言手册，只是你可能没有发现而已。例如，Swift 的 Array 和 Dictionary 都是泛型集合。你可以创建一个 Int 数组，也可创建一个 String 数组，甚至可以是任意其他 Swift 类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>
<p>泛型所解决的问题<br>下面是一个标准的非泛型函数 swapTwoInts(_:_:)，用来交换两个 Int 值：</p>
<p>func swapTwoInts(_ a: inout Int, _ b: inout Int) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}<br>这个函数使用输入输出参数（inout）来交换 a 和 b 的值，请参考输入输出参数。</p>
<p>swapTwoInts(_:_:) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值：</p>
<p>var someInt = 3<br>var anotherInt = 107<br>swapTwoInts(&amp;someInt, &amp;anotherInt)<br>print(“someInt is now (someInt), and anotherInt is now (anotherInt)”)<br>// 打印 “someInt is now 107, and anotherInt is now 3”<br>诚然，swapTwoInts(_:<em>:) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(</em>:<em>:) 和 swapTwoDoubles(</em>:_:)，如下所示：</p>
<p>func swapTwoStrings(_ a: inout String, _ b: inout String) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}</p>
<p>func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}<br>你可能注意到 swapTwoInts(_:<em>:)、swapTwoStrings(</em>:<em>:) 和 swapTwoDoubles(</em>:_:) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<p>注意<br>在上面三个函数中，a 和 b 类型必须相同。如果 a 和 b 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 String 类型的变量和一个 Double 类型的变量互换值。试图这样做将导致编译错误。</p>
<p>泛型函数<br>泛型函数可以适用于任何类型，下面的 swapTwoValues(_:_:) 函数是上面三个函数的泛型版本：</p>
<p>func swapTwoValues<t>(_ a: inout T, _ b: inout T) {<br>    let temporaryA = a<br>    a = b<br>    b = temporaryA<br>}<br>swapTwoValues(_:<em>:) 的函数主体和 swapTwoInts(</em>:_:) 函数是一样的，它们只在第一行有点不同，如下所示：</t></p>
<p>func swapTwoInts(_ a: inout Int, _ b: inout Int)<br>func swapTwoValues<t>(_ a: inout T, _ b: inout T)<br>这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(_:_:) 函数在调用时，才会根据所传入的实际类型决定 T 所代表的类型。</t></p>
<p>泛型函数和非泛型函数的另外一个不同之处，在于这个泛型函数名（swapTwoValues(_:<em>:)）后面跟着占位类型名（T），并用尖括号括起来（<t>）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(</t></em>:_:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。</p>
<p>swapTwoValues(_:<em>:) 函数现在可以像 swapTwoInts(</em>:<em>:) 那样调用，不同的是它能接受两个任意类型的值，条件是这两个值有着相同的类型。swapTwoValues(</em>:_:) 函数被调用时，T 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，T 分别代表 Int 和 String：</p>
<p>var someInt = 3<br>var anotherInt = 107<br>swapTwoValues(&amp;someInt, &amp;anotherInt)<br>// someInt 现在 107, and anotherInt 现在 3</p>
<p>var someString = “hello”<br>var anotherString = “world”<br>swapTwoValues(&amp;someString, &amp;anotherString)<br>// someString 现在 “world”, and anotherString 现在 “hello”<br>注意<br>上面定义的 swapTwoValues(_:<em>:) 函数是受 swap(</em>:<em>:) 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 swapTwoValues(</em>:<em>:) 函数的功能，你可以使用已存在的 swap(</em>:_:) 函数。</p>
<p>类型参数<br>在上面的 swapTwoValues(_:_:) 例子中，占位类型 T 是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <t>）。</t></p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(_:<em>:) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(</em>:_:) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<p>命名类型参数<br>在大多数情况下，类型参数具有一个描述性名字，例如 Dictionary&lt;Key, Value&gt; 中的 Key 和 Value，以及 Array<element> 中的 Element，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 T、U、V，正如上面演示的 swapTwoValues(_:_:) 函数中的 T 一样。</element></p>
<p>注意<br>请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
<p>泛型类型<br>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。</p>
<p>这部分内容将向你展示如何编写一个名为 Stack （栈）的泛型集合类型。栈是一系列值的有序集合，和 Array 类似，但它相比 Swift 的 Array 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。</p>
<p>注意<br>栈的概念已被 UINavigationController 类用来构造视图控制器的导航结构。你通过调用 UINavigationController 的 pushViewController(<em>:animated:) 方法来添加新的视图控制器到导航栈，通过 popViewControllerAnimated(</em>:) 方法来从导航栈中移除视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
<p>下图展示了一个栈的入栈（push）和出栈（pop）的行为：</p>
<p>此处输入图片的描述</p>
<p>现在有三个值在栈中。<br>第四个值被压入到栈的顶部。<br>现在有四个值在栈中，最近入栈的那个值在顶部。<br>栈中最顶部的那个值被移除出栈。<br>一个值移除出栈后，现在栈又只有三个值了。<br>下面展示了如何编写一个非泛型版本的栈，以 Int 型的栈为例：</p>
<p>struct IntStack {<br>    var items = <a href="">Int</a><br>    mutating func push(_ item: Int) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Int {<br>        return items.removeLast()<br>    }<br>}<br>这个结构体在栈中使用一个名为 items 的 Array 属性来存储值。Stack 提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。</p>
<p>上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<p>struct Stack<element> {<br>    var items = <a href="">Element</a><br>    mutating func push(_ item: Element) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Element {<br>        return items.removeLast()<br>    }<br>}<br>注意，Stack 基本上和 IntStack 相同，只是用占位类型参数 Element 代替了实际的 Int 类型。这个类型参数包裹在紧随结构体名的一对尖括号里（<element>）。</element></element></p>
<p>Element 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符：</p>
<p>创建 items 属性，使用 Element 类型的空数组对其进行初始化。<br>指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。<br>指定 pop() 方法的返回值类型必须是 Element 类型。<br>由于 Stack 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 Stack 实例。例如，要创建一个 String 类型的栈，可以写成 Stack<string>()：</string></p>
<p>var stackOfStrings = Stack<string>()<br>stackOfStrings.push(“uno”)<br>stackOfStrings.push(“dos”)<br>stackOfStrings.push(“tres”)<br>stackOfStrings.push(“cuatro”)<br>// 栈中现在有 4 个字符串<br>下图展示了 stackOfStrings 如何将这四个值入栈：</string></p>
<p>此处输入图片的描述</p>
<p>移除并返回栈顶部的值 “cuatro”，即将其出栈：</p>
<p>let fromTheTop = stackOfStrings.pop()<br>// fromTheTop 的值为 “cuatro”，现在栈中还有 3 个字符串<br>下图展示了 stackOfStrings 如何将顶部的值出栈：</p>
<p>此处输入图片的描述</p>
<p>扩展一个泛型类型<br>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>
<p>extension Stack {<br>    var topItem: Element? {<br>        return items.isEmpty ? nil : items[items.count - 1]<br>    }<br>}<br>topItem 属性会返回一个 Element 类型的可选值。当栈为空的时候，topItem 会返回 nil；当栈不为空的时候，topItem 会返回 items 数组中的最后一个元素。</p>
<p>注意，这个扩展并没有定义一个类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。</p>
<p>计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它：</p>
<p>if let topItem = stackOfStrings.topItem {<br>    print(“The top item on the stack is (topItem).”)<br>}<br>// 打印 “The top item on the stack is tres.”</p>
<p>类型约束<br>swapTwoValues(_:_:) 函数和 Stack 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<p>例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。Dictionary 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，Dictionary 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>为了实现这个要求，一个类型约束被强制加到 Dictionary 的键类型上，要求其键类型必须符合 Hashable 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。</p>
<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>
<p>类型约束语法<br>你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：</p>
<p>func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {<br>    // 这里是泛型函数的函数体部分<br>}<br>上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。</p>
<p>类型约束实践<br>这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil：</p>
<p>func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? {<br>    for (index, value) in array.enumerated() {<br>        if value == valueToFind {<br>            return index<br>        }<br>    }<br>    return nil<br>}<br>findIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串：</p>
<p>let strings = [“cat”, “dog”, “llama”, “parakeet”, “terrapin”]<br>if let foundIndex = findIndex(ofString: “llama”, in: strings) {<br>    print(“The index of llama is (foundIndex)”)<br>}<br>// 打印 “The index of llama is 2”<br>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以用占位类型 T 替换 String 类型来写出具有相同功能的泛型函数 findIndex(_:_:)。</p>
<p>下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明：</p>
<p>func findIndex<t>(of valueToFind: T, in array:[T]) -&gt; Int? {<br>    for (index, value) in array.enumerated() {<br>        if value == valueToFind {<br>            return index<br>        }<br>    }<br>    return nil<br>}<br>上面所写的函数无法通过编译。问题出在相等性检查上，即 “if value == valueToFind”。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。</t></p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。</p>
<p>任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分：</p>
<p>func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? {<br>    for (index, value) in array.enumerated() {<br>        if value == valueToFind {<br>            return index<br>        }<br>    }<br>    return nil<br>}<br>findIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T ”。</p>
<p>findIndex(of:in:) 函数现在可以成功编译了，并且可以作用于任何符合 Equatable 的类型，如 Double 或 String：</p>
<p>let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])<br>// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中<br>let stringIndex = findIndex(of: “Andrea”, in: [“Mike”, “Malcolm”, “Andrea”])<br>// stringIndex 类型为 Int?，其值为 2</p>
<p>关联类型<br>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</p>
<p>关联类型实践<br>下面例子定义了一个 Container 协议，该协议定义了一个关联类型 ItemType：</p>
<p>protocol Container {<br>    associatedtype ItemType<br>    mutating func append(_ item: ItemType)<br>    var count: Int { get }<br>    subscript(i: Int) -&gt; ItemType { get }<br>}<br>Container 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能：</p>
<p>必须可以通过 append(_:) 方法添加一个新元素到容器里。<br>必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。<br>必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。<br>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 Container 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>
<p>任何遵从 Container 协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素的类型。</p>
<p>为了定义这三个条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为了达到这个目的，Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，ItemType 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能够正如预期地被执行。</p>
<p>下面是先前的非泛型的 IntStack 类型，这一版本采纳并符合了 Container 协议：</p>
<p>struct IntStack: Container {<br>    // IntStack 的原始实现部分<br>    var items = <a href="">Int</a><br>    mutating func push(_ item: Int) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Int {<br>        return items.removeLast()<br>    }<br>    // Container 协议的实现部分<br>    typealias ItemType = Int<br>    mutating func append(_ item: Int) {<br>        self.push(item)<br>    }<br>    var count: Int {<br>        return items.count<br>    }<br>    subscript(i: Int) -&gt; Int {<br>        return items[i]<br>    }<br>}<br>IntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，IntStack 在实现 Container 的要求时，指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。</p>
<p>由于 Swift 的类型推断，你实际上不用在 IntStack 的定义中声明 ItemType 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 ItemType 的具体类型。事实上，如果你在上面的代码中删除了 typealias ItemType = Int 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 ItemType 应该是哪种类型。</p>
<p>你也可以让泛型 Stack 结构体遵从 Container 协议：</p>
<p>struct Stack<element>: Container {<br>    // Stack<element> 的原始实现部分<br>    var items = <a href="">Element</a><br>    mutating func push(_ item: Element) {<br>        items.append(item)<br>    }<br>    mutating func pop() -&gt; Element {<br>        return items.removeLast()<br>    }<br>    // Container 协议的实现部分<br>    mutating func append(_ item: Element) {<br>        self.push(item)<br>    }<br>    var count: Int {<br>        return items.count<br>    }<br>    subscript(i: Int) -&gt; Element {<br>        return items[i]<br>    }<br>}<br>这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。</element></element></p>
<p>通过扩展一个存在的类型来指定关联类型<br>通过扩展添加协议一致性中描述了如何利用扩展让一个已存在的类型符合一个协议，这包括使用了关联类型的协议。</p>
<p>Swift 的 Array 类型已经提供 append(_:) 方法，一个 count 属性，以及一个接受 Int 类型索引值的下标用以检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需简单地声明 Array 采纳该协议就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：</p>
<p>extension Array: Container {}<br>如同上面的泛型 Stack 结构体一样，Array 的 append(_:) 方法和下标确保了 Swift 可以推断出 ItemType 的类型。定义了这个扩展后，你可以将任意 Array 当作 Container 来使用。</p>
<p>约束关联类型<br>你可以给协议里的关联类型添加类型注释，让遵守协议的类型必须遵循这个约束条件。例如，下面的代码定义了一个 Item 必须遵循 Equatable 的 Container 类型：</p>
<p>protocol Container {<br>    associatedtype Item: Equatable<br>    mutating func append(_ item: Item)<br>    var count: Int { get }<br>    subscript(i: Int) -&gt; Item { get }<br>}<br>为了遵守了 Container 协议，Item 类型也必须遵守 Equatable 协议。</p>
<p>泛型 where 语句<br>类型约束让你能够为泛型函数，下标，类型的类型参数定义一些强制要求。</p>
<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 where 子句为关联类型定义约束。你能通过 where 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。</p>
<p>下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。</p>
<p>被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示：</p>
<p>func allItemsMatch&lt;C1: Container, C2: Container&gt;<br>    (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool<br>    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {</p>
<pre><code>// 检查两个容器含有相同数量的元素
if someContainer.count != anotherContainer.count {
    return false
}

// 检查每一对元素是否相等
for i in 0..&lt;someContainer.count {
    if someContainer[i] != anotherContainer[i] {
        return false
    }
}

// 所有元素都匹配，返回 true
return true
</code></pre><p>}<br>这个函数接受 someContainer 和 anotherContainer 两个参数。参数 someContainer 的类型为 C1，参数 anotherContainer 的类型为 C2。C1 和 C2 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了对两个类型参数的要求：</p>
<p>C1 必须符合 Container 协议（写作 C1: Container）。<br>C2 必须符合 Container 协议（写作 C2: Container）。<br>C1 的 ItemType 必须和 C2 的 ItemType类型相同（写作 C1.ItemType == C2.ItemType）。<br>C1 的 ItemType 必须符合 Equatable 协议（写作 C1.ItemType: Equatable）。<br>第三个和第四个要求被定义为一个 where 子句，写在关键字 where 后面，它们也是泛型函数类型参数列表的一部分。</p>
<p>这些要求意味着：</p>
<p>someContainer 是一个 C1 类型的容器。<br>anotherContainer 是一个 C2 类型的容器。<br>someContainer 和 anotherContainer 包含相同类型的元素。<br>someContainer 中的元素可以通过不等于操作符（!=）来检查它们是否彼此不同。<br>第三个和第四个要求结合起来意味着 anotherContainer 中的元素也可以通过 != 操作符来比较，因为它们和 someContainer 中的元素类型相同。</p>
<p>这些要求让 allItemsMatch(_:_:) 函数能够比较两个容器，即使它们的容器类型不同。</p>
<p>allItemsMatch(_:_:) 函数首先检查两个容器是否拥有相同数量的元素，如果它们的元素数量不同，那么一定不匹配，函数就会返回 false。</p>
<p>进行这项检查之后，通过 for-in 循环和半闭区间操作符（..&lt;）来迭代每个元素，检查 someContainer 中的元素是否不等于 anotherContainer 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 false。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 true。</p>
<p>下面演示了 allItemsMatch(_:_:) 函数的使用：</p>
<p>var stackOfStrings = Stack<string>()<br>stackOfStrings.push(“uno”)<br>stackOfStrings.push(“dos”)<br>stackOfStrings.push(“tres”)</string></p>
<p>var arrayOfStrings = [“uno”, “dos”, “tres”]</p>
<p>if allItemsMatch(stackOfStrings, arrayOfStrings) {<br>    print(“All items match.”)<br>} else {<br>    print(“Not all items match.”)<br>}<br>// 打印 “All items match.”<br>上面的例子创建了一个 Stack 实例来存储一些 String 值，然后将三个字符串压入栈中。这个例子还通过数组字面量创建了一个 Array 实例，数组中包含同栈中一样的三个字符串。即使栈和数组是不同的类型，但它们都遵从 Container 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 allItemsMatch(_:<em>:) 函数。在上面的例子中，allItemsMatch(</em>:_:) 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
<p>具有泛型 where 子句的扩展<br>你也可以使用泛型 where 子句作为扩展的一部分。基于以前的例子，下面的示例扩展了泛型 Stack 结构体，添加一个 isTop(_:) 方法。</p>
<p>extension Stack where Element: Equatable {<br>    func isTop(_ item: Element) -&gt; Bool {<br>        guard let topItem = items.last else {<br>            return false<br>        }<br>        return topItem == item<br>    }<br>}<br>这个新的 isTop(<em>:) 方法首先检查这个栈是不是空的，然后比较给定的元素与栈顶部的元素。如果你尝试不用泛型 where 子句，会有一个问题：在 isTop(</em>:) 里面使用了 == 运算符，但是 Stack 的定义没有要求它的元素是符合 Equatable 协议的，所以使用 == 运算符导致编译时错误。使用泛型 where 子句可以为扩展添加新的条件，因此只有当栈中的元素符合 Equatable 协议时，扩展才会添加 isTop(_:) 方法。</p>
<p>以下是 isTop(_:) 方法的调用方式：</p>
<p>if stackOfStrings.isTop(“tres”) {<br>    print(“Top element is tres.”)<br>} else {<br>    print(“Top element is something else.”)<br>}<br>// 打印 “Top element is tres.”<br>如果尝试在其元素不符合 Equatable 协议的栈上调用 isTop(_:) 方法，则会收到编译时错误。</p>
<p>struct NotEquatable { }<br>var notEquatableStack = Stack<notequatable>()<br>let notEquatableValue = NotEquatable()<br>notEquatableStack.push(notEquatableValue)<br>notEquatableStack.isTop(notEquatableValue)  // 报错<br>你可以使用泛型 where 子句去扩展一个协议。基于以前的示例，下面的示例扩展了 Container 协议，添加一个 startsWith(_:) 方法。</notequatable></p>
<p>extension Container where Item: Equatable {<br>    func startsWith(_ item: Item) -&gt; Bool {<br>        return count &gt;= 1 &amp;&amp; self[0] == item<br>    }<br>}<br>这个 startsWith(<em>:) 方法首先确保容器至少有一个元素，然后检查容器中的第一个元素是否与给定的元素相等。任何符合 Container 协议的类型都可以使用这个新的 startsWith(</em>:) 方法，包括上面使用的栈和数组，只要容器的元素是符合 Equatable 协议的。</p>
<p>if [9, 9, 9].startsWith(42) {<br>    print(“Starts with 42.”)<br>} else {<br>    print(“Starts with something else.”)<br>}<br>// 打印 “Starts with something else.”<br>上述示例中的泛型 where 子句要求 Item 符合协议，但也可以编写一个泛型 where 子句去要求 Item 为特定类型。例如：</p>
<p>extension Container where Item == Double {<br>    func average() -&gt; Double {<br>        var sum = 0.0<br>        for index in 0..&lt;count {<br>            sum += self[index]<br>        }<br>        return sum / Double(count)<br>    }<br>}<br>print([1260.0, 1200.0, 98.6, 37.0].average())<br>// 打印 “648.9”<br>此示例将一个 average() 方法添加到 Item 类型为 Double 的容器中。此方法遍历容器中的元素将其累加，并除以容器的数量计算平均值。它将数量从 Int 转换为 Double 确保能够进行浮点除法。</p>
<p>就像可以在其他地方写泛型 where 子句一样，你可以在一个泛型 where 子句中包含多个条件作为扩展的一部分。用逗号分隔列表中的每个条件。</p>
<p>具有泛型 where 子句的关联类型<br>你可以在关联类型后面加上具有泛型 where 的字句。例如，建立一个包含迭代器（Iterator）的容器，就像是标准库中使用的 Sequence 协议那样。你应该这么写：</p>
<p>protocol Container {<br>    associatedtype Item<br>    mutating func append(_ item: Item)<br>    var count: Int { get }<br>    subscript(i: Int) -&gt; Item { get }</p>
<pre><code>associatedtype Iterator: IteratorProtocol where Iterator.Element == Item
func makeIterator() -&gt; Iterator
</code></pre><p>}<br>迭代器（Iterator）的泛型 where 子句要求：无论迭代器是什么类型，迭代器中的元素类型，必须和容器项目的类型保持一致。makeIterator() 则提供了容器的迭代器的访问接口。</p>
<p>一个协议继承了另一个协议，你通过在协议声明的时候，包含泛型 where 子句，来添加了一个约束到被继承协议的关联类型。例如，下面的代码声明了一个 ComparableContainer 协议，它要求所有的 Item 必须是 Comparable 的。</p>
<p>protocol ComparableContainer: Container where Item: Comparable { }</p>
<p>泛型下标<br>下标能够是泛型的，他们能够包含泛型 where 子句。你可以把占位符类型的名称写在 subscript 后面的尖括号里，在下标代码体开始的标志的花括号之前写下泛型 where 子句。例如：</p>
<p>extension Container {<br>    subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item]<br>        where Indices.Iterator.Element == Int {<br>            var result = <a href="">Item</a><br>            for index in indices {<br>                result.append(self[index])<br>            }<br>            return result<br>    }<br>}<br>这个 Container 协议的扩展添加了一个下标方法，接收一个索引的集合，返回每一个索引所在的值的数组。这个泛型下标的约束如下：</p>
<p>这个 Container 协议的扩展添加了一个下标：下标是一个序列的索引，返回的则是索引所在的项目的值所构成的数组。这个泛型下标的约束如下：</p>
<p>在尖括号中的泛型参数 Indices，必须是符合标准库中的 Sequence 协议的类型。<br>下标使用的单一的参数，indices，必须是 Indices 的实例。<br>泛型 where 子句要求 Sequence（Indices）的迭代器，其所有的元素都是 Int 类型。这样就能确保在序列（Sequence）中的索引和容器(Container)里面的索引类型是一致的。<br>综合一下，这些约束意味着，传入到 indices 下标，是一个整型的序列. (译者：原来的 Container 协议，subscript 必须是 Int 型的，扩展中新的 subscript，允许下标是一个的序列，而非单一的值。)</p>
<p>除了在之前介绍过的基本运算符，Swift 中还有许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。</p>
<p>与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（&amp;+）。所有的这些溢出运算符都是以 &amp; 开头的。</p>
<p>自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中自定义运算符非常简单，运算符也会针对不同类型使用对应实现。</p>
<p>我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，以及相应的优先级与结合性。这些运算符在代码中可以像预定义的运算符一样使用，我们甚至可以扩展已有的类型以支持自定义的运算符。</p>
<p>位运算符<br>位运算符可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。</p>
<p>Swift 支持 C 语言中的全部位运算符，接下来会一一介绍。</p>
<p>按位取反运算符<br>按位取反运算符（~）可以对一个数值的全部比特位进行取反：</p>
<p>Art/bitwiseNOT_2x.png</p>
<p>按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能添加任何空格：</p>
<p>let initialBits: UInt8 = 0b00001111<br>let invertedBits = ~initialBits // 等于 0b11110000<br>UInt8 类型的整数有 8 个比特位，可以存储 0 ~ 255 之间的任意整数。这个例子初始化了一个 UInt8 类型的整数，并赋值为二进制的 00001111，它的前 4 位都为 0，后 4 位都为 1。这个值等价于十进制的 15。</p>
<p>接着使用按位取反运算符创建了一个名为 invertedBits 的常量，这个常量的值与全部位取反后的 initialBits 相等。即所有的 0 都变成了 1，同时所有的 1 都变成 0。invertedBits 的二进制值为 11110000，等价于无符号十进制数的 240。</p>
<p>按位与运算符<br>按位与运算符（&amp;）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位都为 1 的时候，新数的对应位才为 1：</p>
<p>Art/bitwiseAND_2x.png</p>
<p>在下面的示例当中，firstSixBits 和 lastSixBits 中间 4 个位的值都为 1。按位与运算符对它们进行了运算，得到二进制数值 00111100，等价于无符号十进制数的 60：</p>
<p>let firstSixBits: UInt8 = 0b11111100<br>let lastSixBits: UInt8  = 0b00111111<br>let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100</p>
<p>按位或运算符<br>按位或运算符（|）可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有任意一个为 1 时，新数的对应位就为 1：</p>
<p>Art/bitwiseOR_2x.png</p>
<p>在下面的示例中，someBits 和 moreBits 不同的位会被设置为 1。接位或运算符对它们进行了运算，得到二进制数值 11111110，等价于无符号十进制数的 254：</p>
<p>let someBits: UInt8 = 0b10110010<br>let moreBits: UInt8 = 0b01011110<br>let combinedbits = someBits | moreBits // 等于 11111110</p>
<p>按位异或运算符<br>按位异或运算符（^）可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 1：</p>
<p>Art/bitwiseXOR_2x.png</p>
<p>在下面的示例当中，firstBits 和 otherBits 都有一个自己的位为 1 而对方的对应位为 0 的位。 按位异或运算符将新数的这两个位都设置为 1，同时将其它位都设置为 0：</p>
<p>let firstBits: UInt8 = 0b00010100<br>let otherBits: UInt8 = 0b00000101<br>let outputBits = firstBits ^ otherBits // 等于 00010001</p>
<p>按位左移、右移运算符<br>按位左移运算符（&lt;&lt;）和按位右移运算符（&gt;&gt;）可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。</p>
<p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。</p>
<p>无符号整数的移位运算<br>对无符号整数进行移位的规则如下：</p>
<p>已经存在的位按指定的位数进行左移和右移。<br>任何因移动而超出整型存储范围的位都会被丢弃。<br>用 0 来填充移位后产生的空白位。<br>这种方法称为逻辑移位。</p>
<p>以下这张图展示了 11111111 &lt;&lt; 1（即把 11111111 向左移动 1 位），和 11111111 &gt;&gt; 1（即把 11111111 向右移动 1 位）的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的：</p>
<p>Art/bitshiftUnsigned_2x.png</p>
<p>下面的代码演示了 Swift 中的移位运算：</p>
<p>let shiftBits: UInt8 = 4 // 即二进制的 00000100<br>shiftBits &lt;&lt; 1           // 00001000<br>shiftBits &lt;&lt; 2           // 00010000<br>shiftBits &lt;&lt; 5           // 10000000<br>shiftBits &lt;&lt; 6           // 00000000<br>shiftBits &gt;&gt; 2           // 00000001<br>可以使用移位运算对其他的数据类型进行编码和解码：</p>
<p>let pink: UInt32 = 0xCC6699<br>let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16  // redComponent 是 0xCC，即 204<br>let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102<br>let blueComponent = pink &amp; 0x0000FF         // blueComponent 是 0x99，即 153<br>这个示例使用了一个命名为 pink 的 UInt32 型常量来存储 CSS 中粉色的颜色值。该 CSS 的十六进制颜色值 #CC6699，在 Swift 中表示为 0xCC6699。然后利用按位与运算符（&amp;）和按位右移运算符（&gt;&gt;）从这个颜色值中分解出红（CC）、绿（66）以及蓝（99）三个部分。</p>
<p>红色部分是通过对 0xCC6699 和 0xFF0000 进行按位与运算后得到的。0xFF0000 中的 0 部分“掩盖”了 OxCC6699 中的第二、第三个字节，使得数值中的 6699 被忽略，只留下 0xCC0000。</p>
<p>然后，再将这个数按向右移动 16 位（&gt;&gt; 16）。十六进制中每两个字符表示 8 个比特位，所以移动 16 位后 0xCC0000 就变为 0x0000CC。这个数和0xCC是等同的，也就是十进制数值的 204。</p>
<p>同样的，绿色部分通过对 0xCC6699 和 0x00FF00 进行按位与运算得到 0x006600。然后将这个数向右移动 8 位，得到 0x66，也就是十进制数值的 102。</p>
<p>最后，蓝色部分通过对 0xCC6699 和 0x0000FF 进行按位与运算得到 0x000099。这里不需要再向右移位，所以结果为 0x99 ，也就是十进制数值的 153。</p>
<p>有符号整数的移位运算<br>对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特位的有符号整数的，但是其中的原理对任何位数的有符号整数都是通用的。）</p>
<p>有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。符号位为 0 代表正数，为 1 代表负数。</p>
<p>其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起。这是值为 4 的 Int8 型整数的二进制位表现形式：</p>
<p>Art/bitshiftSignedFour_2x.png</p>
<p>符号位为 0，说明这是一个正数，另外 7 位则代表了十进制数值 4 的二进制表示。</p>
<p>负数的存储方式略有不同。它存储的值的绝对值等于 2 的 n 次方减去它的实际值（也就是数值位表示的值），这里的 n 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 2 的 7 次方，即 128。</p>
<p>这是值为 -4 的 Int8 型整数的二进制位表现形式：</p>
<p>Art/bitshiftSignedMinusFour_2x.png</p>
<p>这次的符号位为 1，说明这是一个负数，另外 7 个位则代表了数值 124（即 128 - 4）的二进制表示：</p>
<p>Art/bitshiftSignedMinusFourValue_2x.png</p>
<p>负数的表示通常被称为二进制补码表示。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。</p>
<p>首先，如果想对 -1 和 -4 进行加法运算，我们只需要将这两个数的全部 8 个比特位进行相加，并且将计算结果中超出 8 位的数值丢弃：</p>
<p>Art/bitshiftSignedAddition_2x.png</p>
<p>其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：</p>
<p>当对整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 0。<br>Art/bitshiftSigned_2x.png</p>
<p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为算术移位。</p>
<p>由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 0。在移位的过程中保持符号位不变，意味着负整数在接近 0 的过程中会一直保持为负。</p>
<p>溢出运算符<br>在默认情况下，当向一个整数赋予超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为为我们在运算过大或着过小的数的时候提供了额外的安全性。</p>
<p>例如，Int16 型整数能容纳的有符号整数范围是 -32768 到 32767，当为一个 Int16 型变量赋的值超过这个范围时，系统就会报错：</p>
<p>var potentialOverflow = Int16.max<br>// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数<br>potentialOverflow += 1<br>// 这里会报错<br>为过大或者过小的数值提供错误处理，能让我们在处理边界值时更加灵活。</p>
<p>然而，也可以选择让系统在数值溢出的时候采取截断处理，而非报错。可以使用 Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 &amp; 开头的：</p>
<p>溢出加法 &amp;+<br>溢出减法 &amp;-<br>溢出乘法 &amp;*</p>
<p>数值溢出<br>数值有可能出现上溢或者下溢。</p>
<p>这个示例演示了当我们对一个无符号整数使用溢出加法（&amp;+）进行上溢运算时会发生什么：</p>
<p>var unsignedOverflow = UInt8.max<br>// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255<br>unsignedOverflow = unsignedOverflow &amp;+ 1<br>// 此时 unsignedOverflow 等于 0<br>unsignedOverflow 被初始化为 UInt8 所能容纳的最大整数（255，以二进制表示即 11111111）。然后使用了溢出加法运算符（&amp;+）对其进行加 1 运算。这使得它的二进制表示正好超出 UInt8 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 UInt8 边界内的值是 00000000，也就是十进制数值的 0。</p>
<p>Art/overflowAddition_2x.png</p>
<p>同样地，当我们对一个无符号整数使用溢出减法（&amp;-）进行下溢运算时也会产生类似的现象：</p>
<p>var unsignedOverflow = UInt8.min<br>// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0<br>unsignedOverflow = unsignedOverflow &amp;- 1<br>// 此时 unsignedOverflow 等于 255<br>UInt8 型整数能容纳的最小值是 0，以二进制表示即 00000000。当使用溢出减法运算符对其进行减 1 运算时，数值会产生下溢并被截断为 11111111， 也就是十进制数值的 255。</p>
<p>Art/overflowUnsignedSubtraction_2x.png</p>
<p>溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算，正如按位左移、右移运算符所描述的。</p>
<p>var signedOverflow = Int8.min<br>// signedOverflow 等于 Int8 所能容纳的最小整数 -128<br>signedOverflow = signedOverflow &amp;- 1<br>// 此时 signedOverflow 等于 127<br>Int8 型整数能容纳的最小值是 -128，以二进制表示即 10000000。当使用溢出减法运算符对其进行减 1 运算时，符号位被翻转，得到二进制数值 01111111，也就是十进制数值的 127，这个值也是 Int8 型整数所能容纳的最大值。</p>
<p>Art/overflowSignedSubtraction_2x.png</p>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<p>优先级和结合性<br>运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。</p>
<p>结合性定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将这意思理解为“它们是与左边的表达式结合的”或者“它们是与右边的表达式结合的”。</p>
<p>在复合表达式的运算顺序中，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 17。</p>
<p>2 + 3 % 4 * 5<br>// 结果是 17<br>如果完全从左到右进行运算，则运算的过程是这样的：</p>
<p>2 + 3 = 5<br>5 % 4 = 1<br>1 <em> 5 = 5<br>但是正确答案是 17 而不是 5。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（</em>）与取余运算符（%）的优先级高于加法运算符（+）。因此，它们的计算顺序要先于加法运算。</p>
<p>而乘法与取余的优先级相同。这时为了得到正确的运算顺序，还需要考虑结合性。乘法与取余运算都是左结合的。可以将这考虑成为这两部分表达式都隐式地加上了括号：</p>
<p>2 + ((3 % 4) * 5)<br>(3 % 4) 等于 3，所以表达式相当于：</p>
<p>2 + (3 <em> 5)<br>3 </em> 5 等于 15，所以表达式相当于：</p>
<p>2 + 15<br>因此计算结果为 17。</p>
<p>如果想查看完整的 Swift 运算符优先级和结合性规则，请参考表达式。如果想查看 Swift 标准库提供所有的运算符，请查看 Swift Standard Library Operators Reference。</p>
<p>注意<br>相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致的。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。</p>
<p>运算符函数<br>类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。</p>
<p>下面的例子展示了如何为自定义的结构体实现加法运算符（+）。算术加法运算符是一个双目运算符，因为它可以对两个值进行运算，同时它还是中缀运算符，因为它出现在两个值中间。</p>
<p>例子中定义了一个名为 Vector2D 的结构体用来表示二维坐标向量 (x, y)，紧接着定义了一个可以对两个 Vector2D 结构体进行相加的运算符函数：</p>
<p>struct Vector2D {<br>    var x = 0.0, y = 0.0<br>}</p>
<p>extension Vector2D {<br>    static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: left.x + right.x, y: left.y + right.y)<br>    }<br>}<br>该运算符函数被定义为 Vector2D 上的一个类方法，并且函数的名字与它要进行重载的 + 名字一致。因为加法运算并不是一个向量必需的功能，所以这个类方法被定义在 Vector2D 的一个扩展中，而不是 Vector2D 结构体声明内。而算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 Vector2D 的参数，同时有一个 Vector2D 类型的返回值。</p>
<p>在这个实现中，输入参数分别被命名为 left 和 right，代表在 + 运算符左边和右边的两个 Vector2D 实例。函数返回了一个新的 Vector2D 实例，这个实例的 x 和 y 分别等于作为参数的两个实例的 x 和 y 的值之和。</p>
<p>这个类方法可以在任意两个 Vector2D 实例中间作为中缀运算符来使用：</p>
<p>let vector = Vector2D(x: 3.0, y: 1.0)<br>let anotherVector = Vector2D(x: 2.0, y: 4.0)<br>let combinedVector = vector + anotherVector<br>// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)<br>这个例子实现两个向量 (3.0，1.0) 和 (2.0，4.0) 的相加，并得到新的向量 (5.0，5.0)。这个过程如下图示：</p>
<p>Art/vectorAddition_2x.png</p>
<p>前缀和后缀运算符<br>上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 -a），而当它出现在值之后时，它就是后缀的（例如 b!）。</p>
<p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 修饰符：</p>
<p>extension Vector2D {<br>    static prefix func - (vector: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: -vector.x, y: -vector.y)<br>    }<br>}<br>这段代码为 Vector2D 类型实现了单目负号运算符。由于该运算符是前缀运算符，所以这个函数需要加上 prefix 修饰符。</p>
<p>对于简单数值，单目负号运算符可以对它们的正负性进行改变。对于 Vector2D 来说，该运算将其 x 和 y 属性的正负性都进行了改变：</p>
<p>let positive = Vector2D(x: 3.0, y: 4.0)<br>let negative = -positive<br>// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例<br>let alsoPositive = -negative<br>// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例</p>
<p>复合赋值运算符<br>复合赋值运算符将赋值运算符（=）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（+=）。在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改。</p>
<p>extension Vector2D {<br>    static func += (left: inout Vector2D, right: Vector2D) {<br>        left = left + right<br>    }<br>}<br>因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：</p>
<p>var original = Vector2D(x: 1.0, y: 2.0)<br>let vectorToAdd = Vector2D(x: 3.0, y: 4.0)<br>original += vectorToAdd<br>// original 的值现在为 (4.0, 6.0)<br>注意<br>不能对默认的赋值运算符（=）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （a ? b : c） 进行重载。</p>
<p>等价运算符<br>自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（==）与“不等”运算符（!=）。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。</p>
<p>为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：</p>
<p>extension Vector2D {<br>    static func == (left: Vector2D, right: Vector2D) -&gt; Bool {<br>        return (left.x == right.x) &amp;&amp; (left.y == right.y)<br>    }<br>    static func != (left: Vector2D, right: Vector2D) -&gt; Bool {<br>        return !(left == right)<br>    }<br>}<br>上述代码实现了“相等”运算符（==）来判断两个 Vector2D 实例是否相等。对于 Vector2D 类型来说，“相等”意味着“两个实例的 x 属性和 y 属性都相等”，这也是代码中用来进行判等的逻辑。示例里同时也实现了“不等”运算符（!=），它简单地将“相等”运算符的结果进行取反后返回。</p>
<p>现在我们可以使用这两个运算符来判断两个 Vector2D 实例是否相等：</p>
<p>let twoThree = Vector2D(x: 2.0, y: 3.0)<br>let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)<br>if twoThree == anotherTwoThree {<br>    print(“These two vectors are equivalent.”)<br>}<br>// 打印 “These two vectors are equivalent.”</p>
<p>自定义运算符<br>除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。可以用来自定义运算符的字符列表请参考运算符。</p>
<p>新的运算符要使用 operator 关键字在全局作用域内进行定义，同时还要指定 prefix、infix 或者 postfix 修饰符：</p>
<p>prefix operator +++<br>上面的代码定义了一个新的名为 +++ 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因此我们针对 Vector2D 的实例来定义它的意义。对这个示例来讲，+++ 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵对自身进行相加，从而让 Vector2D 实例的 x 属性和 y 属性的值翻倍。实现 +++ 运算符的方式如下：</p>
<p>extension Vector2D {<br>    static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {<br>        vector += vector<br>        return vector<br>    }<br>}</p>
<p>var toBeDoubled = Vector2D(x: 1.0, y: 4.0)<br>let afterDoubling = +++toBeDoubled<br>// toBeDoubled 现在的值为 (2.0, 8.0)<br>// afterDoubling 现在的值也为 (2.0, 8.0)</p>
<p>自定义中缀运算符的优先级<br>每个自定义中缀运算符都属于某个优先级组。这个优先级组指定了这个运算符和其他中缀运算符的优先级和结合性。优先级和结合性中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。</p>
<p>而没有明确放入优先级组的自定义中缀运算符会放到一个默认的优先级组内，其优先级高于三元运算符。</p>
<p>以下例子定义了一个新的自定义中缀运算符 +-，此运算符属于 AdditionPrecedence 优先组：</p>
<p>infix operator +-: AdditionPrecedence<br>extension Vector2D {<br>    static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {<br>        return Vector2D(x: left.x + right.x, y: left.y - right.y)<br>    }<br>}<br>let firstVector = Vector2D(x: 1.0, y: 2.0)<br>let secondVector = Vector2D(x: 3.0, y: 4.0)<br>let plusMinusVector = firstVector +- secondVector<br>// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)<br>这个运算符把两个向量的 x 值相加，同时用第一个向量的 y 值减去第二个向量的 y 值。因为它本质上是属于“相加型”运算符，所以将它放置 + 和 - 等默认的中缀“相加型”运算符相同的优先级组中。关于 Swift 标准库提供的运算符，以及完整的运算符优先级组和结合性设置，请参考 Swift Standard Library Operators Reference。而更多关于优先级组以及自定义操作符和优先级组的语法，请参考运算符声明</p>
<p>注意<br>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/20180113dsYM分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/20180113dsYM分析/" itemprop="url">dSYM你是如何分析的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-13T10:11:12+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>dSYM你是如何分析的<br>方法1 使用XCode<br>这种方法可能是最容易的方法了。</p>
<p>要使用Xcode符号化 crash log，你需要下面所列的3个文件：<br>crash报告（.crash文件）<br>符号文件 (.dsymb文件)<br>应用程序文件 (appName.app文件，把IPA文件后缀改为zip，然后解压，Payload目录下的appName.app文件), 这里的appName是你的应用程序的名称。<br>把这3个文件放到同一个目录下，打开Xcode的Window菜单下的organizer，然后点击Devices tab，然后选中左边的Device Logs。<br>然后把.crash文件拖到Device Logs或者选择下面的import导入.crash文件。<br>这样你就可以看到crash的详细log了。<br>方法2 使用命令行工具symbolicatecrash<br>有时候Xcode不能够很好的符号化crash文件。我们这里介绍如何通过symbolicatecrash来手动符号化crash log。<br>在处理之前，请依然将“.app“, “.dSYM”和 “.crash”文件放到同一个目录下。现在打开终端(Terminal)然后输入如下的命令：<br>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer<br>然后输入命令：<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash appName.crash appName.app &gt; appName.log<br>现在，符号化的crash log就保存在appName.log中了。<br>方法3 使用命令行工具atos<br>如果你有多个“.ipa”文件，多个”.dSYMB”文件，你并不太确定到底“dSYMB”文件对应哪个”.ipa”文件，那么，这个方法就非常适合你。<br>特别当你的应用发布到多个渠道的时候，你需要对不同渠道的crash文件，写一个自动化的分析脚本的时候，这个方法就极其有用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yida</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yida</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
