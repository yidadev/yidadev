<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="益达的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="益达的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="益达的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>益达的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">益达的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/18/shell脚本常用参数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/shell脚本常用参数/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-18T23:27:01+08:00">
                2018-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>shell的常用关键字</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">echo "shell 输出脚本名称及参数";</span><br><span class="line">echo "执行的脚本名: $0 ";</span><br><span class="line">echo "第一个参数： $1";</span><br><span class="line">echo "第二个参数： $2";</span><br><span class="line">echo "传递到脚本的参数 $#"</span><br><span class="line">echo "脚本运行的当前进程ID号 $$"</span><br><span class="line"></span><br><span class="line">以一个单字符串显示所有向脚本传递的参数。</span><br><span class="line">如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</span><br><span class="line">echo "-- \$* 演示 ---"</span><br><span class="line">for i in "$*"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//拼接字符串</span><br><span class="line">your_name="qinjx"</span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, $&#123;your_name&#125; !"</span><br><span class="line"></span><br><span class="line">//获取字符串的长度</span><br><span class="line">string="abcd" echo $&#123;#string&#125; #输出 4</span><br><span class="line"></span><br><span class="line">//提取字符串</span><br><span class="line">string="runoob is a great site"</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>
<p>数组的定义：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"></span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br><span class="line"></span><br><span class="line">读取数组：</span><br><span class="line">$&#123;数组名[下标] valuen=$&#123;array_name[n]&#125;</span><br><span class="line">echo $&#123;array_name[@]&#125;  使用@符号可以获取数组中的所有元素</span><br><span class="line"></span><br><span class="line"># 取得数组元素的个数</span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure></p>
<p>expr<br>(1).”string : REGEX”字符串匹配示例。要输出匹配到的字符串结果，需要使用”(“和”)“，否则返回的将是匹配到的字符串数量。<br>(2).”index string chars”用法示例。<br>(3).”substr string pos len”用法示例。</p>
<p>数字</p>
<p>-eq    检测两个数是否相等，相等返回 true。<br>ne    检测两个数是否相等，不相等返回 true。    [ $a -ne $b ]<br>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ]<br>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ]<br>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ]<br>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]</p>
<p>if [ $a -eq $b ]<br>then<br>   echo “$a -eq $b : a 等于 b”<br>else<br>   echo “$a -eq $b: a 不等于 b”<br>fi</p>
<p>!    非运算，表达式为 true 则返回 false，否则返回 true。    [ ! false ]<br>-o    或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ]<br>-a    与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ]</p>
<p>&amp;&amp;    逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false<br>||    逻辑的 OR    [[ $a -lt 100 || $b -gt 100 ]] 返回 true</p>
<p>字符串：</p>
<p>=    检测两个字符串是否相等，相等返回 true。    [ $a = $b ] 返回 false。<br>!=    检测两个字符串是否相等，不相等返回 true。    [ $a != $b ] 返回 true。<br>-z    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。<br>-n    检测字符串长度是否为0，不为0返回 true。    [ -n $a ] 返回 true。<br>str    检测字符串是否为空，不为空返回 true。    [ $a ] 返回 true。</p>
<p>-b file    检测文件是否是块设备文件，如果是，则返回 true。    [ -b $file ]<br>-c file    检测文件是否是字符设备文件，如果是，则返回 true。    [ -c $file ]<br>-d file    检测文件是否是目录，如果是，则返回 true。    [ -d $file ]<br>-f file    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    [ -f $file ] 返回 true。<br>-g file    检测文件是否设置了 SGID 位，如果是，则返回 true。    [ -g $file ] ]<br>-k file    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。    [ -k $file ] 返回 false。<br>-p file    检测文件是否是有名管道，如果是，则返回 true。    [ -p $file ] 返回 false。<br>-u file    检测文件是否设置了 SUID 位，如果是，则返回 true。    [ -u $file ] 返回 false。<br>-r file    检测文件是否可读，如果是，则返回 true。    [ -r $file ] 返回 true。<br>-w file    检测文件是否可写，如果是，则返回 true。    [ -w $file ] 返回 true。<br>-x file    检测文件是否可执行，如果是，则返回 true。    [ -x $file ] 返回 true。<br>-s file    检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file ] 返回 true。<br>-e file    检测文件（包括目录）是否存在，如果是，则返回 true。    [ -e $file ] 返回 true。</p>
<p>//输出到文件<br>echo “It is a test” &gt; myfile<br>echo <code>date</code>输出时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/路由的文档分析20180329/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/路由的文档分析20180329/" itemprop="url">路由分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-29T10:11:12+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于我们常见的路由的整理：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/26/162602099053e6f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>首先JLRoute是受URL Scheme思路的影响。它把所有对资源的请求看成是一个URI。<br><img src="https://user-gold-cdn.xitu.io/2018/3/26/162602098f06672b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。(全局的静态变量，定义指定不同组件中的scheme和JLRouters的组合)包含注册，非注册，全部解绑注册。</p>
<p>至于为何有这么多条路由，笔者认为，如果路由按照业务线进行划分的话，每个业务线可能会有不相同的逻辑，即使每个业务里面的组件名字可能相同，但是由于业务线不同，会有不同的路由规则。</p>
<p>在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。</p>
<p>不是特别理解pattern，在remove的过程中 实际扮演的意思，还是通过比较做事情</p>
<p>在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/关于app启动的优化20180327/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/关于app启动的优化20180327/" itemprop="url">App 启动优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-27T10:11:12+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先说结论，t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载；<br>t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</p>
<p>main()调用之前的加载过程<br>App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。<br>动态链接库包括：iOS 中用到的所有系统 framework，加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)和libsystem_blocks (Block)。</p>
<p>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的，那么image究竟包括哪些呢？</p>
<p>什么是image<br>1.executable可执行文件 比如.o文件。<br>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。<br>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p>
<p>除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p>
<p>系统使用动态链接有几点好处：<br>代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份。 易于维护：由于被依赖的 lib 是程序执行时才链接的，所以这些 lib 很容易做更新，比如libSystem.dylib 是 libSystem.B.dylib 的替身，哪天想升级直接换成libSystem.C.dylib 然后再替换替身就行了。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多。</p>
<p>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应），那么ImageLoader又是什么呢？</p>
<p>什么是ImageLoader<br>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。<br>两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。</p>
<p>当然所有这些都发生在我们真正的main函数执行前。</p>
<p>动态链接库加载的具体流程<br>动态链接库的加载步骤具体分为5步：</p>
<p>load dylibs image 读取库镜像文件<br>Rebase image<br>Bind image<br>Objc setup<br>initializers<br>load dylibs image<br>在每个动态库的加载过程中， dyld需要：</p>
<p>分析所依赖的动态库<br>找到动态库的mach-o文件<br>打开文件<br>验证文件<br>在系统核心注册文件签名<br>对动态库的每一个segment调用mmap()<br>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p>
<p>减少非系统库的依赖<br>合并非系统库<br>使用静态资源，比如把代码加入主程序<br>rebase/bind<br>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。<br>通过命令行可以查看相关的资源指针:</p>
<p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p>
<p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p>
<p>减少Objc类数量， 减少selector数量<br>减少C++虚函数数量<br>转而使用swift stuct（其实本质上就是为了减少符号的数量）<br>Objc setup<br>这一步主要工作是:</p>
<p>注册Objc类 (class registration)<br>把category的定义插入方法列表 (category registration)<br>保证每一个selector唯一 (selctor uniquing)<br>由于之前2步骤的优化，这一步实际上没有什么可做的。</p>
<p>initializers<br>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有：</p>
<p>Objc的+load()函数<br>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()<br>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度<br>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p>
<p>dyld 开始将程序二进制文件初始化<br>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号<br>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理<br>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法<br>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。</p>
<p>整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</p>
<p>如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点，这就分别是热启动和冷启动的概念，如下图所示:</p>
<p><img src="http://ofnft8t2g.bkt.clouddn.com/wikiimage2.png" alt=""></p>
<p>main()之前的加载时间如何衡量<br>那么问题就来了，那怎么衡量main()之前也就是time1的耗时呢，苹果官方提供了一种方法，那就是在真机调试的时候勾选dyldPRINTSTATISTICS选项。</p>
<p>由此可见对于系统级别的动态链接库，因为苹果做了优化，所以耗时并不多，在这个awesome的例子中，自身App中的代码占用了整体时间的94.2% 我们应用中一次典型的Log如下：</p>
<p><img src="http://ofnft8t2g.bkt.clouddn.com/wikiimage5.png" alt=""></p>
<p>由此可见，最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。</p>
<p>总结一下：对于main()调用之前的耗时我们可以优化的点有：</p>
<p>减少不必要的framework，因为动态链接比较耗时<br>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查<br>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</p>
<p>删减一些无用的静态变量<br>删减没有被调用到或者已经废弃的方法<br>将不必须在+load方法中做的事情延迟到+initialize中<br>尽量不要用C++虚函数(创建虚函数表有开销)<br>main()调用之后的加载时间</p>
<p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。 App通常在AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。</p>
<p>而视图的渲染主要涉及三个阶段：</p>
<p>准备阶段 这里主要是图片的解码<br>布局阶段 首页所有UIView的- (void)layoutSubViews()运行<br>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行</p>
<p>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方<br>因此，对于main()函数调用之前我们可以优化的点有：</p>
<p>不使用xib，直接视用代码加载首页视图<br>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)<br>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log<br>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</p>
<p>实测数据<br>建立了一个空的HelloWorld工程，只加入了pods中的代码，不包含主端的业务逻辑代码，一次典型的冷启动基本接近2s iPhone6 iOS9.3.5系统测试主要时间在加载动态库，类/方法的初始化还有符号地址绑定阶段。</p>
<p>一次典型的热启动数据如下：可以看到因为系统做了缓存方面的优化，比冷启动快了500ms加上头条主端业务逻辑代码之后一次典型的热启动耗时2.1s。</p>
<p>以上用时均为main()之前的加载耗时。</p>
<p>main()函数之后加载时间优化记录</p>
<p>NSUserDefaults是否是瓶颈<br>苹果官方文档提到NSUserDefaults加载的时候是整个plist配置文件全部load到内存中，目前头条主端当中NSUserDefaults存储了200多项缓存数据，因此怀疑可能拖慢启动速度，但是测试结果显示并不会。 通过符号断点+[NSUserDefaults standardUserDefaults]确定最早一次的+load()从执行到结束耗时1.8ms，可见NSUserDefaults的初始化仅耗时1.8ms，并不是启动耗时的瓶颈。</p>
<p>如何找到拖慢启动应用时长的瓶颈<br>为了找到瓶颈，我们在启动之后的didFinishLauhcning方法开始执行到首页列表页的NewsListViewController的viewDidAppear方法，几乎每个可能比较耗时的流程进行拆分和统计，得到统计数据之后发现： 主要耗时在首页UI构造和渲染(storyboard加载，tabBar/topBar渲染，开屏广告加载/cell注册/日志模块初始化这几个步骤)。</p>
<p>具体优化点<br>因此，针对于今日头条这个App我们可以优化的点如下：</p>
<p>纯代码方式而不是storyboard加载首页UI。<br>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。<br>对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载<br>对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。<br>上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。<br>优化结果<br>之前曾经有一位同事已经做了一定的优化，比如启动之后展示闪屏广告图的同时初始化首页的列表页，当广告展示完成之后列表页也就渲染完成了。经过这一次优化之后的main()之后的启动总时长通过上线之后收集数据的验证达到了预期的效果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/消息机制基础知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/消息机制基础知识点/" itemprop="url">基础知识系列  object-class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-27T10:11:12+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="object-class-类"><a href="#object-class-类" class="headerlink" title="object_class 类"></a>object_class 类</h4><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line">它的定义如下：</span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class               OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name               OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                 OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info      OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size     OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars   OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists  OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache    OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125;OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<h4 id="objc-object-实例"><a href="#objc-object-实例" class="headerlink" title="objc_object 实例"></a>objc_object 实例</h4><p>objc_object是表示一个类的实例的结构体<br>它的定义如下：<br>struct objc_object{<br>     Class isa OBJC_ISA_AVAILABILITY;<br>};<br>typedef struct objc_object *id;<br>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法，找到后即运行这个方法。</p>
<h4 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h4><p>meta-class是一个类对象的类。<br>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么，这个isa指针指向什么呢？<br>答案是，为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体.这就引出了meta-class的概念，meta-class中存储着一个类的所有类方法。所以，调用类方法的这个类对象的isa指针指向的就是meta-class当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。<br>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。<br>即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>Category是表示一个指向分类的结构体的指针，其定义如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_category *Category</span><br><span class="line">struct objc_category&#123;</span><br><span class="line">     char *category_name               OBJC2_UNAVAILABLE; // 分类名</span><br><span class="line">     char *class_name          OBJC2_UNAVAILABLE;  // 分类所属的类名</span><br><span class="line">     struct objc_method_list *instance_methods OBJC2_UNAVAILABLE;// 实例方法列表</span><br><span class="line">     struct objc_method_list *class_methods  OBJC2_UNAVAILABLE; // 类方法列表</span><br><span class="line">     struct objc_protocol_list *protocols  OBJC2_UNAVAILABLE; // 分类所实现的协议列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。可发现，类别中没有ivar成员变量指针，也就意味着：类别中不能够添加实例变量和属性,</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：<br>typedef struct objc_selector *SEL；<br>方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。<br>两个类之间，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行<br>如在某一个类中定义以下两个方法: 错误<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setWidth:(int)width;</span><br><span class="line">- (void)setWidth:(double)width;</span><br></pre></td></tr></table></figure></p>
<p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br>工程中的所有的SEL组成一个Set集合，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！<br>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。<br>通过下面三种方法可以获取SEL:<br>a、sel_registerName函数<br>b、Objective-C编译器提供的@selector()<br>c、NSSelectorFromString()方法</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:<br>id (*IMP)(id, SEL,…)<br>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)<br>第二个参数：是方法选择器(selector)<br>接下来的参数：方法的参数列表。<br>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method用于表示类定义中的方法，则定义如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。有关消息发送和消息转发机制的原理，可以查看这篇文章。</p>
<p>面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为：<br>objc_msgSend(receiver, selector)<br>如果消息含有参数，则为：<br>objc_msgSend(receiver, selector, arg1, arg2, …)<br>如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。<br>现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送 message这条消息，而 receiver 将要如何响应这条消息，那就要看运行时发生的情况来决定了。<br>这里看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：<br>1、检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。<br>2、检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。<br>3、如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。<br>4、如果 cache 找不到就找一下方法分发表。<br>5、如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。<br>6、如果还找不到就要开始进入动态方法解析了，后面会提到。<br>PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。</p>
<p>其实编译器会根据情况在objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。排列组合正好四个方法。<br>值得一提的是在i386 平台处理返回类型为浮点数的消息时，需要用到objc_msgSend_fpret函数来进行处理，这是因为返回类型为浮点数的函数对应的ABI(Application Binary Interface)与返回整型的函数的ABI不兼容。此时objc_msgSend不再适用，于是objc_msgSend_fpret被派上用场，它会对浮点数寄存器做特殊处理。不过在PPC 或 PPC64 平台是不需要麻烦它的。<br>PS：有木有发现这些函数的命名规律哦？带“Super”的是消息传递给超类；“stret”可分为“st”+“ret”两部分，分别代表“struct”和“return”；“fpret”就是“fp”+“ret”，分别代表“floating-point”和“return”。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>你可以动态地提供一个方法的实现。例如我们可以用@dynamic关键字在类的实现文件中修饰一个属性：<br>@dynamic propertyName;<br>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成setPropertyName:和propertyName方法，而需要我们动态提供。我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当Runtime系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 Type Encoding<br>PS：动态方法解析会在消息转发机制浸入前执行。如果 respondsToSelector: 或 instancesRespondToSelector:方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的IMP的机会。如果你想让该方法选择器被传送到转发机制，那么就让resolveInstanceMethod:返回NO。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>后面的文章中有补充</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/HTTP的总结20180325/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/HTTP的总结20180325/" itemprop="url">关于Http的总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-25T10:11:12+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于Http的总结</p>
<ol>
<li><p>HTTP/1.1<br>TCP连接是需要三次握手的，同时，多个TCP连接也会给服务器带来资源的消耗，在HTTP/1.1中，每个请求回复都是一次TCP连接（未开启Keep-Alive的情况下），并且，同时传输多个资源时，会有队首阻塞的问题，造成网络资源无法有效利用。</p>
</li>
<li><p>安全<br>对于大多数人来说，下图的情况几乎都有遇到过（电脑或手机里）。万恶的运营商或者网络接入WiFi提供商劫持我们的网络，修改网络的内容，给我们带来了很大的困扰。</p>
</li>
</ol>
<p>现在，HTTP/2.0出现了。其实HTTP/2.0是支持Clear Text版和Over TLS版，由于现有支持HTTP/2.0的浏览器都是实现的Over TLS版，故本文的HTTP/2.0都是讲的是HTTPS版HTTP/2.0。</p>
<ol>
<li><p>Clear Text版:<br>客户端向服务端请求（假设此时scheme是HTTP），带有以下头：<br>Upgrade: h2c<br>HTTP2-Settings<br>服务器端返回：<br>101状态码，转换协议；<br>Connection: Upgrade<br>Upgrade: h2c 或者 200/404</p>
</li>
<li><p>HTTP/2.0 Over TLS版:<br>客户端向服务器端请求<br>TLS + ALPN(Application Layer Protocol Negotiation)/NPN<br>服务器端返回:<br>TLS 握手 并返回支持的HTTP协议<br><img src="https://mc.qcloudimg.com/static/img/851afadec019cc1f93f28e119c3f6f53/image.jpg" alt=""></p>
</li>
</ol>
<p>b. ALPN协商过程</p>
<p>参考TLS握手过程图，下面是增加ALPN协商的具体过程：<br>客户端添加一个ProtocolNameList字段，包含支持的HTTP协议到ClientHello消息中；<br>服务器端查看ProtocolNameList字段后通过ServerHello消息返回ProtocolName字段，表明被选定的协议；<br>通过实现ALPN，不再需要单独请求一次服务器带上Upgrade: h2c。</p>
<p>c. False Start</p>
<p>通常情况下，使用ALPN会搭配使用False Start，客户端在完成TLS握手前提前发送加密后的应用数据，将两次RTT TLS握手减少为一次；不过需要同时支持ALPN（NPN已经很少用啦）和前向安全性。</p>
<p>d. HSTS</p>
<p>HTTP Strict Transport Security（简称为HSTS）是一个安全功能，告诉浏览器只能通过HTTPS访问当前资源，禁止HTTP方式。<br>如果用户输入域名<a href="http://www.qq.com，" target="_blank" rel="noopener">www.qq.com，</a> 浏览器首先会去请求<a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a> ,请求过程是明文非加密的，此时容易被中间人攻击，让网路恶意中间商直接接触到用户信息；而HSTS是用户请求时，服务器告诉客户端，下次来请求直接请求https:// ，而不要再请求服务器来跳转到https。<br>同时，开启HSTS后，如果证书认证不通过（比如遭到中间人攻击），浏览器此时强制无法打开该网站。</p>
<p>流(Stream)：一个Stream是包含一条或多条信息，ID和优先级的双向通道；<br>消息(Message)：消息由帧组成；<br>帧(Frame)：帧有不同的类型，并且是混合的。他们通过stream id被重新组装进消息中。</p>
<p>二进制帧的处理：</p>
<p><img src="https://mc.qcloudimg.com/static/img/811215f81ab8ff1af5ee542841cd3575/image.jpg" alt=""></p>
<p>HTTP2的二进制帧是9字节(72 bit)<br>长度：24bit，也就是理论上可以携带2^24字节的数据。但通常由于SETTINGS_MAX_FRAME_SIZE的设置，不能发送超过2^14(16384)字节的数据；<br>类型：8bit，决定了该帧的类型；<br>DATA : 数据帧<br>HEADERS : 头部帧<br>PRIORITY : 设置流的优先级<br>RST_STREAM : 终止流<br>SETTINGS : 设置连接参数<br>PUSH_PROMISE : 服务器推送模拟请求帧<br>PING : 用来计算RTT时间和看是否服务器挂了的Stream<br>GOAWAY : 告诉对方停止再向当前连接创建stream<br>WINDOW_UPDATE : 流量控制<br>保留字段：1bit，一般为0。</p>
<p>Stream ID：31bit，Stream标识，理论上可以有2147483648，超过这么多stream怎么办呢？</p>
<p>如果是客户端无法再创建新的stream id，可以直接创建新的TCP连接，stream id被重置。</p>
<p>如果是服务器端无法再创建新的stream id，服务器将会给客户端发一个 GOAWAY帧，客户端无法再向该服务器创建stream，不得不新建TCP连接。</p>
<p>新的特性：<br>a. 多路复用<br><img src="https://mc.qcloudimg.com/static/img/ca52b1f8f8397cd11b0164bf2adda94d/image.jpg" alt=""></p>
<p>HTTP/2.0中，数据在发送端被切分为更小的数据帧用以高效利用链接。</p>
<p>HTTP 1.1时代，再不开启Keep-alive的情况下，每一个请求会占用一个TCP连接，而HTTP/2将请求和响应消息拆分为各自独立的帧，交错的发送，然后再在接收端重新装配组合。有什么好处呢？</p>
<p>交错的多个请求/响应之间互现不会被阻塞</p>
<p>HTTP/1.1时代的Keep-alive也是保持同一个TCP连接，但是由于请求/接收有先后，后面的请求资源会被前面的资源阻塞（没收到响应时不会发新的请求），如下图最左和最右边所示，即便是相比HTTP管道，优化也是巨大的：<br><img src="https://mc.qcloudimg.com/static/img/228acfed18be7661c6da162b0c56b777/image.jpg" alt=""><br>减少了不必要的延时，改善了网路的利用率(多路复用和资源优先级/依赖关系搭配使用，使得页面重度依赖的资源优先传输)；</p>
<p>b. 头部压缩</p>
<p>HTTP/2.0使用HPACK来给头部压缩；<br>值通过霍夫曼编码；<br>之前发送的值都被索引起来，之后使用时发现之前发送过该Header字段，并且值相同，就会沿用之前的索引来指代那个Header值；<br>Cookies：在HTTP/2.0中，Cookie也将会变为键值对索引起来，而不是一长串字符串。</p>
<p>c. 资源优先级/依赖关系<br>资源优先级/依赖关系通过stream权重和dependency来设置。<br>通过上图可以看到，有一列是叫作Priority，初始设置是根据Content-type来设置优先级的，比如HTML是Highest，CSS是High，然后JS是Medium。<br>Stream 权重值可以设置为1到256之间。<br>Stream可以明确的表示依赖关系。<br>注意，一定要理解权重和依赖，权重值和依赖关系是作为带宽资源/服务器/客户端处理资源的建议值，但并不能保证他们有特定的传输顺序。</p>
<p>d. 流量控制<br>与TCP的流量控制类似，不过HTTP/2.0的流量控制可以到具体帧，而TCP是TCP连接层面上的。注意：流量控制目前只对DATA帧有效！流量控制的算法没有具体要求使用哪一种，但是大概实现的功能是这样的：<br>两端收发保有一个流量控制(window)窗口；<br>发送端每发送一个DATA帧，就把窗口的大小递减，递减量为这个帧的大小，要是窗口大小小于该帧的大小，那么这个帧就必须被拆分。如果窗口值等于0，就不能发送任何帧。流量控制的初始默认窗口值大小为65535字节(理论上可以设置2^31-1字节也就是2147483647字节大小的窗口值)；<br>接收端可以通过发送WINDOW_UPDATE帧给发送端，发送端以帧内指定的窗口大小增量加到窗口大小限制上。</p>
<p>e. Server Push<br>Server Push的资源同样需要遵守同源策略，通过:authority来判断。<br>Server Push有什么好处呢：<br>推送的资源可以被客户端缓存；<br>推送的资源可以被不同的页面复用；<br>推送资源也是支持多路复用的；<br>推送资源可以被客户端拒绝掉(客户端接收到PUSH_PROMISE后，可以选择发送RST_PROMISE来拒绝接收，告诉服务器端不要再发送了，当然，此时可能已经有部分内容已经发送过来了)；</p>
<p>关于Http和Https的区别的点</p>
<p>HTTP和HTTPS的区别，概念层的区别<br>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：<br>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>http的隐患：</p>
<p>1、隐私泄露<br>由于 HTTP 本身是明文传输，用户和服务端之间的传输内容都能被中间者查看。也就是说 你在网上搜索、购物、访问的网点、点击的页面等信息，都可以被「中间人」获取。<br>2、页面劫持<br>隐私泄露的风险比较隐蔽，用户基本感知不到。但另外一类劫持的影响就非常明显非常直接了——页面劫持，也就是直接篡改用户的浏览页面。有很多页面劫持很简单粗暴，直接插入第三方广告或者运营商的流量提示信息。<br>3、劫持路径及分类<br>那劫持到底是如何产生的呢？从技术上来讲比较简单，在内容经过的地方进行监听篡改就行了。但要想把整个劫持的产业链条摸清楚，需要深入黑产内部，比较困难。有一点可以肯定的是，劫持大部分都是在中间的网络节点发生的，又叫「中间人」(MITM， man in the middle)。如下图所示<br><img src="https://blog-10039692.file.myqcloud.com/1486471416100_7812_1486471416521.png" alt=""><br>由于信息传输都需要经过上述的「中间人节点」，它们又拥有信息的读写权限，如果信息没有加密，也没有校验，那么想要查看隐私，篡改页面，对于「中间人」来说可谓是轻而易举。</p>
<p>那劫持又有哪些主要的分类呢?根据劫持路径划分的话，主要是下图所示的三类：<br><img src="https://blog-10039692.file.myqcloud.com/1486471476410_5533_1486471477594.png" alt=""><br>DNS 劫持，客户端劫持和链路劫持。 根据我们的不完全统计，业务遇到的绝大部分劫持 (90%)都属于链路劫持。</p>
<p>HTTPS 为什么能很好的解决链路劫持呢？主要是三大武器:<br>1、身份认证—防假冒，防抵赖<br>每次建立一个全新的 HTTPS 连接时，都需要对身份进行认证，确保用户访问的是正确的目的网站。<br><img src="https://blog-10039692.file.myqcloud.com/1486471569259_8625_1486471569506.png" alt=""></p>
<p>2、内容加密—防窃听<br>内容加密意味端对端的通信内容全都是密文，中间人无法直接查看到明文，HTTPS 所有的应用层内容都是通过对称加密来实现加密和解密的。<br><img src="https://blog-10039692.file.myqcloud.com/1486471621111_7034_1486471621290.png" alt=""></p>
<p>3、一致性校验—防篡改<br>通过对数据和共享密钥的 MAC 码来防止中间者篡改消息内容，确保数据的一致性。<br><img src="https://blog-10039692.file.myqcloud.com/1486471674398_2270_1486471675064.png" alt=""></p>
<p>网络耗时。由于协议的规定，必须要进行的网络传输。比如 SSL 完全握手，302 跳转等。最坏情况下可能要增加 7 个 RTT。<br>计算耗时。无论是客户端还是服务端，都需要进行对称加解密，协议解析，私钥计算，证书校验等计算，增加大量的计算时间。</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1486471843113_1438_1486471843834.png" alt=""></p>
<p>Charles可以用作中间的HTTPS代理，允许您以纯文本形式查看Web浏览器和SSL Web服务器之间的通信。</p>
<p>Charles通过成为中间人来做到这一点。替换浏览器看到服务器的证书，Charles动态地为服务器生成证书，并用它自己的根证书（Charles的CA证书）签名。Charles接收服务器的证书，而您的浏览器接收Charles的证书。因此，您将看到一个安全警告，指示根权限不受信任。</p>
<p>先说一下https使用的非对称加密的原理。等等说非对称加密之前还要说下对称加密的原理。简单来说，对称加密就是加密解密使用同一个密钥。浏览器和服务器交互的话一般会动态生成一个密钥，所以密钥如何交换就成了问题。</p>
<p>下面引入非对称密钥，非对称加密主要用于密钥交换（也叫密钥协商），能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。</p>
<p>密钥交换过程：服务器的公钥是公开的，私钥是不公开的。浏览器先向服务器取得公钥，然后用公钥加密自己的私钥连同自己私钥加密的请求一并发送给服务器。服务器使用自己私钥解密得到浏览器的私钥，使用浏览器的私钥解密请求。然后再用浏览器的私钥加密response发送回浏览器(此处之前笔误写成服务器了)。</p>
<p>中间人攻击是先伪装服务器向浏览器发送伪造的公钥，从而取得浏览器的私钥。这样就完成的浏览器端的解密。服务器端类似。</p>
<p>但是！！！https是可以防止中间人攻击的，因为服务器的公钥是用证书的。charles伪造的证书一般浏览器会警告，所以我们需要将charles的证书认为可靠的。从而实现中间人。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/runtime机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/runtime机制/" itemprop="url">Runtime基础考点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-25T10:11:12+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.关于底层的属性说明<br>属性和成员变量不同，<br>@property = ivar + getter  + setter；<br>定义的property会在objc_ivar_list中添加一个成员变量的描述，然后再methodList中添加setter和getter方法，objc_property_t是声明的属性类型，是一个指向objc_property结构体指针；</p>
<p>总结：<br>object_property_t * propertyList = class_copyPropertyList(class, &amp;count);<br>foreach就可以查询所有的property的数据信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    const char * _Nonnull name;           /**<span class="tag">&lt; <span class="attr">The</span> <span class="attr">name</span> <span class="attr">of</span> <span class="attr">the</span> <span class="attr">attribute</span> */</span></span><br><span class="line">    const char * _Nonnull value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>成员变量<br>Ivar的实例变量类型，是一个指向objc_ivar的结构体的指针<br>typedef struct objc_ivar *ivar;<br>结构体指针的组成如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- struct objc_ivar &#123;</span><br><span class="line">    char * _Nullable ivar_name;</span><br><span class="line">    char * _Nullable ivar_type;</span><br><span class="line">    int ivar_offset;基地址的偏移量</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取整个成员变量列表<br>Ivar <em>class_copyIvarList（Class cls, unsigned int </em>outCount）;<br>我们可以直接通过 ivar_getName(ivar);<br>ivar_getTypeEncoding(ivar);<br>释放指针，<br>注意的一些细节点是：记得释放free(ivars);</p>
<p>定义成员变量的列表；<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在objc_class中，所有的成员变量，属性的信息是放在链表ivars中的，ivars是一个数组，数组中的每个元素指向Ivar变量指针的地址。</span><br><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    int ivar_count；</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space；</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_ivar ivar_list[1]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于存储objc_method的记录<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name;</span><br><span class="line">    char * _Nullable method_types; 存储方法的参数类类和返回值类型</span><br><span class="line">    IMP _Nonnull method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于selector的定义，其实底层并没有这个定义；；从相对的总结可以看出，selector其实就是一个char类型的指针；</p>
<p>关于IMP：就是函数指针 ，指向方法实现的首地址<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the function of a method implementation.</span><br><span class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ );</span><br><span class="line">#else</span><br><span class="line">typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */  ;</span><br><span class="line">    一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法</span><br><span class="line">    unsigned int occupied;一个整数，指定实际占用的缓存bucket的总数。</span><br><span class="line">    Method _Nullable buckets[1];指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objc_protocol_list</span><br><span class="line">struct objc_protocol_list &#123;</span><br><span class="line">    struct objc_protocol_list * _Nullable next;</span><br><span class="line">    long count;</span><br><span class="line">    __unsafe_unretained Protocol * _Nullable list[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法调用的api<br>方法调用流程<br>检查 selector 是否需要忽略<br>检查 target 是否为 nil，如果是 nil 就直接 cleanup，然后 return<br>在 target 的 Class 中根据 selector 去找 IMP</p>
<p>寻找 IMP 的过程:<br>在当前 class 的方法缓存里寻找（cache methodLists）<br>找到了跳到对应的方法实现，没找到继续往下执行<br>从当前 class 的 方法列表里查找（methodLists），找到了添加到缓存列表里，然后跳转到对应的方法实现；没找到继续往下执行<br>从 superClass 的缓存列表和方法列表里查找，直到找到基类为止<br>以上步骤还找不到 IMP，则进入消息动态处理和消息转发流程</p>
<p>runtime的api的使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取属性列表</span><br><span class="line">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</span><br><span class="line">//获取方法列表</span><br><span class="line">Method *methodList = class_copyMethodList([self class], &amp;count);</span><br><span class="line">//获取成员列表</span><br><span class="line">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</span><br><span class="line">//获取协议列表</span><br><span class="line">__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">动态创建类</span><br><span class="line">Class cls = objc_allocateClassPair(MyClass.class, &quot;MySubClass&quot;, 0);</span><br><span class="line">class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);</span><br><span class="line">class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);</span><br><span class="line">class_addIvar(cls, &quot;_ivar1&quot;, sizeof(NSString *), log(sizeof(NSString *)), &quot;i&quot;);</span><br><span class="line"></span><br><span class="line">objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@&quot;NSString&quot;&quot;&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; &quot;C&quot;, &quot;&quot; &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_ivar1&quot;&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line"></span><br><span class="line">class_addProperty(cls, &quot;property2&quot;, attrs, 3);</span><br><span class="line">objc_registerClassPair(cls);</span><br><span class="line"></span><br><span class="line">id instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:@selector(submethod1)];</span><br><span class="line">[instance performSelector:@selector(method1)];</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">转化关系</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge void *)obj;</span><br><span class="line">id o = (__bridge id)p;</span><br><span class="line"></span><br><span class="line">关于这个转换可以了解更多：ARC 类型转换：显示转换 id 和 void *</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/shell高阶预发的使用说明/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/shell高阶预发的使用说明/" itemprop="url">join的语法集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-14T10:11:12+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>join的语法集合：</p>
<p>join fileone filetwo 根据文件的第一个域空间进行数据merge</p>
<p>join -1 2 -2 3 fileone filetwo 根据文件的指定域空间 进行数据merge</p>
<p>关于 awk的使用：</p>
<p>awk ‘{[pattern] action}’ {filenames}</p>
<p>awk ‘{print $1,$4}’ log.txt  没行按照tab分割</p>
<p>awk -F  #-F相当于内置变量FS, 指定分割字符</p>
<p>awk -F, ‘{print $1,$2}’   log.txt 按照，分割</p>
<p>awk -F ‘[ ,]’  ‘{print $1,$2,$5}’   log.txt 背景</p>
<p>who | awk ‘{print $1}’ | sort -u</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/自动闭包20180314/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/自动闭包20180314/" itemprop="url">Swift的闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-14T10:11:12+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Swift的自动闭包（autoclosure-noescape-escape-）"><a href="#Swift的自动闭包（autoclosure-noescape-escape-）" class="headerlink" title="Swift的自动闭包（autoclosure,noescape,escape,??）"></a>Swift的自动闭包（autoclosure,noescape,escape,??）</h3><p>@autoclosure（自动闭包）</p>
<p> 1:自动闭包，顾名思义是一种自动创建的闭包，用于包装函数参数的表达式，可以说是一种简便语法.<br> 2:自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。<br> 3:自动闭包的好处之二是让你能够延迟求值,因为代码段不会被执行直到你调用这个闭包，这样你就可以控制代码什么时候执行。<br> 4：含有autoclosure特性的声明同时也具有noescape的特性，及默认是非逃逸闭包，除非传递可选参数escaping.如果传递了该参数，那么将可以在闭包之外进行操作闭包,形式为：请使用@autoclosure(escaping)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/KVO20180311/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/KVO20180311/" itemprop="url">KVO原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-11T10:11:12+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="KVO基本原理："><a href="#KVO基本原理：" class="headerlink" title="KVO基本原理："></a>KVO基本原理：</h4><p>1.KVO是基于runtime机制实现的<br>2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制<br>3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person<br>4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法<br>5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</p>
<h4 id="KVO深入原理："><a href="#KVO深入原理：" class="headerlink" title="KVO深入原理："></a>KVO深入原理：</h4><p>1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：?NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter?方法，setter?方法会负责在调用原?setter?方法之前和之后，通知所有观察对象属性值的更改情况。<br>2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；<br>3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。<br>4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）?因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。<br>5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath?的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath?的属性值已经变更；之后，?observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter?方法这种继承方式的注入是在运行时而不是编译时实现的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1829339-77757288cc139f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/11/weak的原理20180311/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/weak的原理20180311/" itemprop="url">weak原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-11T10:11:12+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="weak实现原理："><a href="#weak实现原理：" class="headerlink" title="weak实现原理："></a>weak实现原理：</h4><p>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。<br>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br>2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。<br>3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
<p>追问的问题一：实现weak后，为什么对象释放后会自动为nil？<br>runtime对注册的类， 会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc，假如weak指向的对象内存地址是a，那么就会以a为键， 在这个weak表中搜索，找到所有以a为键的weak对象，从而设置为nil。</p>
<p>追问的问题二：当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？<br>1、调用objc_release<br>2、因为对象的引用计数为0，所以执行dealloc<br>3、在dealloc中，调用了_objc_rootDealloc函数<br>4、在_objc_rootDealloc中，调用了object_dispose函数<br>5、调用objc_destructInstance<br>6、最后调用objc_clear_deallocating,详细过程如下：<br>a. 从weak表中获取废弃对象的地址为键值的记录<br>b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil<br>c. 将weak表中该记录删除<br>d. 从引用计数表中删除废弃对象的地址为键值的记录</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yida</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yida</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
