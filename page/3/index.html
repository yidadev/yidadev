<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="益达的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="益达的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="益达的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>益达的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">益达的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/08/flexBox布局/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/flexBox布局/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T09:26:04+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于flex的布局：</p>
<p>Webkit内核的浏览器，必须加上-webkit前缀<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h4><p><img src="http://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt=""></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size.</p>
<h4 id="容器的属性："><a href="#容器的属性：" class="headerlink" title="容器的属性："></a>容器的属性：</h4><ol>
<li>flex-direction属性决定主轴的方向（即项目的排列方向）。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png" alt=""></p>
<ol start="2">
<li>flex-wrap属性<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>（1）nowrap（默认）：不换行。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/9da1f23965756568b4c6ea7124db7b9a.png" alt=""><br>（2）wrap：换行，第一行在上方。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/3c6b3c8b8fe5e26bca6fb57538cf72d9.jpg" alt=""><br>（3）wrap-reverse：换行，第一行在下方。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/fb4cf2bab8b6b744b64f6d7a99cd577c.jpg" alt=""></p>
<ol start="3">
<li><p>flex-flow<br>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: <span class="tag">&lt;<span class="name">flex-direction</span>&gt;</span> || <span class="tag">&lt;<span class="name">flex-wrap</span>&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>justify-content属性<br>justify-content属性定义了项目在主轴上的对齐方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png" alt=""></p>
<ol start="4">
<li>align-items属性<br>align-items属性定义项目在交叉轴上如何对齐。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png" alt=""></p>
<ol start="6">
<li>align-content属性<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt=""></p>
<h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><p>1.order属性<br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: <span class="tag">&lt;<span class="name">integer</span>&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png" alt=""></p>
<p>2.flex-grow属性<br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: <span class="tag">&lt;<span class="name">number</span>&gt;</span>; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png" alt=""><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>3.flex-shrink属性<br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: <span class="tag">&lt;<span class="name">number</span>&gt;</span>; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg" alt=""><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p>
<p>4.flex-basis属性<br>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: <span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<p>5.flex属性<br>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ <span class="tag">&lt;<span class="name">'flex-grow'</span>&gt;</span> <span class="tag">&lt;<span class="name">'flex-shrink'</span>&gt;</span>? || <span class="tag">&lt;<span class="name">'flex-basis'</span>&gt;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<p>6.align-self属性<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://www.runoob.com/wp-content/uploads/2015/07/55b19171b8b6b9487d717bf2ecbba6de.png" alt=""></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/08/消息机制基础知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/08/消息机制基础知识点/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-08T09:25:48+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="object-class-类"><a href="#object-class-类" class="headerlink" title="object_class 类"></a>object_class 类</h4><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct object_class *Class</span><br><span class="line">它的定义如下：</span><br><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class               OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name               OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                 OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info      OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size     OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars   OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists  OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache    OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125;OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<h4 id="objc-object-实例"><a href="#objc-object-实例" class="headerlink" title="objc_object 实例"></a>objc_object 实例</h4><p>objc_object是表示一个类的实例的结构体<br>它的定义如下：<br>struct objc_object{<br>     Class isa OBJC_ISA_AVAILABILITY;<br>};<br>typedef struct objc_object *id;<br>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法，找到后即运行这个方法。</p>
<h4 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h4><p>meta-class是一个类对象的类。<br>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么，这个isa指针指向什么呢？<br>答案是，为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体.这就引出了meta-class的概念，meta-class中存储着一个类的所有类方法。所以，调用类方法的这个类对象的isa指针指向的就是meta-class当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。<br>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。<br>即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>Category是表示一个指向分类的结构体的指针，其定义如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_category *Category</span><br><span class="line">struct objc_category&#123;</span><br><span class="line">     char *category_name               OBJC2_UNAVAILABLE; // 分类名</span><br><span class="line">     char *class_name          OBJC2_UNAVAILABLE;  // 分类所属的类名</span><br><span class="line">     struct objc_method_list *instance_methods OBJC2_UNAVAILABLE;// 实例方法列表</span><br><span class="line">     struct objc_method_list *class_methods  OBJC2_UNAVAILABLE; // 类方法列表</span><br><span class="line">     struct objc_protocol_list *protocols  OBJC2_UNAVAILABLE; // 分类所实现的协议列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。可发现，类别中没有ivar成员变量指针，也就意味着：类别中不能够添加实例变量和属性,</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：<br>typedef struct objc_selector *SEL；<br>方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。<br>两个类之间，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行<br>如在某一个类中定义以下两个方法: 错误<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setWidth:(int)width;</span><br><span class="line">- (void)setWidth:(double)width;</span><br></pre></td></tr></table></figure></p>
<p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br>工程中的所有的SEL组成一个Set集合，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！<br>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。<br>通过下面三种方法可以获取SEL:<br>a、sel_registerName函数<br>b、Objective-C编译器提供的@selector()<br>c、NSSelectorFromString()方法</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:<br>id (*IMP)(id, SEL,…)<br>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)<br>第二个参数：是方法选择器(selector)<br>接下来的参数：方法的参数列表。<br>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method用于表示类定义中的方法，则定义如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method</span><br><span class="line">struct objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class="line">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。有关消息发送和消息转发机制的原理，可以查看这篇文章。</p>
<p>面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为：<br>objc_msgSend(receiver, selector)<br>如果消息含有参数，则为：<br>objc_msgSend(receiver, selector, arg1, arg2, …)<br>如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。<br>现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送 message这条消息，而 receiver 将要如何响应这条消息，那就要看运行时发生的情况来决定了。<br>这里看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：<br>1、检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。<br>2、检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。<br>3、如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。<br>4、如果 cache 找不到就找一下方法分发表。<br>5、如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。<br>6、如果还找不到就要开始进入动态方法解析了，后面会提到。<br>PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。</p>
<p>其实编译器会根据情况在objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。排列组合正好四个方法。<br>值得一提的是在i386 平台处理返回类型为浮点数的消息时，需要用到objc_msgSend_fpret函数来进行处理，这是因为返回类型为浮点数的函数对应的ABI(Application Binary Interface)与返回整型的函数的ABI不兼容。此时objc_msgSend不再适用，于是objc_msgSend_fpret被派上用场，它会对浮点数寄存器做特殊处理。不过在PPC 或 PPC64 平台是不需要麻烦它的。<br>PS：有木有发现这些函数的命名规律哦？带“Super”的是消息传递给超类；“stret”可分为“st”+“ret”两部分，分别代表“struct”和“return”；“fpret”就是“fp”+“ret”，分别代表“floating-point”和“return”。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>你可以动态地提供一个方法的实现。例如我们可以用@dynamic关键字在类的实现文件中修饰一个属性：<br>@dynamic propertyName;<br>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成setPropertyName:和propertyName方法，而需要我们动态提供。我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当Runtime系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 Type Encoding<br>PS：动态方法解析会在消息转发机制浸入前执行。如果 respondsToSelector: 或 instancesRespondToSelector:方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的IMP的机会。如果你想让该方法选择器被传送到转发机制，那么就让resolveInstanceMethod:返回NO。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>后面的文章中有补充</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/关于容错的加载机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/关于容错的加载机制/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-29T22:39:31+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于热启动的处理一些异常情况 ，</p>
<p>对于所有的加load的做优先级操作，+load执行后，安全默认放到最高优先级做处理：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/路由的文档分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/路由的文档分析/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-29T16:23:41+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于我们常见的路由的整理：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/26/162602099053e6f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>首先JLRoute是受URL Scheme思路的影响。它把所有对资源的请求看成是一个URI。<br><img src="https://user-gold-cdn.xitu.io/2018/3/26/162602098f06672b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。(全局的静态变量，定义指定不同组件中的scheme和JLRouters的组合)包含注册，非注册，全部解绑注册。</p>
<p>至于为何有这么多条路由，笔者认为，如果路由按照业务线进行划分的话，每个业务线可能会有不相同的逻辑，即使每个业务里面的组件名字可能相同，但是由于业务线不同，会有不同的路由规则。</p>
<p>在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。</p>
<p>不是特别理解pattern，在remove的过程中 实际扮演的意思，还是通过比较做事情</p>
<p>在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/关于app启动的优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/关于app启动的优化/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-27T09:43:44+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先说结论，t(App总启动时间) = t1(main()之前的加载时间) + t2(main()之后的加载时间)。 t1 = 系统dylib(动态链接库)和自身App可执行文件的加载；<br>t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</p>
<p>main()调用之前的加载过程<br>App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。<br>动态链接库包括：iOS 中用到的所有系统 framework，加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)和libsystem_blocks (Block)。</p>
<p>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的，那么image究竟包括哪些呢？</p>
<p>什么是image<br>1.executable可执行文件 比如.o文件。<br>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。<br>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p>
<p>除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p>
<p>系统使用动态链接有几点好处：<br>代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份。 易于维护：由于被依赖的 lib 是程序执行时才链接的，所以这些 lib 很容易做更新，比如libSystem.dylib 是 libSystem.B.dylib 的替身，哪天想升级直接换成libSystem.C.dylib 然后再替换替身就行了。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多。</p>
<p>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应），那么ImageLoader又是什么呢？</p>
<p>什么是ImageLoader<br>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。<br>两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。</p>
<p>当然所有这些都发生在我们真正的main函数执行前。</p>
<p>动态链接库加载的具体流程<br>动态链接库的加载步骤具体分为5步：</p>
<p>load dylibs image 读取库镜像文件<br>Rebase image<br>Bind image<br>Objc setup<br>initializers<br>load dylibs image<br>在每个动态库的加载过程中， dyld需要：</p>
<p>分析所依赖的动态库<br>找到动态库的mach-o文件<br>打开文件<br>验证文件<br>在系统核心注册文件签名<br>对动态库的每一个segment调用mmap()<br>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p>
<p>减少非系统库的依赖<br>合并非系统库<br>使用静态资源，比如把代码加入主程序<br>rebase/bind<br>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。<br>通过命令行可以查看相关的资源指针:</p>
<p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p>
<p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p>
<p>减少Objc类数量， 减少selector数量<br>减少C++虚函数数量<br>转而使用swift stuct（其实本质上就是为了减少符号的数量）<br>Objc setup<br>这一步主要工作是:</p>
<p>注册Objc类 (class registration)<br>把category的定义插入方法列表 (category registration)<br>保证每一个selector唯一 (selctor uniquing)<br>由于之前2步骤的优化，这一步实际上没有什么可做的。</p>
<p>initializers<br>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有：</p>
<p>Objc的+load()函数<br>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()<br>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度<br>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p>
<p>dyld 开始将程序二进制文件初始化<br>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号<br>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理<br>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法<br>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。</p>
<p>整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</p>
<p>如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点，这就分别是热启动和冷启动的概念，如下图所示:</p>
<p><img src="http://ofnft8t2g.bkt.clouddn.com/wikiimage2.png" alt=""></p>
<p>main()之前的加载时间如何衡量<br>那么问题就来了，那怎么衡量main()之前也就是time1的耗时呢，苹果官方提供了一种方法，那就是在真机调试的时候勾选dyldPRINTSTATISTICS选项。</p>
<p>由此可见对于系统级别的动态链接库，因为苹果做了优化，所以耗时并不多，在这个awesome的例子中，自身App中的代码占用了整体时间的94.2% 我们应用中一次典型的Log如下：</p>
<p><img src="http://ofnft8t2g.bkt.clouddn.com/wikiimage5.png" alt=""></p>
<p>由此可见，最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。</p>
<p>总结一下：对于main()调用之前的耗时我们可以优化的点有：</p>
<p>减少不必要的framework，因为动态链接比较耗时<br>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查<br>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</p>
<p>删减一些无用的静态变量<br>删减没有被调用到或者已经废弃的方法<br>将不必须在+load方法中做的事情延迟到+initialize中<br>尽量不要用C++虚函数(创建虚函数表有开销)<br>main()调用之后的加载时间</p>
<p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。 App通常在AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。</p>
<p>而视图的渲染主要涉及三个阶段：</p>
<p>准备阶段 这里主要是图片的解码<br>布局阶段 首页所有UIView的- (void)layoutSubViews()运行<br>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行</p>
<p>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方<br>因此，对于main()函数调用之前我们可以优化的点有：</p>
<p>不使用xib，直接视用代码加载首页视图<br>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)<br>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log<br>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</p>
<p>实测数据<br>建立了一个空的HelloWorld工程，只加入了pods中的代码，不包含主端的业务逻辑代码，一次典型的冷启动基本接近2s iPhone6 iOS9.3.5系统测试主要时间在加载动态库，类/方法的初始化还有符号地址绑定阶段。</p>
<p>一次典型的热启动数据如下：可以看到因为系统做了缓存方面的优化，比冷启动快了500ms加上头条主端业务逻辑代码之后一次典型的热启动耗时2.1s。</p>
<p>以上用时均为main()之前的加载耗时。</p>
<p>main()函数之后加载时间优化记录</p>
<p>NSUserDefaults是否是瓶颈<br>苹果官方文档提到NSUserDefaults加载的时候是整个plist配置文件全部load到内存中，目前头条主端当中NSUserDefaults存储了200多项缓存数据，因此怀疑可能拖慢启动速度，但是测试结果显示并不会。 通过符号断点+[NSUserDefaults standardUserDefaults]确定最早一次的+load()从执行到结束耗时1.8ms，可见NSUserDefaults的初始化仅耗时1.8ms，并不是启动耗时的瓶颈。</p>
<p>如何找到拖慢启动应用时长的瓶颈<br>为了找到瓶颈，我们在启动之后的didFinishLauhcning方法开始执行到首页列表页的NewsListViewController的viewDidAppear方法，几乎每个可能比较耗时的流程进行拆分和统计，得到统计数据之后发现： 主要耗时在首页UI构造和渲染(storyboard加载，tabBar/topBar渲染，开屏广告加载/cell注册/日志模块初始化这几个步骤)。</p>
<p>具体优化点<br>因此，针对于今日头条这个App我们可以优化的点如下：</p>
<p>纯代码方式而不是storyboard加载首页UI。<br>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。<br>对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载<br>对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。<br>上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。<br>优化结果<br>之前曾经有一位同事已经做了一定的优化，比如启动之后展示闪屏广告图的同时初始化首页的列表页，当广告展示完成之后列表页也就渲染完成了。经过这一次优化之后的main()之后的启动总时长通过上线之后收集数据的验证达到了预期的效果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/面试题库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/面试题库/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-25T21:12:34+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于一些基础的面试题：</p>
<p>Runtime的消息转发机制</p>
<p>Runloop的工作原理</p>
<p>内存管理</p>
<p>block</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/HTTPS相关/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/HTTPS相关/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-25T21:11:40+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于Http的总结</p>
<ol>
<li><p>HTTP/1.1<br>TCP连接是需要三次握手的，同时，多个TCP连接也会给服务器带来资源的消耗，在HTTP/1.1中，每个请求回复都是一次TCP连接（未开启Keep-Alive的情况下），并且，同时传输多个资源时，会有队首阻塞的问题，造成网络资源无法有效利用。</p>
</li>
<li><p>安全<br>对于大多数人来说，下图的情况几乎都有遇到过（电脑或手机里）。万恶的运营商或者网络接入WiFi提供商劫持我们的网络，修改网络的内容，给我们带来了很大的困扰。</p>
</li>
</ol>
<p>现在，HTTP/2.0出现了。其实HTTP/2.0是支持Clear Text版和Over TLS版，由于现有支持HTTP/2.0的浏览器都是实现的Over TLS版，故本文的HTTP/2.0都是讲的是HTTPS版HTTP/2.0。</p>
<ol>
<li><p>Clear Text版:<br>客户端向服务端请求（假设此时scheme是HTTP），带有以下头：<br>Upgrade: h2c<br>HTTP2-Settings<br>服务器端返回：<br>101状态码，转换协议；<br>Connection: Upgrade<br>Upgrade: h2c 或者 200/404</p>
</li>
<li><p>HTTP/2.0 Over TLS版:<br>客户端向服务器端请求<br>TLS + ALPN(Application Layer Protocol Negotiation)/NPN<br>服务器端返回:<br>TLS 握手 并返回支持的HTTP协议<br><img src="https://mc.qcloudimg.com/static/img/851afadec019cc1f93f28e119c3f6f53/image.jpg" alt=""></p>
</li>
</ol>
<p>b. ALPN协商过程</p>
<p>参考TLS握手过程图，下面是增加ALPN协商的具体过程：<br>客户端添加一个ProtocolNameList字段，包含支持的HTTP协议到ClientHello消息中；<br>服务器端查看ProtocolNameList字段后通过ServerHello消息返回ProtocolName字段，表明被选定的协议；<br>通过实现ALPN，不再需要单独请求一次服务器带上Upgrade: h2c。</p>
<p>c. False Start</p>
<p>通常情况下，使用ALPN会搭配使用False Start，客户端在完成TLS握手前提前发送加密后的应用数据，将两次RTT TLS握手减少为一次；不过需要同时支持ALPN（NPN已经很少用啦）和前向安全性。</p>
<p>d. HSTS</p>
<p>HTTP Strict Transport Security（简称为HSTS）是一个安全功能，告诉浏览器只能通过HTTPS访问当前资源，禁止HTTP方式。<br>如果用户输入域名<a href="http://www.qq.com，" target="_blank" rel="noopener">www.qq.com，</a> 浏览器首先会去请求<a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a> ,请求过程是明文非加密的，此时容易被中间人攻击，让网路恶意中间商直接接触到用户信息；而HSTS是用户请求时，服务器告诉客户端，下次来请求直接请求https:// ，而不要再请求服务器来跳转到https。<br>同时，开启HSTS后，如果证书认证不通过（比如遭到中间人攻击），浏览器此时强制无法打开该网站。</p>
<p>流(Stream)：一个Stream是包含一条或多条信息，ID和优先级的双向通道；<br>消息(Message)：消息由帧组成；<br>帧(Frame)：帧有不同的类型，并且是混合的。他们通过stream id被重新组装进消息中。</p>
<p>二进制帧的处理：</p>
<p><img src="https://mc.qcloudimg.com/static/img/811215f81ab8ff1af5ee542841cd3575/image.jpg" alt=""></p>
<p>HTTP2的二进制帧是9字节(72 bit)<br>长度：24bit，也就是理论上可以携带2^24字节的数据。但通常由于SETTINGS_MAX_FRAME_SIZE的设置，不能发送超过2^14(16384)字节的数据；<br>类型：8bit，决定了该帧的类型；<br>DATA : 数据帧<br>HEADERS : 头部帧<br>PRIORITY : 设置流的优先级<br>RST_STREAM : 终止流<br>SETTINGS : 设置连接参数<br>PUSH_PROMISE : 服务器推送模拟请求帧<br>PING : 用来计算RTT时间和看是否服务器挂了的Stream<br>GOAWAY : 告诉对方停止再向当前连接创建stream<br>WINDOW_UPDATE : 流量控制<br>保留字段：1bit，一般为0。</p>
<p>Stream ID：31bit，Stream标识，理论上可以有2147483648，超过这么多stream怎么办呢？</p>
<p>如果是客户端无法再创建新的stream id，可以直接创建新的TCP连接，stream id被重置。</p>
<p>如果是服务器端无法再创建新的stream id，服务器将会给客户端发一个 GOAWAY帧，客户端无法再向该服务器创建stream，不得不新建TCP连接。</p>
<p>新的特性：<br>a. 多路复用<br><img src="https://mc.qcloudimg.com/static/img/ca52b1f8f8397cd11b0164bf2adda94d/image.jpg" alt=""></p>
<p>HTTP/2.0中，数据在发送端被切分为更小的数据帧用以高效利用链接。</p>
<p>HTTP 1.1时代，再不开启Keep-alive的情况下，每一个请求会占用一个TCP连接，而HTTP/2将请求和响应消息拆分为各自独立的帧，交错的发送，然后再在接收端重新装配组合。有什么好处呢？</p>
<p>交错的多个请求/响应之间互现不会被阻塞</p>
<p>HTTP/1.1时代的Keep-alive也是保持同一个TCP连接，但是由于请求/接收有先后，后面的请求资源会被前面的资源阻塞（没收到响应时不会发新的请求），如下图最左和最右边所示，即便是相比HTTP管道，优化也是巨大的：<br><img src="https://mc.qcloudimg.com/static/img/228acfed18be7661c6da162b0c56b777/image.jpg" alt=""><br>减少了不必要的延时，改善了网路的利用率(多路复用和资源优先级/依赖关系搭配使用，使得页面重度依赖的资源优先传输)；</p>
<p>b. 头部压缩</p>
<p>HTTP/2.0使用HPACK来给头部压缩；<br>值通过霍夫曼编码；<br>之前发送的值都被索引起来，之后使用时发现之前发送过该Header字段，并且值相同，就会沿用之前的索引来指代那个Header值；<br>Cookies：在HTTP/2.0中，Cookie也将会变为键值对索引起来，而不是一长串字符串。</p>
<p>c. 资源优先级/依赖关系<br>资源优先级/依赖关系通过stream权重和dependency来设置。<br>通过上图可以看到，有一列是叫作Priority，初始设置是根据Content-type来设置优先级的，比如HTML是Highest，CSS是High，然后JS是Medium。<br>Stream 权重值可以设置为1到256之间。<br>Stream可以明确的表示依赖关系。<br>注意，一定要理解权重和依赖，权重值和依赖关系是作为带宽资源/服务器/客户端处理资源的建议值，但并不能保证他们有特定的传输顺序。</p>
<p>d. 流量控制<br>与TCP的流量控制类似，不过HTTP/2.0的流量控制可以到具体帧，而TCP是TCP连接层面上的。注意：流量控制目前只对DATA帧有效！流量控制的算法没有具体要求使用哪一种，但是大概实现的功能是这样的：<br>两端收发保有一个流量控制(window)窗口；<br>发送端每发送一个DATA帧，就把窗口的大小递减，递减量为这个帧的大小，要是窗口大小小于该帧的大小，那么这个帧就必须被拆分。如果窗口值等于0，就不能发送任何帧。流量控制的初始默认窗口值大小为65535字节(理论上可以设置2^31-1字节也就是2147483647字节大小的窗口值)；<br>接收端可以通过发送WINDOW_UPDATE帧给发送端，发送端以帧内指定的窗口大小增量加到窗口大小限制上。</p>
<p>e. Server Push<br>Server Push的资源同样需要遵守同源策略，通过:authority来判断。<br>Server Push有什么好处呢：<br>推送的资源可以被客户端缓存；<br>推送的资源可以被不同的页面复用；<br>推送资源也是支持多路复用的；<br>推送资源可以被客户端拒绝掉(客户端接收到PUSH_PROMISE后，可以选择发送RST_PROMISE来拒绝接收，告诉服务器端不要再发送了，当然，此时可能已经有部分内容已经发送过来了)；</p>
<p>关于Http和Https的区别的点</p>
<p>HTTP和HTTPS的区别，概念层的区别<br>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：<br>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>http的隐患：</p>
<p>1、隐私泄露<br>由于 HTTP 本身是明文传输，用户和服务端之间的传输内容都能被中间者查看。也就是说 你在网上搜索、购物、访问的网点、点击的页面等信息，都可以被「中间人」获取。<br>2、页面劫持<br>隐私泄露的风险比较隐蔽，用户基本感知不到。但另外一类劫持的影响就非常明显非常直接了——页面劫持，也就是直接篡改用户的浏览页面。有很多页面劫持很简单粗暴，直接插入第三方广告或者运营商的流量提示信息。<br>3、劫持路径及分类<br>那劫持到底是如何产生的呢？从技术上来讲比较简单，在内容经过的地方进行监听篡改就行了。但要想把整个劫持的产业链条摸清楚，需要深入黑产内部，比较困难。有一点可以肯定的是，劫持大部分都是在中间的网络节点发生的，又叫「中间人」(MITM， man in the middle)。如下图所示<br><img src="https://blog-10039692.file.myqcloud.com/1486471416100_7812_1486471416521.png" alt=""><br>由于信息传输都需要经过上述的「中间人节点」，它们又拥有信息的读写权限，如果信息没有加密，也没有校验，那么想要查看隐私，篡改页面，对于「中间人」来说可谓是轻而易举。</p>
<p>那劫持又有哪些主要的分类呢?根据劫持路径划分的话，主要是下图所示的三类：<br><img src="https://blog-10039692.file.myqcloud.com/1486471476410_5533_1486471477594.png" alt=""><br>DNS 劫持，客户端劫持和链路劫持。 根据我们的不完全统计，业务遇到的绝大部分劫持 (90%)都属于链路劫持。</p>
<p>HTTPS 为什么能很好的解决链路劫持呢？主要是三大武器:<br>1、身份认证—防假冒，防抵赖<br>每次建立一个全新的 HTTPS 连接时，都需要对身份进行认证，确保用户访问的是正确的目的网站。<br><img src="https://blog-10039692.file.myqcloud.com/1486471569259_8625_1486471569506.png" alt=""></p>
<p>2、内容加密—防窃听<br>内容加密意味端对端的通信内容全都是密文，中间人无法直接查看到明文，HTTPS 所有的应用层内容都是通过对称加密来实现加密和解密的。<br><img src="https://blog-10039692.file.myqcloud.com/1486471621111_7034_1486471621290.png" alt=""></p>
<p>3、一致性校验—防篡改<br>通过对数据和共享密钥的 MAC 码来防止中间者篡改消息内容，确保数据的一致性。<br><img src="https://blog-10039692.file.myqcloud.com/1486471674398_2270_1486471675064.png" alt=""></p>
<p>网络耗时。由于协议的规定，必须要进行的网络传输。比如 SSL 完全握手，302 跳转等。最坏情况下可能要增加 7 个 RTT。<br>计算耗时。无论是客户端还是服务端，都需要进行对称加解密，协议解析，私钥计算，证书校验等计算，增加大量的计算时间。</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1486471843113_1438_1486471843834.png" alt=""></p>
<p>Charles可以用作中间的HTTPS代理，允许您以纯文本形式查看Web浏览器和SSL Web服务器之间的通信。</p>
<p>Charles通过成为中间人来做到这一点。替换浏览器看到服务器的证书，Charles动态地为服务器生成证书，并用它自己的根证书（Charles的CA证书）签名。Charles接收服务器的证书，而您的浏览器接收Charles的证书。因此，您将看到一个安全警告，指示根权限不受信任。</p>
<p>先说一下https使用的非对称加密的原理。等等说非对称加密之前还要说下对称加密的原理。简单来说，对称加密就是加密解密使用同一个密钥。浏览器和服务器交互的话一般会动态生成一个密钥，所以密钥如何交换就成了问题。</p>
<p>下面引入非对称密钥，非对称加密主要用于密钥交换（也叫密钥协商），能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。</p>
<p>密钥交换过程：服务器的公钥是公开的，私钥是不公开的。浏览器先向服务器取得公钥，然后用公钥加密自己的私钥连同自己私钥加密的请求一并发送给服务器。服务器使用自己私钥解密得到浏览器的私钥，使用浏览器的私钥解密请求。然后再用浏览器的私钥加密response发送回浏览器(此处之前笔误写成服务器了)。</p>
<p>中间人攻击是先伪装服务器向浏览器发送伪造的公钥，从而取得浏览器的私钥。这样就完成的浏览器端的解密。服务器端类似。</p>
<p>但是！！！https是可以防止中间人攻击的，因为服务器的公钥是用证书的。charles伪造的证书一般浏览器会警告，所以我们需要将charles的证书认为可靠的。从而实现中间人。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/HTTP的总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/HTTP的总结/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-25T20:08:18+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于Http的总结</p>
<ol>
<li><p>HTTP/1.1<br>TCP连接是需要三次握手的，同时，多个TCP连接也会给服务器带来资源的消耗，在HTTP/1.1中，每个请求回复都是一次TCP连接（未开启Keep-Alive的情况下），并且，同时传输多个资源时，会有队首阻塞的问题，造成网络资源无法有效利用。</p>
</li>
<li><p>安全<br>对于大多数人来说，下图的情况几乎都有遇到过（电脑或手机里）。万恶的运营商或者网络接入WiFi提供商劫持我们的网络，修改网络的内容，给我们带来了很大的困扰。</p>
</li>
</ol>
<p>现在，HTTP/2.0出现了。其实HTTP/2.0是支持Clear Text版和Over TLS版，由于现有支持HTTP/2.0的浏览器都是实现的Over TLS版，故本文的HTTP/2.0都是讲的是HTTPS版HTTP/2.0。</p>
<ol>
<li><p>Clear Text版:<br>客户端向服务端请求（假设此时scheme是HTTP），带有以下头：<br>Upgrade: h2c<br>HTTP2-Settings<br>服务器端返回：<br>101状态码，转换协议；<br>Connection: Upgrade<br>Upgrade: h2c 或者 200/404</p>
</li>
<li><p>HTTP/2.0 Over TLS版:<br>客户端向服务器端请求<br>TLS + ALPN(Application Layer Protocol Negotiation)/NPN<br>服务器端返回:<br>TLS 握手 并返回支持的HTTP协议<br><img src="https://mc.qcloudimg.com/static/img/851afadec019cc1f93f28e119c3f6f53/image.jpg" alt=""></p>
</li>
</ol>
<p>b. ALPN协商过程</p>
<p>参考TLS握手过程图，下面是增加ALPN协商的具体过程：<br>客户端添加一个ProtocolNameList字段，包含支持的HTTP协议到ClientHello消息中；<br>服务器端查看ProtocolNameList字段后通过ServerHello消息返回ProtocolName字段，表明被选定的协议；<br>通过实现ALPN，不再需要单独请求一次服务器带上Upgrade: h2c。</p>
<p>c. False Start</p>
<p>通常情况下，使用ALPN会搭配使用False Start，客户端在完成TLS握手前提前发送加密后的应用数据，将两次RTT TLS握手减少为一次；不过需要同时支持ALPN（NPN已经很少用啦）和前向安全性。</p>
<p>d. HSTS</p>
<p>HTTP Strict Transport Security（简称为HSTS）是一个安全功能，告诉浏览器只能通过HTTPS访问当前资源，禁止HTTP方式。<br>如果用户输入域名<a href="http://www.qq.com，" target="_blank" rel="noopener">www.qq.com，</a> 浏览器首先会去请求<a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a> ,请求过程是明文非加密的，此时容易被中间人攻击，让网路恶意中间商直接接触到用户信息；而HSTS是用户请求时，服务器告诉客户端，下次来请求直接请求https:// ，而不要再请求服务器来跳转到https。<br>同时，开启HSTS后，如果证书认证不通过（比如遭到中间人攻击），浏览器此时强制无法打开该网站。</p>
<p>流(Stream)：一个Stream是包含一条或多条信息，ID和优先级的双向通道；<br>消息(Message)：消息由帧组成；<br>帧(Frame)：帧有不同的类型，并且是混合的。他们通过stream id被重新组装进消息中。</p>
<p>二进制帧的处理：</p>
<p><img src="https://mc.qcloudimg.com/static/img/811215f81ab8ff1af5ee542841cd3575/image.jpg" alt=""></p>
<p>HTTP2的二进制帧是9字节(72 bit)<br>长度：24bit，也就是理论上可以携带2^24字节的数据。但通常由于SETTINGS_MAX_FRAME_SIZE的设置，不能发送超过2^14(16384)字节的数据；<br>类型：8bit，决定了该帧的类型；<br>DATA : 数据帧<br>HEADERS : 头部帧<br>PRIORITY : 设置流的优先级<br>RST_STREAM : 终止流<br>SETTINGS : 设置连接参数<br>PUSH_PROMISE : 服务器推送模拟请求帧<br>PING : 用来计算RTT时间和看是否服务器挂了的Stream<br>GOAWAY : 告诉对方停止再向当前连接创建stream<br>WINDOW_UPDATE : 流量控制<br>保留字段：1bit，一般为0。</p>
<p>Stream ID：31bit，Stream标识，理论上可以有2147483648，超过这么多stream怎么办呢？</p>
<p>如果是客户端无法再创建新的stream id，可以直接创建新的TCP连接，stream id被重置。</p>
<p>如果是服务器端无法再创建新的stream id，服务器将会给客户端发一个 GOAWAY帧，客户端无法再向该服务器创建stream，不得不新建TCP连接。</p>
<p>新的特性：<br>a. 多路复用<br><img src="https://mc.qcloudimg.com/static/img/ca52b1f8f8397cd11b0164bf2adda94d/image.jpg" alt=""></p>
<p>HTTP/2.0中，数据在发送端被切分为更小的数据帧用以高效利用链接。</p>
<p>HTTP 1.1时代，再不开启Keep-alive的情况下，每一个请求会占用一个TCP连接，而HTTP/2将请求和响应消息拆分为各自独立的帧，交错的发送，然后再在接收端重新装配组合。有什么好处呢？</p>
<p>交错的多个请求/响应之间互现不会被阻塞</p>
<p>HTTP/1.1时代的Keep-alive也是保持同一个TCP连接，但是由于请求/接收有先后，后面的请求资源会被前面的资源阻塞（没收到响应时不会发新的请求），如下图最左和最右边所示，即便是相比HTTP管道，优化也是巨大的：<br><img src="https://mc.qcloudimg.com/static/img/228acfed18be7661c6da162b0c56b777/image.jpg" alt=""><br>减少了不必要的延时，改善了网路的利用率(多路复用和资源优先级/依赖关系搭配使用，使得页面重度依赖的资源优先传输)；</p>
<p>b. 头部压缩</p>
<p>HTTP/2.0使用HPACK来给头部压缩；<br>值通过霍夫曼编码；<br>之前发送的值都被索引起来，之后使用时发现之前发送过该Header字段，并且值相同，就会沿用之前的索引来指代那个Header值；<br>Cookies：在HTTP/2.0中，Cookie也将会变为键值对索引起来，而不是一长串字符串。</p>
<p>c. 资源优先级/依赖关系<br>资源优先级/依赖关系通过stream权重和dependency来设置。<br>通过上图可以看到，有一列是叫作Priority，初始设置是根据Content-type来设置优先级的，比如HTML是Highest，CSS是High，然后JS是Medium。<br>Stream 权重值可以设置为1到256之间。<br>Stream可以明确的表示依赖关系。<br>注意，一定要理解权重和依赖，权重值和依赖关系是作为带宽资源/服务器/客户端处理资源的建议值，但并不能保证他们有特定的传输顺序。</p>
<p>d. 流量控制<br>与TCP的流量控制类似，不过HTTP/2.0的流量控制可以到具体帧，而TCP是TCP连接层面上的。注意：流量控制目前只对DATA帧有效！流量控制的算法没有具体要求使用哪一种，但是大概实现的功能是这样的：<br>两端收发保有一个流量控制(window)窗口；<br>发送端每发送一个DATA帧，就把窗口的大小递减，递减量为这个帧的大小，要是窗口大小小于该帧的大小，那么这个帧就必须被拆分。如果窗口值等于0，就不能发送任何帧。流量控制的初始默认窗口值大小为65535字节(理论上可以设置2^31-1字节也就是2147483647字节大小的窗口值)；<br>接收端可以通过发送WINDOW_UPDATE帧给发送端，发送端以帧内指定的窗口大小增量加到窗口大小限制上。</p>
<p>e. Server Push<br>Server Push的资源同样需要遵守同源策略，通过:authority来判断。<br>Server Push有什么好处呢：<br>推送的资源可以被客户端缓存；<br>推送的资源可以被不同的页面复用；<br>推送资源也是支持多路复用的；<br>推送资源可以被客户端拒绝掉(客户端接收到PUSH_PROMISE后，可以选择发送RST_PROMISE来拒绝接收，告诉服务器端不要再发送了，当然，此时可能已经有部分内容已经发送过来了)；</p>
<p>关于Http和Https的区别的点</p>
<p>HTTP和HTTPS的区别，概念层的区别<br>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：<br>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>http的隐患：</p>
<p>1、隐私泄露<br>由于 HTTP 本身是明文传输，用户和服务端之间的传输内容都能被中间者查看。也就是说 你在网上搜索、购物、访问的网点、点击的页面等信息，都可以被「中间人」获取。<br>2、页面劫持<br>隐私泄露的风险比较隐蔽，用户基本感知不到。但另外一类劫持的影响就非常明显非常直接了——页面劫持，也就是直接篡改用户的浏览页面。有很多页面劫持很简单粗暴，直接插入第三方广告或者运营商的流量提示信息。<br>3、劫持路径及分类<br>那劫持到底是如何产生的呢？从技术上来讲比较简单，在内容经过的地方进行监听篡改就行了。但要想把整个劫持的产业链条摸清楚，需要深入黑产内部，比较困难。有一点可以肯定的是，劫持大部分都是在中间的网络节点发生的，又叫「中间人」(MITM， man in the middle)。如下图所示<br><img src="https://blog-10039692.file.myqcloud.com/1486471416100_7812_1486471416521.png" alt=""><br>由于信息传输都需要经过上述的「中间人节点」，它们又拥有信息的读写权限，如果信息没有加密，也没有校验，那么想要查看隐私，篡改页面，对于「中间人」来说可谓是轻而易举。</p>
<p>那劫持又有哪些主要的分类呢?根据劫持路径划分的话，主要是下图所示的三类：<br><img src="https://blog-10039692.file.myqcloud.com/1486471476410_5533_1486471477594.png" alt=""><br>DNS 劫持，客户端劫持和链路劫持。 根据我们的不完全统计，业务遇到的绝大部分劫持 (90%)都属于链路劫持。</p>
<p>HTTPS 为什么能很好的解决链路劫持呢？主要是三大武器:<br>1、身份认证—防假冒，防抵赖<br>每次建立一个全新的 HTTPS 连接时，都需要对身份进行认证，确保用户访问的是正确的目的网站。<br><img src="https://blog-10039692.file.myqcloud.com/1486471569259_8625_1486471569506.png" alt=""></p>
<p>2、内容加密—防窃听<br>内容加密意味端对端的通信内容全都是密文，中间人无法直接查看到明文，HTTPS 所有的应用层内容都是通过对称加密来实现加密和解密的。<br><img src="https://blog-10039692.file.myqcloud.com/1486471621111_7034_1486471621290.png" alt=""></p>
<p>3、一致性校验—防篡改<br>通过对数据和共享密钥的 MAC 码来防止中间者篡改消息内容，确保数据的一致性。<br><img src="https://blog-10039692.file.myqcloud.com/1486471674398_2270_1486471675064.png" alt=""></p>
<p>网络耗时。由于协议的规定，必须要进行的网络传输。比如 SSL 完全握手，302 跳转等。最坏情况下可能要增加 7 个 RTT。<br>计算耗时。无论是客户端还是服务端，都需要进行对称加解密，协议解析，私钥计算，证书校验等计算，增加大量的计算时间。</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1486471843113_1438_1486471843834.png" alt=""></p>
<p>Charles可以用作中间的HTTPS代理，允许您以纯文本形式查看Web浏览器和SSL Web服务器之间的通信。</p>
<p>Charles通过成为中间人来做到这一点。替换浏览器看到服务器的证书，Charles动态地为服务器生成证书，并用它自己的根证书（Charles的CA证书）签名。Charles接收服务器的证书，而您的浏览器接收Charles的证书。因此，您将看到一个安全警告，指示根权限不受信任。</p>
<p>先说一下https使用的非对称加密的原理。等等说非对称加密之前还要说下对称加密的原理。简单来说，对称加密就是加密解密使用同一个密钥。浏览器和服务器交互的话一般会动态生成一个密钥，所以密钥如何交换就成了问题。</p>
<p>下面引入非对称密钥，非对称加密主要用于密钥交换（也叫密钥协商），能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。</p>
<p>密钥交换过程：服务器的公钥是公开的，私钥是不公开的。浏览器先向服务器取得公钥，然后用公钥加密自己的私钥连同自己私钥加密的请求一并发送给服务器。服务器使用自己私钥解密得到浏览器的私钥，使用浏览器的私钥解密请求。然后再用浏览器的私钥加密response发送回浏览器(此处之前笔误写成服务器了)。</p>
<p>中间人攻击是先伪装服务器向浏览器发送伪造的公钥，从而取得浏览器的私钥。这样就完成的浏览器端的解密。服务器端类似。</p>
<p>但是！！！https是可以防止中间人攻击的，因为服务器的公钥是用证书的。charles伪造的证书一般浏览器会警告，所以我们需要将charles的证书认为可靠的。从而实现中间人。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/基础面试题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/基础面试题/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T09:44:42+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于一些基础的面试题：</p>
<p>Runtime的消息转发机制</p>
<p>Runloop的工作原理</p>
<p>内存管理</p>
<p>block</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/javaCore的说明/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yida">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="益达的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/javaCore的说明/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-18T19:56:16+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于javaCore"><a href="#关于javaCore" class="headerlink" title="关于javaCore"></a>关于javaCore</h3><p>一个JSVirtualMachine的实例就是一个完整独立的JavaScript的执行环境，为JavaScript的执行提供底层资源。</p>
<p>这个类主要用来做两件事情：</p>
<p>实现并发的JavaScript执行<br>JavaScript和Objective-C桥接对象的内存管理</p>
<p>每一个JavaScript上下文（JSContext对象）都归属于一个虚拟机（JSVirtualMachine）。每个虚拟机可以包含多个不同的上下文，并允许在这些不同的上下文之间传值（JSValue对象）。</p>
<p>然而，每个虚拟机都是完整且独立的，有其独立的堆空间和垃圾回收器（garbage collector ），GC无法处理别的虚拟机堆中的对象，因此你不能把一个虚拟机中创建的值传给另一个虚拟机。</p>
<p>线程和JavaScript的并发执行</p>
<p>JavaScriptCore API都是线程安全的。你可以在任意线程创建JSValue或者执行JS代码，然而，所有其他想要使用该虚拟机的线程都要等待。</p>
<p>如果想并发执行JS，需要使用多个不同的虚拟机来实现。<br>可以在子线程中执行JS代码。</p>
<p>三个线程分别异步执行每秒1次的js log，首先会休眠1秒。</p>
<p>在context上执行一个休眠5秒的JS函数。</p>
<p>首先执行的应该是休眠5秒的JS函数，在此期间，context所处的虚拟机上的其他调用都会处于等待状态，因此tick和tick_2在前5秒都不会有执行。</p>
<p>而context1所处的虚拟机仍然可以正常执行tick_1。</p>
<p>休眠5秒结束后，tick和tick_2才会开始执行（不保证先后顺序）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yida</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yida</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
